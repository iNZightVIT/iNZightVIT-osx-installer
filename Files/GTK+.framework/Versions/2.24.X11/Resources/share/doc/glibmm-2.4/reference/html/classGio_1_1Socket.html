<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>glibmm: Gio::Socket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.35.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGio.html">Gio</a></li><li class="navelem"><a class="el" href="classGio_1_1Socket.html">Socket</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classGio_1_1Socket-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Gio::Socket Class Reference<div class="ingroups"><a class="el" href="group__NetworkIO.html">Portable Network I/O Functionality</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Low-level socket object.  
 <a href="classGio_1_1Socket.html#details">More...</a></p>

<p><code>#include &lt;giomm/socket.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::Socket:</div>
<div class="dyncontent">
<div class="center"><img src="classGio_1_1Socket__inherit__graph.png" border="0" usemap="#Gio_1_1Socket_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1Socket_inherit__map" id="Gio_1_1Socket_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8efac59d8562ceb635b76fe70087572d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8efac59d8562ceb635b76fe70087572d">~Socket</a> ()</td></tr>
<tr class="separator:a8efac59d8562ceb635b76fe70087572d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d51f7bcd83450331d7261898e9007d6"><td class="memItemLeft" align="right" valign="top">GSocket*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a1d51f7bcd83450331d7261898e9007d6">gobj</a> ()</td></tr>
<tr class="memdesc:a1d51f7bcd83450331d7261898e9007d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a1d51f7bcd83450331d7261898e9007d6">More...</a><br/></td></tr>
<tr class="separator:a1d51f7bcd83450331d7261898e9007d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c7fa832ce1c984a7bbceb4d7ba93a8"><td class="memItemLeft" align="right" valign="top">const GSocket*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a51c7fa832ce1c984a7bbceb4d7ba93a8">gobj</a> () const </td></tr>
<tr class="memdesc:a51c7fa832ce1c984a7bbceb4d7ba93a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a51c7fa832ce1c984a7bbceb4d7ba93a8">More...</a><br/></td></tr>
<tr class="separator:a51c7fa832ce1c984a7bbceb4d7ba93a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fe06b1a579c40b596933da0ded4e37"><td class="memItemLeft" align="right" valign="top">GSocket*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ae2fe06b1a579c40b596933da0ded4e37">gobj_copy</a> ()</td></tr>
<tr class="memdesc:ae2fe06b1a579c40b596933da0ded4e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.  <a href="#ae2fe06b1a579c40b596933da0ded4e37">More...</a><br/></td></tr>
<tr class="separator:ae2fe06b1a579c40b596933da0ded4e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16044bba5924c183cff90f0a4cf47394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a16044bba5924c183cff90f0a4cf47394">bind</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, bool allow_reuse)</td></tr>
<tr class="memdesc:a16044bba5924c183cff90f0a4cf47394"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a socket is created it is attached to an address family, but it doesn't have an address in this family.  <a href="#a16044bba5924c183cff90f0a4cf47394">More...</a><br/></td></tr>
<tr class="separator:a16044bba5924c183cff90f0a4cf47394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16eed3fd42f3769b5e608f96db214fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#af16eed3fd42f3769b5e608f96db214fd">listen</a> ()</td></tr>
<tr class="memdesc:af16eed3fd42f3769b5e608f96db214fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the socket as a server socket, i.e. a socket that is used to accept incoming requests using g_socket_accept().  <a href="#af16eed3fd42f3769b5e608f96db214fd">More...</a><br/></td></tr>
<tr class="separator:af16eed3fd42f3769b5e608f96db214fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137ae34a8f211eaed11f9a58ca6b3f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a137ae34a8f211eaed11f9a58ca6b3f5e">accept</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a137ae34a8f211eaed11f9a58ca6b3f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept incoming connections on a connection-based socket.  <a href="#a137ae34a8f211eaed11f9a58ca6b3f5e">More...</a><br/></td></tr>
<tr class="separator:a137ae34a8f211eaed11f9a58ca6b3f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6c036db4e484e6b7f0419962254888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888">accept</a> ()</td></tr>
<tr class="memdesc:a4b6c036db4e484e6b7f0419962254888"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888" title="A accept() convenience overload.">accept()</a> convenience overload.  <a href="#a4b6c036db4e484e6b7f0419962254888">More...</a><br/></td></tr>
<tr class="separator:a4b6c036db4e484e6b7f0419962254888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab220f5714a6116d35e846b00f4ad23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23">connect</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a9ab220f5714a6116d35e846b00f4ad23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the socket to the specified remote address.  <a href="#a9ab220f5714a6116d35e846b00f4ad23">More...</a><br/></td></tr>
<tr class="separator:a9ab220f5714a6116d35e846b00f4ad23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0828763fe472d46aed833fad30af1c0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a0828763fe472d46aed833fad30af1c0b">connect</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address)</td></tr>
<tr class="memdesc:a0828763fe472d46aed833fad30af1c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23" title="Connect the socket to the specified remote address.">connect()</a> convenience overload.  <a href="#a0828763fe472d46aed833fad30af1c0b">More...</a><br/></td></tr>
<tr class="separator:a0828763fe472d46aed833fad30af1c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b68dc0948e6dfa158487c314f9a521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a06b68dc0948e6dfa158487c314f9a521">check_connect_result</a> ()</td></tr>
<tr class="memdesc:a06b68dc0948e6dfa158487c314f9a521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks and resets the pending connect error for the socket.  <a href="#a06b68dc0948e6dfa158487c314f9a521">More...</a><br/></td></tr>
<tr class="separator:a06b68dc0948e6dfa158487c314f9a521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742403f4d076ba9050a435d95fea5d1c"><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a742403f4d076ba9050a435d95fea5d1c">receive</a> (char* buffer, gsize size, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a742403f4d076ba9050a435d95fea5d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data (up to <em>size</em> bytes) from a socket.  <a href="#a742403f4d076ba9050a435d95fea5d1c">More...</a><br/></td></tr>
<tr class="separator:a742403f4d076ba9050a435d95fea5d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73463b7677ffdfddaced49bdf170b4b6"><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a73463b7677ffdfddaced49bdf170b4b6">receive</a> (char* buffer, gsize size)</td></tr>
<tr class="memdesc:a73463b7677ffdfddaced49bdf170b4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#a742403f4d076ba9050a435d95fea5d1c" title="Receive data (up to size bytes) from a socket.">receive()</a> convenience overload.  <a href="#a73463b7677ffdfddaced49bdf170b4b6">More...</a><br/></td></tr>
<tr class="separator:a73463b7677ffdfddaced49bdf170b4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2d4382139553881ae139920e8db93e"><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4d2d4382139553881ae139920e8db93e">receive_from</a> (<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, char* buffer, gsize size, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="separator:a4d2d4382139553881ae139920e8db93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056fd2c3609971d5befcf2b4ccf51aa3"><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a056fd2c3609971d5befcf2b4ccf51aa3">receive_from</a> (<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, char* buffer, gsize size)</td></tr>
<tr class="separator:a056fd2c3609971d5befcf2b4ccf51aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5c3145109841e0406150ad0b7f547c"><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adc5c3145109841e0406150ad0b7f547c">send</a> (const gchar* buffer, gsize size, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:adc5c3145109841e0406150ad0b7f547c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to send <em>size</em> bytes from <em>buffer</em> on the socket.  <a href="#adc5c3145109841e0406150ad0b7f547c">More...</a><br/></td></tr>
<tr class="separator:adc5c3145109841e0406150ad0b7f547c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986efa2a33528ce5aba0d7c6a7be1b65"><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a986efa2a33528ce5aba0d7c6a7be1b65">send</a> (const gchar* buffer, gsize size)</td></tr>
<tr class="memdesc:a986efa2a33528ce5aba0d7c6a7be1b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#adc5c3145109841e0406150ad0b7f547c" title="Tries to send size bytes from buffer on the socket.">send()</a> convenience overload.  <a href="#a986efa2a33528ce5aba0d7c6a7be1b65">More...</a><br/></td></tr>
<tr class="separator:a986efa2a33528ce5aba0d7c6a7be1b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2d4ff883535e696b6cdaacd730f729"><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8b2d4ff883535e696b6cdaacd730f729">send_to</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, const char* buffer, gsize size, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a8b2d4ff883535e696b6cdaacd730f729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to send <em>size</em> bytes from <em>buffer</em> to <em>address</em>.  <a href="#a8b2d4ff883535e696b6cdaacd730f729">More...</a><br/></td></tr>
<tr class="separator:a8b2d4ff883535e696b6cdaacd730f729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929c8c4e0c10a39d65358853e94d9c4f"><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a929c8c4e0c10a39d65358853e94d9c4f">send_to</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp; address, const char* buffer, gsize size)</td></tr>
<tr class="memdesc:a929c8c4e0c10a39d65358853e94d9c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#a8b2d4ff883535e696b6cdaacd730f729" title="Tries to send size bytes from buffer to address.">send_to()</a> convenience overload.  <a href="#a929c8c4e0c10a39d65358853e94d9c4f">More...</a><br/></td></tr>
<tr class="separator:a929c8c4e0c10a39d65358853e94d9c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab30d39b9e73fef6401c76d1d4edc118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aab30d39b9e73fef6401c76d1d4edc118">close</a> ()</td></tr>
<tr class="memdesc:aab30d39b9e73fef6401c76d1d4edc118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the socket, shutting down any active connection.  <a href="#aab30d39b9e73fef6401c76d1d4edc118">More...</a><br/></td></tr>
<tr class="separator:aab30d39b9e73fef6401c76d1d4edc118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac925f7e6592ad4a96afe0f75411a96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a7ac925f7e6592ad4a96afe0f75411a96">is_closed</a> ()</td></tr>
<tr class="memdesc:a7ac925f7e6592ad4a96afe0f75411a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a socket is closed.  <a href="#a7ac925f7e6592ad4a96afe0f75411a96">More...</a><br/></td></tr>
<tr class="separator:a7ac925f7e6592ad4a96afe0f75411a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f685bc040e9e10abe093deec0719fd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4f685bc040e9e10abe093deec0719fd7">shutdown</a> (bool shutdown_read, bool shutdown_write)</td></tr>
<tr class="memdesc:a4f685bc040e9e10abe093deec0719fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down part of a full-duplex connection.  <a href="#a4f685bc040e9e10abe093deec0719fd7">More...</a><br/></td></tr>
<tr class="separator:a4f685bc040e9e10abe093deec0719fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9561511b77e652271705fbfdb2f8f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aea9561511b77e652271705fbfdb2f8f2">is_connected</a> ()</td></tr>
<tr class="memdesc:aea9561511b77e652271705fbfdb2f8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the socket is connected.  <a href="#aea9561511b77e652271705fbfdb2f8f2">More...</a><br/></td></tr>
<tr class="separator:aea9561511b77e652271705fbfdb2f8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd0af5978112d1c8e2e68e51c9b99c5"><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a3cd0af5978112d1c8e2e68e51c9b99c5">get_available_bytes</a> () const </td></tr>
<tr class="memdesc:a3cd0af5978112d1c8e2e68e51c9b99c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of data pending in the OS input buffer.  <a href="#a3cd0af5978112d1c8e2e68e51c9b99c5">More...</a><br/></td></tr>
<tr class="separator:a3cd0af5978112d1c8e2e68e51c9b99c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fdc5d814fd61abab15ec03c7da20ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a86fdc5d814fd61abab15ec03c7da20ec">condition_check</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition)</td></tr>
<tr class="memdesc:a86fdc5d814fd61abab15ec03c7da20ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks on the readiness of <em>socket</em> to perform operations.  <a href="#a86fdc5d814fd61abab15ec03c7da20ec">More...</a><br/></td></tr>
<tr class="separator:a86fdc5d814fd61abab15ec03c7da20ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae28fa63035c05396064f5f4bb4fc36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36">condition_wait</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:aaae28fa63035c05396064f5f4bb4fc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for <em>condition</em> to become true on <em>socket</em>.  <a href="#aaae28fa63035c05396064f5f4bb4fc36">More...</a><br/></td></tr>
<tr class="separator:aaae28fa63035c05396064f5f4bb4fc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae420715a2050cc09112f178bae88ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a9ae420715a2050cc09112f178bae88ba">condition_wait</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition)</td></tr>
<tr class="memdesc:a9ae420715a2050cc09112f178bae88ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36" title="Waits for condition to become true on socket.">condition_wait()</a> convenience overload.  <a href="#a9ae420715a2050cc09112f178bae88ba">More...</a><br/></td></tr>
<tr class="separator:a9ae420715a2050cc09112f178bae88ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb32e1cc859b9689bf10169dfd70a9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#addb32e1cc859b9689bf10169dfd70a9c">condition_timed_wait</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition, gint64 timeout, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:addb32e1cc859b9689bf10169dfd70a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for up to <em>timeout</em> microseconds for <em>condition</em> to become true on <em>socket</em>.  <a href="#addb32e1cc859b9689bf10169dfd70a9c">More...</a><br/></td></tr>
<tr class="separator:addb32e1cc859b9689bf10169dfd70a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a3736a74c730c76e7c9a1670c3fbdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a71a3736a74c730c76e7c9a1670c3fbdd">condition_timed_wait</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> condition, gint64 timeout)</td></tr>
<tr class="memdesc:a71a3736a74c730c76e7c9a1670c3fbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#addb32e1cc859b9689bf10169dfd70a9c" title="Waits for up to timeout microseconds for condition to become true on socket.">condition_timed_wait()</a> convenience overload.  <a href="#a71a3736a74c730c76e7c9a1670c3fbdd">More...</a><br/></td></tr>
<tr class="separator:a71a3736a74c730c76e7c9a1670c3fbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7b9d6cecc1c2234f9979b2ffb1b309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adc7b9d6cecc1c2234f9979b2ffb1b309">set_listen_backlog</a> (int backlog)</td></tr>
<tr class="memdesc:adc7b9d6cecc1c2234f9979b2ffb1b309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of outstanding connections allowed when listening on this socket.  <a href="#adc7b9d6cecc1c2234f9979b2ffb1b309">More...</a><br/></td></tr>
<tr class="separator:adc7b9d6cecc1c2234f9979b2ffb1b309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a9e70db9abc7fc6383641afde8ee6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a22a9e70db9abc7fc6383641afde8ee6f">get_listen_backlog</a> () const </td></tr>
<tr class="memdesc:a22a9e70db9abc7fc6383641afde8ee6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the listen backlog setting of the socket.  <a href="#a22a9e70db9abc7fc6383641afde8ee6f">More...</a><br/></td></tr>
<tr class="separator:a22a9e70db9abc7fc6383641afde8ee6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d5a174441c255b69be9e809cdb96b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a51d5a174441c255b69be9e809cdb96b3">set_blocking</a> (bool blocking)</td></tr>
<tr class="memdesc:a51d5a174441c255b69be9e809cdb96b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the blocking mode of the socket.  <a href="#a51d5a174441c255b69be9e809cdb96b3">More...</a><br/></td></tr>
<tr class="separator:a51d5a174441c255b69be9e809cdb96b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffcbc226b08ae14856ea0dfe4d580e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a1ffcbc226b08ae14856ea0dfe4d580e9">get_blocking</a> () const </td></tr>
<tr class="memdesc:a1ffcbc226b08ae14856ea0dfe4d580e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the blocking mode of the socket.  <a href="#a1ffcbc226b08ae14856ea0dfe4d580e9">More...</a><br/></td></tr>
<tr class="separator:a1ffcbc226b08ae14856ea0dfe4d580e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfac67927584ae7afe53006eebb06d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a6cfac67927584ae7afe53006eebb06d7">set_keepalive</a> (bool keepalive)</td></tr>
<tr class="memdesc:a6cfac67927584ae7afe53006eebb06d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or unsets the So::KEEPALIVE flag on the underlying socket.  <a href="#a6cfac67927584ae7afe53006eebb06d7">More...</a><br/></td></tr>
<tr class="separator:a6cfac67927584ae7afe53006eebb06d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530b4adc3d295f7c000981286dee8019"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a530b4adc3d295f7c000981286dee8019">get_keepalive</a> () const </td></tr>
<tr class="memdesc:a530b4adc3d295f7c000981286dee8019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the keepalive mode of the socket.  <a href="#a530b4adc3d295f7c000981286dee8019">More...</a><br/></td></tr>
<tr class="separator:a530b4adc3d295f7c000981286dee8019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1e2a576e62d1e339eefae1fe12e24b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aac1e2a576e62d1e339eefae1fe12e24b">get_family</a> () const </td></tr>
<tr class="memdesc:aac1e2a576e62d1e339eefae1fe12e24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the socket family of the socket.  <a href="#aac1e2a576e62d1e339eefae1fe12e24b">More...</a><br/></td></tr>
<tr class="separator:aac1e2a576e62d1e339eefae1fe12e24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bb5076efcb022e31db9622a1c6e0ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#af3bb5076efcb022e31db9622a1c6e0ae">get_fd</a> () const </td></tr>
<tr class="memdesc:af3bb5076efcb022e31db9622a1c6e0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying OS socket object.  <a href="#af3bb5076efcb022e31db9622a1c6e0ae">More...</a><br/></td></tr>
<tr class="separator:af3bb5076efcb022e31db9622a1c6e0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654e36f8577b61a4df93a0a70479a7f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a654e36f8577b61a4df93a0a70479a7f1">get_local_address</a> () const </td></tr>
<tr class="memdesc:a654e36f8577b61a4df93a0a70479a7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the local address of a bound socket.  <a href="#a654e36f8577b61a4df93a0a70479a7f1">More...</a><br/></td></tr>
<tr class="separator:a654e36f8577b61a4df93a0a70479a7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce45788b8ac674bdf32a3ec8fb683c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#adce45788b8ac674bdf32a3ec8fb683c1">get_remote_address</a> () const </td></tr>
<tr class="memdesc:adce45788b8ac674bdf32a3ec8fb683c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the remove address of a connected socket.  <a href="#adce45788b8ac674bdf32a3ec8fb683c1">More...</a><br/></td></tr>
<tr class="separator:adce45788b8ac674bdf32a3ec8fb683c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecd966ee71eb956258b289cf63eb43e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4ecd966ee71eb956258b289cf63eb43e">get_protocol</a> () const </td></tr>
<tr class="memdesc:a4ecd966ee71eb956258b289cf63eb43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the socket protocol id the socket was created with.  <a href="#a4ecd966ee71eb956258b289cf63eb43e">More...</a><br/></td></tr>
<tr class="separator:a4ecd966ee71eb956258b289cf63eb43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cd563d5bc68362f3a574054ce63481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a05cd563d5bc68362f3a574054ce63481">get_socket_type</a> () const </td></tr>
<tr class="memdesc:a05cd563d5bc68362f3a574054ce63481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the socket type of the socket.  <a href="#a05cd563d5bc68362f3a574054ce63481">More...</a><br/></td></tr>
<tr class="separator:a05cd563d5bc68362f3a574054ce63481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33e646694bf6c5062683ba4b79d4fe1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ae33e646694bf6c5062683ba4b79d4fe1">speaks_ipv4</a> () const </td></tr>
<tr class="memdesc:ae33e646694bf6c5062683ba4b79d4fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a socket is capable of speaking IPv4.  <a href="#ae33e646694bf6c5062683ba4b79d4fe1">More...</a><br/></td></tr>
<tr class="separator:ae33e646694bf6c5062683ba4b79d4fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcda0eba8fcb30bd020624ce3f14d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Credentials.html">Credentials</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a2fcda0eba8fcb30bd020624ce3f14d8f">get_credentials</a> ()</td></tr>
<tr class="memdesc:a2fcda0eba8fcb30bd020624ce3f14d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the credentials of the foreign process connected to this socket, if any (e.g. it is only supported for SOCKET_FAMILY_UNIX sockets).  <a href="#a2fcda0eba8fcb30bd020624ce3f14d8f">More...</a><br/></td></tr>
<tr class="separator:a2fcda0eba8fcb30bd020624ce3f14d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc5b5f562eb0255d846a41bde23d0f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1Credentials.html">Credentials</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#afcc5b5f562eb0255d846a41bde23d0f7">get_credentials</a> () const </td></tr>
<tr class="memdesc:afcc5b5f562eb0255d846a41bde23d0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the credentials of the foreign process connected to this socket, if any (e.g. it is only supported for SOCKET_FAMILY_UNIX sockets).  <a href="#afcc5b5f562eb0255d846a41bde23d0f7">More...</a><br/></td></tr>
<tr class="separator:afcc5b5f562eb0255d846a41bde23d0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c05cab954287b392d6c60bc347ca5d8"><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a0c05cab954287b392d6c60bc347ca5d8">get_timeout</a> () const </td></tr>
<tr class="memdesc:a0c05cab954287b392d6c60bc347ca5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the timeout setting of the socket.  <a href="#a0c05cab954287b392d6c60bc347ca5d8">More...</a><br/></td></tr>
<tr class="separator:a0c05cab954287b392d6c60bc347ca5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe942e5157528b217d7af4a7839a9e7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#afe942e5157528b217d7af4a7839a9e7a">set_timeout</a> (guint timeout)</td></tr>
<tr class="memdesc:afe942e5157528b217d7af4a7839a9e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time in seconds after which I/O operations on <em>socket</em> will time out if they have not yet completed.  <a href="#afe942e5157528b217d7af4a7839a9e7a">More...</a><br/></td></tr>
<tr class="separator:afe942e5157528b217d7af4a7839a9e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812c649ac510471833c7e3bc82e79d26"><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a812c649ac510471833c7e3bc82e79d26">receive_with_blocking</a> (gchar* buffer, gsize size, bool blocking, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable=<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;())</td></tr>
<tr class="memdesc:a812c649ac510471833c7e3bc82e79d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This behaves exactly the same as g_socket_receive(), except that the choice of blocking or non-blocking behavior is determined by the <em>blocking</em> argument rather than by <em>socket's</em> properties.  <a href="#a812c649ac510471833c7e3bc82e79d26">More...</a><br/></td></tr>
<tr class="separator:a812c649ac510471833c7e3bc82e79d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad350079b590c05387736a0fd21e6e0ec"><td class="memItemLeft" align="right" valign="top">gssize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ad350079b590c05387736a0fd21e6e0ec">send_with_blocking</a> (gchar* buffer, gsize size, bool blocking, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable=<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;())</td></tr>
<tr class="memdesc:ad350079b590c05387736a0fd21e6e0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This behaves exactly the same as g_socket_send(), except that the choice of blocking or non-blocking behavior is determined by the <em>blocking</em> argument rather than by <em>socket's</em> properties.  <a href="#ad350079b590c05387736a0fd21e6e0ec">More...</a><br/></td></tr>
<tr class="separator:ad350079b590c05387736a0fd21e6e0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8161abb1b8367aed9502d48be2d94172"><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8161abb1b8367aed9502d48be2d94172">get_ttl</a> () const </td></tr>
<tr class="memdesc:a8161abb1b8367aed9502d48be2d94172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unicast time-to-live setting on <em>socket</em>; see g_socket_set_ttl() for more details.  <a href="#a8161abb1b8367aed9502d48be2d94172">More...</a><br/></td></tr>
<tr class="separator:a8161abb1b8367aed9502d48be2d94172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce7afa0966858f85979cbb884294007"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#afce7afa0966858f85979cbb884294007">set_ttl</a> (guint ttl)</td></tr>
<tr class="memdesc:afce7afa0966858f85979cbb884294007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time-to-live for outgoing unicast packets on <em>socket</em>.  <a href="#afce7afa0966858f85979cbb884294007">More...</a><br/></td></tr>
<tr class="separator:afce7afa0966858f85979cbb884294007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766a2e06ff796c80c42147dfb3e85366"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a766a2e06ff796c80c42147dfb3e85366">get_broadcast</a> () const </td></tr>
<tr class="memdesc:a766a2e06ff796c80c42147dfb3e85366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the broadcast setting on <em>socket</em>; if <code>true</code>, it is possible to send packets to broadcast addresses or receive from broadcast addresses.  <a href="#a766a2e06ff796c80c42147dfb3e85366">More...</a><br/></td></tr>
<tr class="separator:a766a2e06ff796c80c42147dfb3e85366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaf83216c9c5c127b6b5f8de425db4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aacaf83216c9c5c127b6b5f8de425db4c">set_broadcast</a> (bool broadcast)</td></tr>
<tr class="memdesc:aacaf83216c9c5c127b6b5f8de425db4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether <em>socket</em> should allow sending to and receiving from broadcast addresses.  <a href="#aacaf83216c9c5c127b6b5f8de425db4c">More...</a><br/></td></tr>
<tr class="separator:aacaf83216c9c5c127b6b5f8de425db4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa1d5519cde6e690e7d939b8ec79537"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a3aa1d5519cde6e690e7d939b8ec79537">get_multicast_loopback</a> () const </td></tr>
<tr class="memdesc:a3aa1d5519cde6e690e7d939b8ec79537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the multicast loopback setting on <em>socket</em>; if <code>true</code> (the default), outgoing multicast packets will be looped back to multicast listeners on the same host.  <a href="#a3aa1d5519cde6e690e7d939b8ec79537">More...</a><br/></td></tr>
<tr class="separator:a3aa1d5519cde6e690e7d939b8ec79537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e4493d31588bb9175b090a061dbd5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#af2e4493d31588bb9175b090a061dbd5d">set_multicast_loopback</a> (bool loopback)</td></tr>
<tr class="memdesc:af2e4493d31588bb9175b090a061dbd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether outgoing multicast packets will be received by sockets listening on that multicast address on the same host.  <a href="#af2e4493d31588bb9175b090a061dbd5d">More...</a><br/></td></tr>
<tr class="separator:af2e4493d31588bb9175b090a061dbd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750debbc865bf9e6d8fb9b950c04dd67"><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a750debbc865bf9e6d8fb9b950c04dd67">get_multicast_ttl</a> () const </td></tr>
<tr class="memdesc:a750debbc865bf9e6d8fb9b950c04dd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the multicast time-to-live setting on <em>socket</em>; see g_socket_set_multicast_ttl() for more details.  <a href="#a750debbc865bf9e6d8fb9b950c04dd67">More...</a><br/></td></tr>
<tr class="separator:a750debbc865bf9e6d8fb9b950c04dd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac946c14f5f92326c3f062f23ed1d5837"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ac946c14f5f92326c3f062f23ed1d5837">set_multicast_ttl</a> (guint ttl)</td></tr>
<tr class="memdesc:ac946c14f5f92326c3f062f23ed1d5837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time-to-live for outgoing multicast datagrams on <em>socket</em>.  <a href="#ac946c14f5f92326c3f062f23ed1d5837">More...</a><br/></td></tr>
<tr class="separator:ac946c14f5f92326c3f062f23ed1d5837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afded8c4757a4f2f8a89b6550e48531db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#afded8c4757a4f2f8a89b6550e48531db">join_multicast_group</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; group, bool source_specific, const std::string&amp; iface)</td></tr>
<tr class="memdesc:afded8c4757a4f2f8a89b6550e48531db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers <em>socket</em> to receive multicast messages sent to <em>group</em>.  <a href="#afded8c4757a4f2f8a89b6550e48531db">More...</a><br/></td></tr>
<tr class="separator:afded8c4757a4f2f8a89b6550e48531db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db138a424b8b2ab26d62a9ef2b29656"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8db138a424b8b2ab26d62a9ef2b29656">join_multicast_group</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; group, bool source_specific)</td></tr>
<tr class="memdesc:a8db138a424b8b2ab26d62a9ef2b29656"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#afded8c4757a4f2f8a89b6550e48531db" title="Registers socket to receive multicast messages sent to group.">join_multicast_group()</a> convenience overload.  <a href="#a8db138a424b8b2ab26d62a9ef2b29656">More...</a><br/></td></tr>
<tr class="separator:a8db138a424b8b2ab26d62a9ef2b29656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7e7ee9703f5f92dafa0a49cc47ca91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a5c7e7ee9703f5f92dafa0a49cc47ca91">leave_multicast_group</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; group, bool source_specific, const std::string&amp; iface)</td></tr>
<tr class="memdesc:a5c7e7ee9703f5f92dafa0a49cc47ca91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes <em>socket</em> from the multicast group defined by <em>group</em>, <em>iface</em>, and <em>source_specific</em> (which must all have the same values they had when you joined the group).  <a href="#a5c7e7ee9703f5f92dafa0a49cc47ca91">More...</a><br/></td></tr>
<tr class="separator:a5c7e7ee9703f5f92dafa0a49cc47ca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6648bc6b4d15ac95903ff47bb8e140f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ad6648bc6b4d15ac95903ff47bb8e140f">leave_multicast_group</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp; group, bool source_specific)</td></tr>
<tr class="memdesc:ad6648bc6b4d15ac95903ff47bb8e140f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1Socket.html#a5c7e7ee9703f5f92dafa0a49cc47ca91" title="Removes socket from the multicast group defined by group, iface, and source_specific (which must all ...">leave_multicast_group()</a> convenience overload.  <a href="#ad6648bc6b4d15ac95903ff47bb8e140f">More...</a><br/></td></tr>
<tr class="separator:ad6648bc6b4d15ac95903ff47bb8e140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e80070bf40ed9bff3d6e82fd6bc403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a33e80070bf40ed9bff3d6e82fd6bc403">property_blocking</a> ()</td></tr>
<tr class="memdesc:a33e80070bf40ed9bff3d6e82fd6bc403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not I/O on this socket is blocking.  <a href="#a33e80070bf40ed9bff3d6e82fd6bc403">More...</a><br/></td></tr>
<tr class="separator:a33e80070bf40ed9bff3d6e82fd6bc403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d697455cc099f37e06550d9a6b244c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ad4d697455cc099f37e06550d9a6b244c">property_blocking</a> () const </td></tr>
<tr class="memdesc:ad4d697455cc099f37e06550d9a6b244c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not I/O on this socket is blocking.  <a href="#ad4d697455cc099f37e06550d9a6b244c">More...</a><br/></td></tr>
<tr class="separator:ad4d697455cc099f37e06550d9a6b244c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a9ca8602e7d1c500cf9f4f4ab45aee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a83a9ca8602e7d1c500cf9f4f4ab45aee">property_family</a> () const </td></tr>
<tr class="memdesc:a83a9ca8602e7d1c500cf9f4f4ab45aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sockets address family.  <a href="#a83a9ca8602e7d1c500cf9f4f4ab45aee">More...</a><br/></td></tr>
<tr class="separator:a83a9ca8602e7d1c500cf9f4f4ab45aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f0ebc8891cdcccf8e16d0845921beb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a92f0ebc8891cdcccf8e16d0845921beb">property_fd</a> () const </td></tr>
<tr class="memdesc:a92f0ebc8891cdcccf8e16d0845921beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sockets file descriptor.  <a href="#a92f0ebc8891cdcccf8e16d0845921beb">More...</a><br/></td></tr>
<tr class="separator:a92f0ebc8891cdcccf8e16d0845921beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab16cc7a80fbbf288732298017f21a5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aab16cc7a80fbbf288732298017f21a5f">property_keepalive</a> ()</td></tr>
<tr class="memdesc:aab16cc7a80fbbf288732298017f21a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep connection alive by sending periodic pings.  <a href="#aab16cc7a80fbbf288732298017f21a5f">More...</a><br/></td></tr>
<tr class="separator:aab16cc7a80fbbf288732298017f21a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545a19bc5664e66900d1ca8c29f7d0e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a545a19bc5664e66900d1ca8c29f7d0e6">property_keepalive</a> () const </td></tr>
<tr class="memdesc:a545a19bc5664e66900d1ca8c29f7d0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep connection alive by sending periodic pings.  <a href="#a545a19bc5664e66900d1ca8c29f7d0e6">More...</a><br/></td></tr>
<tr class="separator:a545a19bc5664e66900d1ca8c29f7d0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7ef3aff95f2f829af2d3ce2ef36836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a7c7ef3aff95f2f829af2d3ce2ef36836">property_listen_backlog</a> ()</td></tr>
<tr class="memdesc:a7c7ef3aff95f2f829af2d3ce2ef36836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outstanding connections in the listen queue.  <a href="#a7c7ef3aff95f2f829af2d3ce2ef36836">More...</a><br/></td></tr>
<tr class="separator:a7c7ef3aff95f2f829af2d3ce2ef36836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08f21c5f7bd408e63815581bbfb48ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ad08f21c5f7bd408e63815581bbfb48ab">property_listen_backlog</a> () const </td></tr>
<tr class="memdesc:ad08f21c5f7bd408e63815581bbfb48ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outstanding connections in the listen queue.  <a href="#ad08f21c5f7bd408e63815581bbfb48ab">More...</a><br/></td></tr>
<tr class="separator:ad08f21c5f7bd408e63815581bbfb48ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52bc9e13993758922ce0d3683f336af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ac52bc9e13993758922ce0d3683f336af">property_local_address</a> () const </td></tr>
<tr class="memdesc:ac52bc9e13993758922ce0d3683f336af"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local address the socket is bound to.  <a href="#ac52bc9e13993758922ce0d3683f336af">More...</a><br/></td></tr>
<tr class="separator:ac52bc9e13993758922ce0d3683f336af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0affc1f63146a265a1d1c2b884091708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a0affc1f63146a265a1d1c2b884091708">property_remote_address</a> () const </td></tr>
<tr class="memdesc:a0affc1f63146a265a1d1c2b884091708"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remote address the socket is connected to.  <a href="#a0affc1f63146a265a1d1c2b884091708">More...</a><br/></td></tr>
<tr class="separator:a0affc1f63146a265a1d1c2b884091708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4042172bae49d0a2721546e31141d572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4042172bae49d0a2721546e31141d572">property_timeout</a> ()</td></tr>
<tr class="memdesc:a4042172bae49d0a2721546e31141d572"><td class="mdescLeft">&#160;</td><td class="mdescRight">The timeout in seconds on socket I/O.  <a href="#a4042172bae49d0a2721546e31141d572">More...</a><br/></td></tr>
<tr class="separator:a4042172bae49d0a2721546e31141d572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19433af6a2d3b85920a709559d81e4a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; guint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a19433af6a2d3b85920a709559d81e4a3">property_timeout</a> () const </td></tr>
<tr class="memdesc:a19433af6a2d3b85920a709559d81e4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The timeout in seconds on socket I/O.  <a href="#a19433af6a2d3b85920a709559d81e4a3">More...</a><br/></td></tr>
<tr class="separator:a19433af6a2d3b85920a709559d81e4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ebb99f61c167a77fe06572a9128cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a89ebb99f61c167a77fe06572a9128cb4">property_protocol</a> () const </td></tr>
<tr class="memdesc:a89ebb99f61c167a77fe06572a9128cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The id of the protocol to use, or -1 for unknown.  <a href="#a89ebb99f61c167a77fe06572a9128cb4">More...</a><br/></td></tr>
<tr class="separator:a89ebb99f61c167a77fe06572a9128cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870a59c1f58b2c4b28aa402e7c824cf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a870a59c1f58b2c4b28aa402e7c824cf1">property_broadcast</a> ()</td></tr>
<tr class="memdesc:a870a59c1f58b2c4b28aa402e7c824cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to allow sending to and receiving from broadcast addresses.  <a href="#a870a59c1f58b2c4b28aa402e7c824cf1">More...</a><br/></td></tr>
<tr class="separator:a870a59c1f58b2c4b28aa402e7c824cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74338dcee4fb6ef6e3d3db36e0a6347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aa74338dcee4fb6ef6e3d3db36e0a6347">property_broadcast</a> () const </td></tr>
<tr class="memdesc:aa74338dcee4fb6ef6e3d3db36e0a6347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to allow sending to and receiving from broadcast addresses.  <a href="#aa74338dcee4fb6ef6e3d3db36e0a6347">More...</a><br/></td></tr>
<tr class="separator:aa74338dcee4fb6ef6e3d3db36e0a6347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa658ba9c5796b7b5da36734b9c031e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#afa658ba9c5796b7b5da36734b9c031e0">property_type</a> () const </td></tr>
<tr class="memdesc:afa658ba9c5796b7b5da36734b9c031e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sockets type.  <a href="#afa658ba9c5796b7b5da36734b9c031e0">More...</a><br/></td></tr>
<tr class="separator:afa658ba9c5796b7b5da36734b9c031e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c54b763b8637fb06f4c03c4796e1c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#ab7c54b763b8637fb06f4c03c4796e1c9">property_ttl</a> ()</td></tr>
<tr class="memdesc:ab7c54b763b8637fb06f4c03c4796e1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time-to-live of outgoing unicast packets.  <a href="#ab7c54b763b8637fb06f4c03c4796e1c9">More...</a><br/></td></tr>
<tr class="separator:ab7c54b763b8637fb06f4c03c4796e1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba76e739cbfd9a6bb69efa3a908b718f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; guint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aba76e739cbfd9a6bb69efa3a908b718f">property_ttl</a> () const </td></tr>
<tr class="memdesc:aba76e739cbfd9a6bb69efa3a908b718f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time-to-live of outgoing unicast packets.  <a href="#aba76e739cbfd9a6bb69efa3a908b718f">More...</a><br/></td></tr>
<tr class="separator:aba76e739cbfd9a6bb69efa3a908b718f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067aa46a4f9950001e56a315f4313add"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a067aa46a4f9950001e56a315f4313add">property_multicast_loopback</a> ()</td></tr>
<tr class="memdesc:a067aa46a4f9950001e56a315f4313add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether outgoing multicast packets loop back to the local host.  <a href="#a067aa46a4f9950001e56a315f4313add">More...</a><br/></td></tr>
<tr class="separator:a067aa46a4f9950001e56a315f4313add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4b46a4077d1889099cf2f11ba92a83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#abe4b46a4077d1889099cf2f11ba92a83">property_multicast_loopback</a> () const </td></tr>
<tr class="memdesc:abe4b46a4077d1889099cf2f11ba92a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether outgoing multicast packets loop back to the local host.  <a href="#abe4b46a4077d1889099cf2f11ba92a83">More...</a><br/></td></tr>
<tr class="separator:abe4b46a4077d1889099cf2f11ba92a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669af953e00f1041a0088e1da6c7787d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a669af953e00f1041a0088e1da6c7787d">property_multicast_ttl</a> ()</td></tr>
<tr class="memdesc:a669af953e00f1041a0088e1da6c7787d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time-to-live of outgoing multicast packets.  <a href="#a669af953e00f1041a0088e1da6c7787d">More...</a><br/></td></tr>
<tr class="separator:a669af953e00f1041a0088e1da6c7787d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756aad409d9845505a20069923415179"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a><br class="typebreak"/>
&lt; guint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a756aad409d9845505a20069923415179">property_multicast_ttl</a> () const </td></tr>
<tr class="memdesc:a756aad409d9845505a20069923415179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time-to-live of outgoing multicast packets.  <a href="#a756aad409d9845505a20069923415179">More...</a><br/></td></tr>
<tr class="separator:a756aad409d9845505a20069923415179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGlib_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGlib_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGlib_1_1Object.html">Glib::Object</a></td></tr>
<tr class="memitem:a0e6581bcbcc6197cca07df24bb91c492 inherit pub_methods_classGlib_1_1Object"><td class="memItemLeft" align="right" valign="top">void*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a0e6581bcbcc6197cca07df24bb91c492">get_data</a> (const <a class="el" href="classGlib_1_1QueryQuark.html">QueryQuark</a>&amp; key)</td></tr>
<tr class="separator:a0e6581bcbcc6197cca07df24bb91c492 inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff7a375a862f3f899daaa99710122fa inherit pub_methods_classGlib_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#afff7a375a862f3f899daaa99710122fa">set_data</a> (const <a class="el" href="classGlib_1_1Quark.html">Quark</a>&amp; key, void* data)</td></tr>
<tr class="separator:afff7a375a862f3f899daaa99710122fa inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1febe3bae2dd71756e98e523cd33c1b4 inherit pub_methods_classGlib_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a1febe3bae2dd71756e98e523cd33c1b4">set_data</a> (const <a class="el" href="classGlib_1_1Quark.html">Quark</a>&amp; key, void* data, <a class="el" href="classGlib_1_1Object.html#a1d8d9f3c19b59eda96c40beca8d520e0">DestroyNotify</a> notify)</td></tr>
<tr class="separator:a1febe3bae2dd71756e98e523cd33c1b4 inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada5b50844bda7ee02bed0ae2a715c00 inherit pub_methods_classGlib_1_1Object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#aada5b50844bda7ee02bed0ae2a715c00">remove_data</a> (const <a class="el" href="classGlib_1_1QueryQuark.html">QueryQuark</a>&amp; quark)</td></tr>
<tr class="separator:aada5b50844bda7ee02bed0ae2a715c00 inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab454f71bd74403b0cc46d3cbbedd6b0e inherit pub_methods_classGlib_1_1Object"><td class="memItemLeft" align="right" valign="top">void*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#ab454f71bd74403b0cc46d3cbbedd6b0e">steal_data</a> (const <a class="el" href="classGlib_1_1QueryQuark.html">QueryQuark</a>&amp; quark)</td></tr>
<tr class="separator:ab454f71bd74403b0cc46d3cbbedd6b0e inherit pub_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGlib_1_1ObjectBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGlib_1_1ObjectBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGlib_1_1ObjectBase.html">Glib::ObjectBase</a></td></tr>
<tr class="memitem:aab599d3eec4b4a9ddc95ccdc6100053d inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#aab599d3eec4b4a9ddc95ccdc6100053d">set_property_value</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const <a class="el" href="classGlib_1_1ValueBase.html">Glib::ValueBase</a>&amp; value)</td></tr>
<tr class="memdesc:aab599d3eec4b4a9ddc95ccdc6100053d inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="#aab599d3eec4b4a9ddc95ccdc6100053d">More...</a><br/></td></tr>
<tr class="separator:aab599d3eec4b4a9ddc95ccdc6100053d inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e30750441b92f0246c9d4ece95fc8a0 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a5e30750441b92f0246c9d4ece95fc8a0">get_property_value</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, <a class="el" href="classGlib_1_1ValueBase.html">Glib::ValueBase</a>&amp; value) const </td></tr>
<tr class="memdesc:a5e30750441b92f0246c9d4ece95fc8a0 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="#a5e30750441b92f0246c9d4ece95fc8a0">More...</a><br/></td></tr>
<tr class="separator:a5e30750441b92f0246c9d4ece95fc8a0 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplParams" colspan="2">template&lt;class PropertyType &gt; </td></tr>
<tr class="memitem:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ad37844f7ea2c0091a22d011e04c48820">set_property</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const PropertyType&amp; value)</td></tr>
<tr class="memdesc:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="#ad37844f7ea2c0091a22d011e04c48820">More...</a><br/></td></tr>
<tr class="separator:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplParams" colspan="2">template&lt;class PropertyType &gt; </td></tr>
<tr class="memitem:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a5f894c9c36ad391fdc85552af67a8530">get_property</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, PropertyType&amp; value) const </td></tr>
<tr class="memdesc:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="#a5f894c9c36ad391fdc85552af67a8530">More...</a><br/></td></tr>
<tr class="separator:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6c1e8f094275114d6e2c3ef3a33f98 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#adc6c1e8f094275114d6e2c3ef3a33f98">connect_property_changed</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; slot)</td></tr>
<tr class="memdesc:adc6c1e8f094275114d6e2c3ef3a33f98 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can use the signal_changed() signal of the property proxy instead, but this is necessary when using the reduced API.  <a href="#adc6c1e8f094275114d6e2c3ef3a33f98">More...</a><br/></td></tr>
<tr class="separator:adc6c1e8f094275114d6e2c3ef3a33f98 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896d7773c00bd2dcd310c861282ee8d1 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="../../../libsigc++-2.0/reference/html/structsigc_1_1connection.html">sigc::connection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a896d7773c00bd2dcd310c861282ee8d1">connect_property_changed_with_return</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const <a class="elRef" href="../../../libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; slot)</td></tr>
<tr class="memdesc:a896d7773c00bd2dcd310c861282ee8d1 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can use the signal_changed() signal of the property proxy instead, but this is necessary when using the reduced API.  <a href="#a896d7773c00bd2dcd310c861282ee8d1">More...</a><br/></td></tr>
<tr class="separator:a896d7773c00bd2dcd310c861282ee8d1 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9e13b75f116c20212d318204ce8ea3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a6e9e13b75f116c20212d318204ce8ea3">freeze_notify</a> ()</td></tr>
<tr class="memdesc:a6e9e13b75f116c20212d318204ce8ea3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the freeze count on object.  <a href="#a6e9e13b75f116c20212d318204ce8ea3">More...</a><br/></td></tr>
<tr class="separator:a6e9e13b75f116c20212d318204ce8ea3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd8ea7bd8c4084ade6b3c27dddf06a4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a1bd8ea7bd8c4084ade6b3c27dddf06a4">thaw_notify</a> ()</td></tr>
<tr class="memdesc:a1bd8ea7bd8c4084ade6b3c27dddf06a4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverts the effect of a previous call to <a class="el" href="classGlib_1_1ObjectBase.html#a6e9e13b75f116c20212d318204ce8ea3" title="Increases the freeze count on object.">freeze_notify()</a>.  <a href="#a1bd8ea7bd8c4084ade6b3c27dddf06a4">More...</a><br/></td></tr>
<tr class="separator:a1bd8ea7bd8c4084ade6b3c27dddf06a4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896a8a5db20043ea82956e3ef4b9c4ae inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a896a8a5db20043ea82956e3ef4b9c4ae">reference</a> () const </td></tr>
<tr class="memdesc:a896a8a5db20043ea82956e3ef4b9c4ae inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the reference count for this object.  <a href="#a896a8a5db20043ea82956e3ef4b9c4ae">More...</a><br/></td></tr>
<tr class="separator:a896a8a5db20043ea82956e3ef4b9c4ae inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3234b8ffb2a35b927e2978c8f3bfbfe3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a3234b8ffb2a35b927e2978c8f3bfbfe3">unreference</a> () const </td></tr>
<tr class="memdesc:a3234b8ffb2a35b927e2978c8f3bfbfe3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the reference count for this object.  <a href="#a3234b8ffb2a35b927e2978c8f3bfbfe3">More...</a><br/></td></tr>
<tr class="separator:a3234b8ffb2a35b927e2978c8f3bfbfe3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6efc18be8cb9c56e58fc0bd20fafbe inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">GObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">gobj</a> ()</td></tr>
<tr class="memdesc:a4c6efc18be8cb9c56e58fc0bd20fafbe inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a4c6efc18be8cb9c56e58fc0bd20fafbe">More...</a><br/></td></tr>
<tr class="separator:a4c6efc18be8cb9c56e58fc0bd20fafbe inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778a94181132976bbfb0519793f3b32e inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">const GObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a778a94181132976bbfb0519793f3b32e">gobj</a> () const </td></tr>
<tr class="memdesc:a778a94181132976bbfb0519793f3b32e inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a778a94181132976bbfb0519793f3b32e">More...</a><br/></td></tr>
<tr class="separator:a778a94181132976bbfb0519793f3b32e inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2a5eb93102f1849e5419016e22a15f inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">GObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a9b2a5eb93102f1849e5419016e22a15f">gobj_copy</a> () const </td></tr>
<tr class="memdesc:a9b2a5eb93102f1849e5419016e22a15f inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a ref-ed copy to someone. Use for direct struct access.  <a href="#a9b2a5eb93102f1849e5419016e22a15f">More...</a><br/></td></tr>
<tr class="separator:a9b2a5eb93102f1849e5419016e22a15f inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGio_1_1Initable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGio_1_1Initable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGio_1_1Initable.html">Gio::Initable</a></td></tr>
<tr class="memitem:aa4da38b665a33995bf28ad1838253b7e inherit pub_methods_classGio_1_1Initable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#aa4da38b665a33995bf28ad1838253b7e">~Initable</a> ()</td></tr>
<tr class="separator:aa4da38b665a33995bf28ad1838253b7e inherit pub_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90206d58591c674e03c5de57623bac18 inherit pub_methods_classGio_1_1Initable"><td class="memItemLeft" align="right" valign="top">GInitable*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a90206d58591c674e03c5de57623bac18">gobj</a> ()</td></tr>
<tr class="memdesc:a90206d58591c674e03c5de57623bac18 inherit pub_methods_classGio_1_1Initable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a90206d58591c674e03c5de57623bac18">More...</a><br/></td></tr>
<tr class="separator:a90206d58591c674e03c5de57623bac18 inherit pub_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30665fda96b812e27231ec5abc47b789 inherit pub_methods_classGio_1_1Initable"><td class="memItemLeft" align="right" valign="top">const GInitable*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a30665fda96b812e27231ec5abc47b789">gobj</a> () const </td></tr>
<tr class="memdesc:a30665fda96b812e27231ec5abc47b789 inherit pub_methods_classGio_1_1Initable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a30665fda96b812e27231ec5abc47b789">More...</a><br/></td></tr>
<tr class="separator:a30665fda96b812e27231ec5abc47b789 inherit pub_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGlib_1_1Interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGlib_1_1Interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGlib_1_1Interface.html">Glib::Interface</a></td></tr>
<tr class="memitem:ae05bf6a4ce0f0992c2ad01429d13f9f7 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#ae05bf6a4ce0f0992c2ad01429d13f9f7">Interface</a> (const Glib::Interface_Class&amp; interface_class)</td></tr>
<tr class="memdesc:ae05bf6a4ce0f0992c2ad01429d13f9f7 inherit pub_methods_classGlib_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by constructors of derived classes.  <a href="#ae05bf6a4ce0f0992c2ad01429d13f9f7">More...</a><br/></td></tr>
<tr class="separator:ae05bf6a4ce0f0992c2ad01429d13f9f7 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00253b22a76f751f1627865451cbc404 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a00253b22a76f751f1627865451cbc404">Interface</a> (GObject* castitem)</td></tr>
<tr class="memdesc:a00253b22a76f751f1627865451cbc404 inherit pub_methods_classGlib_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by constructors of derived classes.  <a href="#a00253b22a76f751f1627865451cbc404">More...</a><br/></td></tr>
<tr class="separator:a00253b22a76f751f1627865451cbc404 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e12a7a3e0281e28798326ad65e3560c inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a8e12a7a3e0281e28798326ad65e3560c">~Interface</a> ()</td></tr>
<tr class="separator:a8e12a7a3e0281e28798326ad65e3560c inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969e9396f75132a9577428f4fa932d42 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">GObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a969e9396f75132a9577428f4fa932d42">gobj</a> ()</td></tr>
<tr class="separator:a969e9396f75132a9577428f4fa932d42 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a443071a69d3372c2cdd7128a91ed1 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">const GObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a70a443071a69d3372c2cdd7128a91ed1">gobj</a> () const </td></tr>
<tr class="separator:a70a443071a69d3372c2cdd7128a91ed1 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a175fe732c02ea3e861a86e6c7d690ba0"><td class="memItemLeft" align="right" valign="top">static GType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a175fe732c02ea3e861a86e6c7d690ba0">get_type</a> ()</td></tr>
<tr class="memdesc:a175fe732c02ea3e861a86e6c7d690ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GType for this class, for use with the underlying GObject type system.  <a href="#a175fe732c02ea3e861a86e6c7d690ba0">More...</a><br/></td></tr>
<tr class="separator:a175fe732c02ea3e861a86e6c7d690ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad87b57121a04302e4d9b41c322f59ca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#aad87b57121a04302e4d9b41c322f59ca">create</a> (<a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> family, <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> type, <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> protocol, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable=<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;())</td></tr>
<tr class="memdesc:aad87b57121a04302e4d9b41c322f59ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> with the defined family, type and protocol.  <a href="#aad87b57121a04302e4d9b41c322f59ca">More...</a><br/></td></tr>
<tr class="separator:aad87b57121a04302e4d9b41c322f59ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0268c13028a8e3eeb551ca14b83b8e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a8d0268c13028a8e3eeb551ca14b83b8e">create_from_fd</a> (int fd, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable=<a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;())</td></tr>
<tr class="memdesc:a8d0268c13028a8e3eeb551ca14b83b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> from a native file descriptor or winsock SOCKET handle.  <a href="#a8d0268c13028a8e3eeb551ca14b83b8e">More...</a><br/></td></tr>
<tr class="separator:a8d0268c13028a8e3eeb551ca14b83b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classGio_1_1Initable"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classGio_1_1Initable')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classGio_1_1Initable.html">Gio::Initable</a></td></tr>
<tr class="memitem:a6b68b1a2c2ab02ed1f25887c7acd121c inherit pub_static_methods_classGio_1_1Initable"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a6b68b1a2c2ab02ed1f25887c7acd121c">add_interface</a> (GType gtype_implementer)</td></tr>
<tr class="separator:a6b68b1a2c2ab02ed1f25887c7acd121c inherit pub_static_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a76f2678aa3641f7ded51813d9ead43 inherit pub_static_methods_classGio_1_1Initable"><td class="memItemLeft" align="right" valign="top">static GType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a6a76f2678aa3641f7ded51813d9ead43">get_type</a> ()</td></tr>
<tr class="memdesc:a6a76f2678aa3641f7ded51813d9ead43 inherit pub_static_methods_classGio_1_1Initable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GType for this class, for use with the underlying GObject type system.  <a href="#a6a76f2678aa3641f7ded51813d9ead43">More...</a><br/></td></tr>
<tr class="separator:a6a76f2678aa3641f7ded51813d9ead43 inherit pub_static_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9d2455e8d617dc7a828480d65db7b473"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a9d2455e8d617dc7a828480d65db7b473">Socket</a> (<a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> family, <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> type, <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> protocol, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="separator:a9d2455e8d617dc7a828480d65db7b473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d7c4338fcf53743f23926fccc8c6d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a74d7c4338fcf53743f23926fccc8c6d6">Socket</a> (int fd, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="separator:a74d7c4338fcf53743f23926fccc8c6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classGlib_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classGlib_1_1Object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classGlib_1_1Object.html">Glib::Object</a></td></tr>
<tr class="memitem:ad43f7c5ad0336e1eb3af622392a112eb inherit pro_methods_classGlib_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#ad43f7c5ad0336e1eb3af622392a112eb">Object</a> ()</td></tr>
<tr class="separator:ad43f7c5ad0336e1eb3af622392a112eb inherit pro_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d72588496bd7ac03f72420021fb94a5 inherit pro_methods_classGlib_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a6d72588496bd7ac03f72420021fb94a5">Object</a> (const Glib::ConstructParams&amp; construct_params)</td></tr>
<tr class="separator:a6d72588496bd7ac03f72420021fb94a5 inherit pro_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f490eeaeb71db673c36799a0f729be5 inherit pro_methods_classGlib_1_1Object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a6f490eeaeb71db673c36799a0f729be5">Object</a> (GObject* castitem)</td></tr>
<tr class="separator:a6f490eeaeb71db673c36799a0f729be5 inherit pro_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae4319439a3a03d8f803fb5a27f12df inherit pro_methods_classGlib_1_1Object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a5ae4319439a3a03d8f803fb5a27f12df">~Object</a> ()</td></tr>
<tr class="separator:a5ae4319439a3a03d8f803fb5a27f12df inherit pro_methods_classGlib_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classGlib_1_1ObjectBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classGlib_1_1ObjectBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classGlib_1_1ObjectBase.html">Glib::ObjectBase</a></td></tr>
<tr class="memitem:a27d3451d9ca28d6a2f00838d7c56d545 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a27d3451d9ca28d6a2f00838d7c56d545">ObjectBase</a> ()</td></tr>
<tr class="memdesc:a27d3451d9ca28d6a2f00838d7c56d545 inherit pro_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This default constructor is called implicitly from the constructor of user-derived classes, even if, for instance, Gtk::Button calls a different <a class="el" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces.">ObjectBase</a> constructor.  <a href="#a27d3451d9ca28d6a2f00838d7c56d545">More...</a><br/></td></tr>
<tr class="separator:a27d3451d9ca28d6a2f00838d7c56d545 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ef18214894c6874579313ab21d1018 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ad4ef18214894c6874579313ab21d1018">ObjectBase</a> (const char* custom_type_name)</td></tr>
<tr class="memdesc:ad4ef18214894c6874579313ab21d1018 inherit pro_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">A derived constructor always overrides this choice.  <a href="#ad4ef18214894c6874579313ab21d1018">More...</a><br/></td></tr>
<tr class="separator:ad4ef18214894c6874579313ab21d1018 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d59b4d85b0ee72a727e6b2e1b31a2ff inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a3d59b4d85b0ee72a727e6b2e1b31a2ff">ObjectBase</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00456.html">std::type_info</a>&amp; custom_type_info)</td></tr>
<tr class="memdesc:a3d59b4d85b0ee72a727e6b2e1b31a2ff inherit pro_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor is a special feature to allow creation of derived types on the fly, without having to use g_object_new() manually.  <a href="#a3d59b4d85b0ee72a727e6b2e1b31a2ff">More...</a><br/></td></tr>
<tr class="separator:a3d59b4d85b0ee72a727e6b2e1b31a2ff inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ac047a06c36c2d9c75f7cffc537dc4 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a42ac047a06c36c2d9c75f7cffc537dc4">~ObjectBase</a> ()=0</td></tr>
<tr class="separator:a42ac047a06c36c2d9c75f7cffc537dc4 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3faafb14c4f0ca60fbf0f5f5c4d549d0 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a3faafb14c4f0ca60fbf0f5f5c4d549d0">initialize</a> (GObject* castitem)</td></tr>
<tr class="separator:a3faafb14c4f0ca60fbf0f5f5c4d549d0 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classGio_1_1Initable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classGio_1_1Initable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classGio_1_1Initable.html">Gio::Initable</a></td></tr>
<tr class="memitem:a239fb2aa148d653d534db5581d72c348 inherit pro_methods_classGio_1_1Initable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a239fb2aa148d653d534db5581d72c348">Initable</a> ()</td></tr>
<tr class="memdesc:a239fb2aa148d653d534db5581d72c348 inherit pro_methods_classGio_1_1Initable"><td class="mdescLeft">&#160;</td><td class="mdescRight">You should derive from this class to use it.  <a href="#a239fb2aa148d653d534db5581d72c348">More...</a><br/></td></tr>
<tr class="separator:a239fb2aa148d653d534db5581d72c348 inherit pro_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbee3b8e980bf52ae2a66e1523127a3 inherit pro_methods_classGio_1_1Initable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a7dbee3b8e980bf52ae2a66e1523127a3">init</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a7dbee3b8e980bf52ae2a66e1523127a3 inherit pro_methods_classGio_1_1Initable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the object implementing the interface.  <a href="#a7dbee3b8e980bf52ae2a66e1523127a3">More...</a><br/></td></tr>
<tr class="separator:a7dbee3b8e980bf52ae2a66e1523127a3 inherit pro_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5881cf9c259d5af218585b7ecde38464 inherit pro_methods_classGio_1_1Initable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a5881cf9c259d5af218585b7ecde38464">init</a> ()</td></tr>
<tr class="memdesc:a5881cf9c259d5af218585b7ecde38464 inherit pro_methods_classGio_1_1Initable"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1Initable.html#a5881cf9c259d5af218585b7ecde38464" title="A init() convenience overload.">init()</a> convenience overload.  <a href="#a5881cf9c259d5af218585b7ecde38464">More...</a><br/></td></tr>
<tr class="separator:a5881cf9c259d5af218585b7ecde38464 inherit pro_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c86a53352ecda8bca80d5132e4e99c inherit pro_methods_classGio_1_1Initable"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a53c86a53352ecda8bca80d5132e4e99c">init_vfunc</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, GError** error)</td></tr>
<tr class="separator:a53c86a53352ecda8bca80d5132e4e99c inherit pro_methods_classGio_1_1Initable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a4b4f2145105f84580f0a2659a9e8e5db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Gio::Socket</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Socket.html#a4b4f2145105f84580f0a2659a9e8e5db">wrap</a> (GSocket* object, bool take_copy=false)</td></tr>
<tr class="memdesc:a4b4f2145105f84580f0a2659a9e8e5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object.  <a href="#a4b4f2145105f84580f0a2659a9e8e5db">More...</a><br/></td></tr>
<tr class="separator:a4b4f2145105f84580f0a2659a9e8e5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classGlib_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('related_classGlib_1_1Object')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classGlib_1_1Object.html">Glib::Object</a></td></tr>
<tr class="memitem:ae4dea9a8dc611d6e4400a5b6a3cb4e7f inherit related_classGlib_1_1Object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Object.html">Glib::Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#ae4dea9a8dc611d6e4400a5b6a3cb4e7f">wrap</a> (GObject* object, bool take_copy=false)</td></tr>
<tr class="separator:ae4dea9a8dc611d6e4400a5b6a3cb4e7f inherit related_classGlib_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header related_classGio_1_1Initable"><td colspan="2" onclick="javascript:toggleInherit('related_classGio_1_1Initable')"><img src="closed.png" alt="-"/>&#160;Related Functions inherited from <a class="el" href="classGio_1_1Initable.html">Gio::Initable</a></td></tr>
<tr class="memitem:a9a2f7929de61e6b32a2317fe0ebde865 inherit related_classGio_1_1Initable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Initable.html">Gio::Initable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1Initable.html#a9a2f7929de61e6b32a2317fe0ebde865">wrap</a> (GInitable* object, bool take_copy=false)</td></tr>
<tr class="memdesc:a9a2f7929de61e6b32a2317fe0ebde865 inherit related_classGio_1_1Initable"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object.  <a href="#a9a2f7929de61e6b32a2317fe0ebde865">More...</a><br/></td></tr>
<tr class="separator:a9a2f7929de61e6b32a2317fe0ebde865 inherit related_classGio_1_1Initable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classGlib_1_1Object"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classGlib_1_1Object')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classGlib_1_1Object.html">Glib::Object</a></td></tr>
<tr class="memitem:a1d8d9f3c19b59eda96c40beca8d520e0 inherit pub_types_classGlib_1_1Object"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Object.html#a1d8d9f3c19b59eda96c40beca8d520e0">DestroyNotify</a> )(gpointer data)</td></tr>
<tr class="separator:a1d8d9f3c19b59eda96c40beca8d520e0 inherit pub_types_classGlib_1_1Object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Low-level socket object. </p>
<p>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> is a low-level networking primitive. It is a more or less direct mapping of the BSD socket API in a portable GObject based API. It supports both the UNIX socket implementations and winsock2 on Windows.</p>
<p><a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> is the platform independent base upon which the higher level network primitives are based. Applications are not typically meant to use it directly, but rather through classes like <a class="el" href="classGio_1_1SocketClient.html" title="Helper for connecting to a network service.">SocketClient</a>, <a class="el" href="classGio_1_1SocketService.html" title="Make it easy to implement a network service.">SocketService</a> and <a class="el" href="classGio_1_1SocketConnection.html" title="A socket connection.">SocketConnection</a>. However there may be cases where direct use of <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> is useful.</p>
<p><a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> implements the <a class="el" href="classGio_1_1Initable.html" title="Failable object initialization interface.">Initable</a> interface, and since initialization can fail, the constructor may throw an exception.</p>
<p>Sockets operate in two general modes, blocking or non-blocking. When in blocking mode all operations block until the requested operation is finished or there is an error. In non-blocking mode all calls that would block return immediately with a <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a4041bd40a7ec2e6dc8dae84c30065fec" title="Operation would block.">Gio::Error::WOULD_BLOCK</a> error. To know when a call would successfully run you can call <a class="el" href="classGio_1_1Socket.html#a86fdc5d814fd61abab15ec03c7da20ec" title="Checks on the readiness of socket to perform operations.">condition_check()</a>, or <a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36" title="Waits for condition to become true on socket.">condition_wait()</a>. You can also use create_source() and attach it to a <a class="el" href="classGlib_1_1MainContext.html" title="Main context.">Glib::MainContext</a> to get callbacks when I/O is possible. Note that all sockets are always set to non blocking mode in the system, and blocking mode is emulated in <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>.</p>
<p>When working in non-blocking mode applications should always be able to handle getting a <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a4041bd40a7ec2e6dc8dae84c30065fec" title="Operation would block.">Gio::Error::WOULD_BLOCK</a> error even when some other function said that I/O was possible. This can easily happen in case of a race condition in the application, but it can also happen for other reasons. For instance, on Windows a socket is always seen as writable until a write returns <a class="el" href="classGio_1_1Error.html#a85e6b7d494c35d7a51ca879e4c65f134a4041bd40a7ec2e6dc8dae84c30065fec" title="Operation would block.">Gio::Error::WOULD_BLOCK</a>.</p>
<p>Sockets can be either connection oriented or datagram based. For connection oriented types you must first establish a connection by either connecting to an address or accepting a connection from another address. For connectionless socket types the target/source address is specified or received in each I/O operation.</p>
<p>All socket file descriptors are set to be close-on-exec.</p>
<p>Note that creating a <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> causes the signal SIGPIPE to be ignored for the remainder of the program. If you are writing a command-line utility that uses <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>, you may need to take into account the fact that your program will not automatically be killed if it tries to write to stdout after it has been closed.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000070">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8efac59d8562ceb635b76fe70087572d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gio::Socket::~Socket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d2455e8d617dc7a828480d65db7b473"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gio::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a>&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a>&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a74d7c4338fcf53743f23926fccc8c6d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gio::Socket::Socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a137ae34a8f211eaed11f9a58ca6b3f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; Gio::Socket::accept </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept incoming connections on a connection-based socket. </p>
<p>This removes the first outstanding connection request from the listening socket and creates a <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> object for it.</p>
<p>The <em>socket</em> must be bound to a local address with g_socket_bind() and must be listening for incoming connections (g_socket_listen()).</p>
<p>If there are no outstanding connections then the operation will block or return IO_ERROR_WOULD_BLOCK if non-blocking I/O is enabled. To be notified of an incoming connection, wait for the IO_IN condition.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000101">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>, or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4b6c036db4e484e6b7f0419962254888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; Gio::Socket::accept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#a4b6c036db4e484e6b7f0419962254888" title="A accept() convenience overload.">accept()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a16044bba5924c183cff90f0a4cf47394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_reuse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When a socket is created it is attached to an address family, but it doesn't have an address in this family. </p>
<p>g_socket_bind() assigns the address (sometimes called name) of the socket.</p>
<p>It is generally required to bind to a local address before you can receive connections. (See g_socket_listen() and g_socket_accept() ). In certain situations, you may also want to bind a socket that will be used to initiate connections, though this is not normally required.</p>
<p><em>allow_reuse</em> should be <code>true</code> for server sockets (sockets that you will eventually call g_socket_accept() on), and <code>false</code> for client sockets. (Specifically, if it is <code>true</code>, then g_socket_bind() will set the So::REUSEADDR flag on the socket, allowing it to bind <em>address</em> even if that address was previously used by another socket that has not yet been fully cleaned-up by the kernel. Failing to set this flag on a server socket may cause the bind call to return IO_ERROR_ADDRESS_IN_USE if the server program is stopped and then immediately restarted.)</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000099">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a> specifying the local address. </td></tr>
    <tr><td class="paramname">allow_reuse</td><td>Whether to allow reusing this address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a06b68dc0948e6dfa158487c314f9a521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::check_connect_result </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks and resets the pending connect error for the socket. </p>
<p>This is used to check for errors when g_socket_connect() is used in non-blocking mode.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000103">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if no error, <code>false</code> otherwise, setting <em>error</em> to the error. </dd></dl>

</div>
</div>
<a class="anchor" id="aab30d39b9e73fef6401c76d1d4edc118"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the socket, shutting down any active connection. </p>
<p>Closing a socket does not wait for all outstanding I/O operations to finish, so the caller should not rely on them to be guaranteed to complete even if the close returns with no error.</p>
<p>Once the socket is closed, all other operations will return IO_ERROR_CLOSED. Closing a socket multiple times will not return an error.</p>
<p>Sockets will be automatically closed when the last reference is dropped, but you might want to call this function to make sure resources are released as early as possible.</p>
<p>Beware that due to the way that TCP works, it is possible for recently-sent data to be lost if either you close a socket while the IO_IN condition is set, or else if the remote connection tries to send something to you after you close the socket but before it has finished reading all of the data you sent. There is no easy generic way to avoid this problem; the easiest fix is to design the network protocol such that the client will never send data "out of turn". Another solution is for the server to half-close the connection by calling g_socket_shutdown() with only the <em>shutdown_write</em> flag set, and then wait for the client to notice this and close its side of the connection, after which the server can safely call g_socket_close(). (This is what <a class="el" href="classGio_1_1TcpConnection.html" title="A TCP SocketConnection.">TcpConnection</a> does if you call g_tcp_connection_set_graceful_disconnect(). But of course, this only works if the client will close its connection after the server does.)</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000107">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a86fdc5d814fd61abab15ec03c7da20ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a> Gio::Socket::condition_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks on the readiness of <em>socket</em> to perform operations. </p>
<p>The operations specified in <em>condition</em> are checked for and masked against the currently-satisfied conditions on <em>socket</em>. The result is returned.</p>
<p>Note that on Windows, it is possible for an operation to return IO_ERROR_WOULD_BLOCK even immediately after g_socket_condition_check() has claimed that the socket is ready for writing. Rather than calling g_socket_condition_check() and then writing to the socket if it succeeds, it is generally better to simply try writing to the socket right away, and try again later if the initial attempt returns IO_ERROR_WOULD_BLOCK.</p>
<p>It is meaningless to specify IO_ERR or IO_HUP in condition; these conditions will always be set in the output if they are true.</p>
<p>This call never blocks.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000111">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>A IOCondition mask to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>GIOCondition</em> mask of the current state. </dd></dl>

</div>
</div>
<a class="anchor" id="addb32e1cc859b9689bf10169dfd70a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::condition_timed_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for up to <em>timeout</em> microseconds for <em>condition</em> to become true on <em>socket</em>. </p>
<p>If the condition is met, <code>true</code> is returned.</p>
<p>If <em>cancellable</em> is cancelled before the condition is met, or if <em>timeout</em> (or the socket's <a class="el" href="classGio_1_1Socket.html#a4042172bae49d0a2721546e31141d572" title="The timeout in seconds on socket I/O.">Socket::property_timeout()</a>) is reached before the condition is met, then <code>false</code> is returned and <em>error</em>, if non-<code>0</code>, is set to the appropriate value (IO_ERROR_CANCELLED or IO_ERROR_TIMED_OUT).</p>
<p>If you don't want a timeout, use g_socket_condition_wait(). (Alternatively, you can pass -1 for <em>timeout</em>.)</p>
<p>Note that although <em>timeout</em> is in microseconds for consistency with other GLib APIs, this function actually only has millisecond resolution, and the behavior is undefined if <em>timeout</em> is not an exact number of milliseconds.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000094">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>A IOCondition mask to wait for. </td></tr>
    <tr><td class="paramname">timeout</td><td>The maximum time (in microseconds) to wait, or -1. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the condition was met, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a71a3736a74c730c76e7c9a1670c3fbdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::condition_timed_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#addb32e1cc859b9689bf10169dfd70a9c" title="Waits for up to timeout microseconds for condition to become true on socket.">condition_timed_wait()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="aaae28fa63035c05396064f5f4bb4fc36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::condition_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for <em>condition</em> to become true on <em>socket</em>. </p>
<p>When the condition is met, <code>true</code> is returned.</p>
<p>If <em>cancellable</em> is cancelled before the condition is met, or if the socket has a timeout set and it is reached before the condition is met, then <code>false</code> is returned and <em>error</em>, if non-<code>0</code>, is set to the appropriate value (IO_ERROR_CANCELLED or IO_ERROR_TIMED_OUT).</p>
<p>See also g_socket_condition_timed_wait().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000112">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>A IOCondition mask to wait for. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the condition was met, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ae420715a2050cc09112f178bae88ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::condition_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">Glib::IOCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#aaae28fa63035c05396064f5f4bb4fc36" title="Waits for condition to become true on socket.">condition_wait()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a9ab220f5714a6116d35e846b00f4ad23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect the socket to the specified remote address. </p>
<p>For connection oriented socket this generally means we attempt to make a connection to the <em>address</em>. For a connection-less socket it sets the default address for g_socket_send() and discards all incoming datagrams from other sources.</p>
<p>Generally connection oriented sockets can only connect once, but connection-less sockets can connect multiple times to change the default address.</p>
<p>If the connect call needs to do network I/O it will block, unless non-blocking I/O is enabled. Then IO_ERROR_PENDING is returned and the user can be notified of the connection finishing by waiting for the G_IO_OUT condition. The result of the connection must then be checked with g_socket_check_connect_result().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000102">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a> specifying the remote address. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if connected, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a0828763fe472d46aed833fad30af1c0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#a9ab220f5714a6116d35e846b00f4ad23" title="Connect the socket to the specified remote address.">connect()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="aad87b57121a04302e4d9b41c322f59ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; Gio::Socket::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a>&#160;</td>
          <td class="paramname"><em>family</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a>&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em> = <code><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;&#160;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> with the defined family, type and protocol. </p>
<p>If <em>protocol</em> is 0 (SOCKET_PROTOCOL_DEFAULT) the default protocol type for the family and type is used.</p>
<p>The <em>protocol</em> is a family and type specific int that specifies what kind of protocol to use. SocketProtocol lists several common ones. Many families only support one protocol, and use 0 for this, others support several and using 0 means to use the default protocol for the family and type.</p>
<p>The protocol id is passed directly to the operating system, so you can use protocols not listed in SocketProtocol if you know the protocol number used for it.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000097">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">family</td><td>The socket family to use, e.g. SOCKET_FAMILY_IPV4. </td></tr>
    <tr><td class="paramname">type</td><td>The socket type to use. </td></tr>
    <tr><td class="paramname">protocol</td><td>The id of the protocol to use, or 0 for default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> or <code>0</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d0268c13028a8e3eeb551ca14b83b8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Socket.html">Socket</a>&gt; Gio::Socket::create_from_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em> = <code><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;&#160;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> from a native file descriptor or winsock SOCKET handle. </p>
<p>This reads all the settings from the file descriptor so that all properties should work. Note that the file descriptor will be set to non-blocking mode, independent on the blocking mode of the <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a>.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000098">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A native socket file descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> or <code>0</code> on error. Free the returned object with Glib::object_unref().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a>, or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1Error.html">Glib::Error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3cd0af5978112d1c8e2e68e51c9b99c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::get_available_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the amount of data pending in the OS input buffer. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000093">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that can be read from the socket without blocking or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ffcbc226b08ae14856ea0dfe4d580e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::get_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the blocking mode of the socket. </p>
<p>For details on blocking I/O, see g_socket_set_blocking().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000116">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if blocking I/O is used, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a766a2e06ff796c80c42147dfb3e85366"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::get_broadcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the broadcast setting on <em>socket</em>; if <code>true</code>, it is possible to send packets to broadcast addresses or receive from broadcast addresses. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000097">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The broadcast setting on <em>socket</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fcda0eba8fcb30bd020624ce3f14d8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Credentials.html">Credentials</a>&gt; Gio::Socket::get_credentials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the credentials of the foreign process connected to this socket, if any (e.g. it is only supported for SOCKET_FAMILY_UNIX sockets). </p>
<p>If this operation isn't supported on the OS, the method fails with the IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading the So::PEERCRED option on the underlying socket.</p>
<p>Other ways to obtain credentials from a foreign peer includes the <a class="el" href="classGio_1_1UnixCredentialsMessage.html" title="UnixCredentialsMessage - A SocketControlMessage containing credentials.">UnixCredentialsMessage</a> type and g_unix_connection_send_credentials() / g_unix_connection_receive_credentials() functions.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000283">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> if <em>error</em> is set, otherwise a <a class="el" href="classGio_1_1Credentials.html" title="An object containing credentials.">Credentials</a> object that must be freed with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="afcc5b5f562eb0255d846a41bde23d0f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;const <a class="el" href="classGio_1_1Credentials.html">Credentials</a>&gt; Gio::Socket::get_credentials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the credentials of the foreign process connected to this socket, if any (e.g. it is only supported for SOCKET_FAMILY_UNIX sockets). </p>
<p>If this operation isn't supported on the OS, the method fails with the IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented by reading the So::PEERCRED option on the underlying socket.</p>
<p>Other ways to obtain credentials from a foreign peer includes the <a class="el" href="classGio_1_1UnixCredentialsMessage.html" title="UnixCredentialsMessage - A SocketControlMessage containing credentials.">UnixCredentialsMessage</a> type and g_unix_connection_send_credentials() / g_unix_connection_receive_credentials() functions.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000284">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>0</code> if <em>error</em> is set, otherwise a <a class="el" href="classGio_1_1Credentials.html" title="An object containing credentials.">Credentials</a> object that must be freed with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aac1e2a576e62d1e339eefae1fe12e24b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> Gio::Socket::get_family </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the socket family of the socket. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000119">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A SocketFamily. </dd></dl>

</div>
</div>
<a class="anchor" id="af3bb5076efcb022e31db9622a1c6e0ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gio::Socket::get_fd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the underlying OS socket object. </p>
<p>On unix this is a socket file descriptor, and on Windows this is a Winsock2 SOCKET handle. This may be useful for doing platform specific or otherwise unusual operations on the socket.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000120">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The file descriptor of the socket. </dd></dl>

</div>
</div>
<a class="anchor" id="a530b4adc3d295f7c000981286dee8019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::get_keepalive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the keepalive mode of the socket. </p>
<p>For details on this, see g_socket_set_keepalive().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000118">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if keepalive is active, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a22a9e70db9abc7fc6383641afde8ee6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gio::Socket::get_listen_backlog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the listen backlog setting of the socket. </p>
<p>For details on this, see g_socket_set_listen_backlog().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000114">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of pending connections. </dd></dl>

</div>
</div>
<a class="anchor" id="a654e36f8577b61a4df93a0a70479a7f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; Gio::Socket::get_local_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the local address of a bound socket. </p>
<p>This is only useful if the socket has been bound to a local address, either explicitly or implicitly when connecting.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000121">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a3aa1d5519cde6e690e7d939b8ec79537"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::get_multicast_loopback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the multicast loopback setting on <em>socket</em>; if <code>true</code> (the default), outgoing multicast packets will be looped back to multicast listeners on the same host. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000099">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The multicast loopback setting on <em>socket</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a750debbc865bf9e6d8fb9b950c04dd67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint Gio::Socket::get_multicast_ttl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the multicast time-to-live setting on <em>socket</em>; see g_socket_set_multicast_ttl() for more details. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000101">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The multicast time-to-live setting on <em>socket</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ecd966ee71eb956258b289cf63eb43e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> Gio::Socket::get_protocol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the socket protocol id the socket was created with. </p>
<p>In case the protocol is unknown, -1 is returned.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000123">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A protocol id, or -1 if unknown. </dd></dl>

</div>
</div>
<a class="anchor" id="adce45788b8ac674bdf32a3ec8fb683c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; Gio::Socket::get_remote_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to get the remove address of a connected socket. </p>
<p>This is only useful for connection oriented sockets that have been connected.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000122">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a> or <code>0</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a05cd563d5bc68362f3a574054ce63481"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> Gio::Socket::get_socket_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the socket type of the socket. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000124">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A SocketType. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c05cab954287b392d6c60bc347ca5d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint Gio::Socket::get_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the timeout setting of the socket. </p>
<p>For details on this, see g_socket_set_timeout().</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000285">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The timeout in seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a8161abb1b8367aed9502d48be2d94172"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint Gio::Socket::get_ttl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the unicast time-to-live setting on <em>socket</em>; see g_socket_set_ttl() for more details. </p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000095">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The time-to-live setting on <em>socket</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a175fe732c02ea3e861a86e6c7d690ba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static GType Gio::Socket::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the GType for this class, for use with the underlying GObject type system. </p>

</div>
</div>
<a class="anchor" id="a1d51f7bcd83450331d7261898e9007d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GSocket* Gio::Socket::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

</div>
</div>
<a class="anchor" id="a51c7fa832ce1c984a7bbceb4d7ba93a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const GSocket* Gio::Socket::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

</div>
</div>
<a class="anchor" id="ae2fe06b1a579c40b596933da0ded4e37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GSocket* Gio::Socket::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="a7ac925f7e6592ad4a96afe0f75411a96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::is_closed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a socket is closed. </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000108">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if socket is closed, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aea9561511b77e652271705fbfdb2f8f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::is_connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the socket is connected. </p>
<p>This is only useful for connection-oriented sockets.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000110">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if socket is connected, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afded8c4757a4f2f8a89b6550e48531db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::join_multicast_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>source_specific</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers <em>socket</em> to receive multicast messages sent to <em>group</em>. </p>
<p><em>socket</em> must be a SOCKET_TYPE_DATAGRAM socket, and must have been bound to an appropriate interface and port with g_socket_bind().</p>
<p>If <em>iface</em> is <code>0</code>, the system will automatically pick an interface to bind to based on <em>group</em>.</p>
<p>If <em>source_specific</em> is <code>true</code>, source-specific multicast as defined in RFC 4604 is used. Note that on older platforms this may fail with a IO_ERROR_NOT_SUPPORTED error.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000103">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>A <a class="el" href="classGio_1_1InetAddress.html" title="An IPv4/IPv6 address.">InetAddress</a> specifying the group address to join. </td></tr>
    <tr><td class="paramname">iface</td><td>Name of the interface to use, or <code>0</code>. </td></tr>
    <tr><td class="paramname">source_specific</td><td><code>true</code> if source-specific multicast should be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a8db138a424b8b2ab26d62a9ef2b29656"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::join_multicast_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>source_specific</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#afded8c4757a4f2f8a89b6550e48531db" title="Registers socket to receive multicast messages sent to group.">join_multicast_group()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a5c7e7ee9703f5f92dafa0a49cc47ca91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::leave_multicast_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>source_specific</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes <em>socket</em> from the multicast group defined by <em>group</em>, <em>iface</em>, and <em>source_specific</em> (which must all have the same values they had when you joined the group). </p>
<p><em>socket</em> remains bound to its address and port, and can still receive unicast messages after calling this.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000104">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>A <a class="el" href="classGio_1_1InetAddress.html" title="An IPv4/IPv6 address.">InetAddress</a> specifying the group address to leave. </td></tr>
    <tr><td class="paramname">iface</td><td>Interface used. </td></tr>
    <tr><td class="paramname">source_specific</td><td><code>true</code> if source-specific multicast was used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6648bc6b4d15ac95903ff47bb8e140f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::leave_multicast_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1InetAddress.html">InetAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>source_specific</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#a5c7e7ee9703f5f92dafa0a49cc47ca91" title="Removes socket from the multicast group defined by group, iface, and source_specific (which must all ...">leave_multicast_group()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="af16eed3fd42f3769b5e608f96db214fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::listen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks the socket as a server socket, i.e. a socket that is used to accept incoming requests using g_socket_accept(). </p>
<p>Before calling this the socket must be bound to a local address using g_socket_bind().</p>
<p>To set the maximum amount of outstanding clients, use g_socket_set_listen_backlog().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000100">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a33e80070bf40ed9bff3d6e82fd6bc403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; Gio::Socket::property_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not I/O on this socket is blocking. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4d697455cc099f37e06550d9a6b244c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; Gio::Socket::property_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not I/O on this socket is blocking. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a870a59c1f58b2c4b28aa402e7c824cf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; Gio::Socket::property_broadcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to allow sending to and receiving from broadcast addresses. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="aa74338dcee4fb6ef6e3d3db36e0a6347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; Gio::Socket::property_broadcast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether to allow sending to and receiving from broadcast addresses. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a83a9ca8602e7d1c500cf9f4f4ab45aee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#ga0ba69e14ad979bf9b2073ad122e38d48">SocketFamily</a> &gt; Gio::Socket::property_family </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sockets address family. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a92f0ebc8891cdcccf8e16d0845921beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt; Gio::Socket::property_fd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sockets file descriptor. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="aab16cc7a80fbbf288732298017f21a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; Gio::Socket::property_keepalive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep connection alive by sending periodic pings. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a545a19bc5664e66900d1ca8c29f7d0e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; Gio::Socket::property_keepalive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keep connection alive by sending periodic pings. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c7ef3aff95f2f829af2d3ce2ef36836"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; int &gt; Gio::Socket::property_listen_backlog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outstanding connections in the listen queue. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ad08f21c5f7bd408e63815581bbfb48ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; int &gt; Gio::Socket::property_listen_backlog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outstanding connections in the listen queue. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ac52bc9e13993758922ce0d3683f336af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; &gt; Gio::Socket::property_local_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The local address the socket is bound to. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a067aa46a4f9950001e56a315f4313add"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; bool &gt; Gio::Socket::property_multicast_loopback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether outgoing multicast packets loop back to the local host. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="abe4b46a4077d1889099cf2f11ba92a83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; bool &gt; Gio::Socket::property_multicast_loopback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether outgoing multicast packets loop back to the local host. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a669af953e00f1041a0088e1da6c7787d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt; Gio::Socket::property_multicast_ttl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time-to-live of outgoing multicast packets. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a756aad409d9845505a20069923415179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; guint &gt; Gio::Socket::property_multicast_ttl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time-to-live of outgoing multicast packets. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a89ebb99f61c167a77fe06572a9128cb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#ga4e8932017a600fffa5e8e6b5f6ea5b16">SocketProtocol</a> &gt; Gio::Socket::property_protocol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The id of the protocol to use, or -1 for unknown. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a0affc1f63146a265a1d1c2b884091708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a>&gt; &gt; Gio::Socket::property_remote_address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The remote address the socket is connected to. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a4042172bae49d0a2721546e31141d572"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt; Gio::Socket::property_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The timeout in seconds on socket I/O. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a19433af6a2d3b85920a709559d81e4a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; guint &gt; Gio::Socket::property_timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The timeout in seconds on socket I/O. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7c54b763b8637fb06f4c03c4796e1c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy.html">Glib::PropertyProxy</a>&lt; guint &gt; Gio::Socket::property_ttl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time-to-live of outgoing unicast packets. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy that allows you to get or set the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="aba76e739cbfd9a6bb69efa3a908b718f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; guint &gt; Gio::Socket::property_ttl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time-to-live of outgoing unicast packets. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="afa658ba9c5796b7b5da36734b9c031e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1PropertyProxy__ReadOnly.html">Glib::PropertyProxy_ReadOnly</a>&lt; <a class="el" href="group__giommEnums.html#ga2302a45e052658e343729e0be2fd3310">SocketType</a> &gt; Gio::Socket::property_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sockets type. </p>
<p>You rarely need to use properties because there are get_ and set_ methods for almost all of them. </p>
<dl class="section return"><dt>Returns</dt><dd>A PropertyProxy_ReadOnly that allows you to get the value of the property, or receive notification when the value of the property changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a742403f4d076ba9050a435d95fea5d1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::receive </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data (up to <em>size</em> bytes) from a socket. </p>
<p>This is mainly used by connection-oriented sockets; it is identical to g_socket_receive_from() with <em>address</em> set to <code>0</code>.</p>
<p>For SOCKET_TYPE_DATAGRAM and SOCKET_TYPE_SEQPACKET sockets, g_socket_receive() will always read either 0 or 1 complete messages from the socket. If the received message is too large to fit in <em>buffer</em>, then the data beyond <em>size</em> bytes will be discarded, without any explicit indication that this has occurred.</p>
<p>For SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any number of bytes, up to <em>size</em>. If more than <em>size</em> bytes have been received, the additional data will be returned in future calls to g_socket_receive().</p>
<p>If the socket is in blocking mode the call will block until there is some data to receive, the connection is closed, or there is an error. If there is no data available and the socket is in non-blocking mode, a IO_ERROR_WOULD_BLOCK error will be returned. To be notified when data is available, wait for the IO_IN condition.</p>
<p>On error -1 is returned and <em>error</em> is set accordingly.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000104">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to read data into (which should be at least <em>size</em> bytes long). </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes you want to read from the socket. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a73463b7677ffdfddaced49bdf170b4b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::receive </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#a742403f4d076ba9050a435d95fea5d1c" title="Receive data (up to size bytes) from a socket.">receive()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a4d2d4382139553881ae139920e8db93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::receive_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a056fd2c3609971d5befcf2b4ccf51aa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::receive_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a812c649ac510471833c7e3bc82e79d26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::receive_with_blocking </td>
          <td>(</td>
          <td class="paramtype">gchar *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em> = <code><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;&#160;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This behaves exactly the same as g_socket_receive(), except that the choice of blocking or non-blocking behavior is determined by the <em>blocking</em> argument rather than by <em>socket's</em> properties. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000287">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer to read data into (which should be at least <em>size</em> bytes long). </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes you want to read from the socket. </td></tr>
    <tr><td class="paramname">blocking</td><td>Whether to do blocking or non-blocking I/O. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read, or 0 if the connection was closed by the peer, or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="adc5c3145109841e0406150ad0b7f547c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::send </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to send <em>size</em> bytes from <em>buffer</em> on the socket. </p>
<p>This is mainly used by connection-oriented sockets; it is identical to g_socket_send_to() with <em>address</em> set to <code>0</code>.</p>
<p>If the socket is in blocking mode the call will block until there is space for the data in the socket queue. If there is no space available and the socket is in non-blocking mode a IO_ERROR_WOULD_BLOCK error will be returned. To be notified when space is available, wait for the IO_OUT condition. Note though that you may still receive IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously notified of a IO_OUT condition. (On Windows in particular, this is very common due to the way the underlying APIs work.)</p>
<p>On error -1 is returned and <em>error</em> is set accordingly.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000105">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing the data to send. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to send. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written (which may be less than <em>size</em>), or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a986efa2a33528ce5aba0d7c6a7be1b65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::send </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#adc5c3145109841e0406150ad0b7f547c" title="Tries to send size bytes from buffer on the socket.">send()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a8b2d4ff883535e696b6cdaacd730f729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::send_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to send <em>size</em> bytes from <em>buffer</em> to <em>address</em>. </p>
<p>If <em>address</em> is <code>0</code> then the message is sent to the default receiver (set by g_socket_connect()).</p>
<p>See g_socket_send() for additional information.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000106">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>A <a class="el" href="classGio_1_1SocketAddress.html" title="Abstract base class representing endpoints for socket communication.">SocketAddress</a>, or <code>0</code>. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer containing the data to send. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to send. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written (which may be less than <em>size</em>), or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a929c8c4e0c10a39d65358853e94d9c4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::send_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1SocketAddress.html">SocketAddress</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1Socket.html#a8b2d4ff883535e696b6cdaacd730f729" title="Tries to send size bytes from buffer to address.">send_to()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="ad350079b590c05387736a0fd21e6e0ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gssize Gio::Socket::send_with_blocking </td>
          <td>(</td>
          <td class="paramtype">gchar *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em> = <code><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;&#160;<a class="el" href="classGio_1_1Cancellable.html">Cancellable</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This behaves exactly the same as g_socket_send(), except that the choice of blocking or non-blocking behavior is determined by the <em>blocking</em> argument rather than by <em>socket's</em> properties. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000288">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing the data to send. </td></tr>
    <tr><td class="paramname">size</td><td>The number of bytes to send. </td></tr>
    <tr><td class="paramname">blocking</td><td>Whether to do blocking or non-blocking I/O. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled.">Cancellable</a> or <code>0</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written (which may be less than <em>size</em>), or -1 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a51d5a174441c255b69be9e809cdb96b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::set_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the blocking mode of the socket. </p>
<p>In blocking mode all operations block until they succeed or there is an error. In non-blocking mode all functions return results immediately or with a IO_ERROR_WOULD_BLOCK error.</p>
<p>All sockets are created in blocking mode. However, note that the platform level socket is always non-blocking, and blocking mode is a GSocket level feature.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000115">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blocking</td><td>Whether to use blocking I/O or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacaf83216c9c5c127b6b5f8de425db4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::set_broadcast </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>broadcast</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether <em>socket</em> should allow sending to and receiving from broadcast addresses. </p>
<p>This is <code>false</code> by default.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000098">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">broadcast</td><td>Whether <em>socket</em> should allow sending to and receiving from broadcast addresses. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cfac67927584ae7afe53006eebb06d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::set_keepalive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepalive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or unsets the So::KEEPALIVE flag on the underlying socket. </p>
<p>When this flag is set on a socket, the system will attempt to verify that the remote socket endpoint is still present if a sufficiently long period of time passes with no data being exchanged. If the system is unable to verify the presence of the remote endpoint, it will automatically close the connection.</p>
<p>This option is only functional on certain kinds of sockets. (Notably, SOCKET_PROTOCOL_TCP sockets.)</p>
<p>The exact time between pings is system- and protocol-dependent, but will normally be at least two hours. Most commonly, you would set this flag on a server socket if you want to allow clients to remain idle for long periods of time, but also want to ensure that connections are eventually garbage-collected if clients crash or become unreachable.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000117">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepalive</td><td>Value for the keepalive flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc7b9d6cecc1c2234f9979b2ffb1b309"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::set_listen_backlog </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum number of outstanding connections allowed when listening on this socket. </p>
<p>If more clients than this are connecting to the socket and the application is not handling them on time then the new connections will be refused.</p>
<p>Note that this must be called before g_socket_listen() and has no effect if called after that.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000113">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backlog</td><td>The maximum number of pending connections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2e4493d31588bb9175b090a061dbd5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::set_multicast_loopback </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loopback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether outgoing multicast packets will be received by sockets listening on that multicast address on the same host. </p>
<p>This is <code>true</code> by default.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000100">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loopback</td><td>Whether <em>socket</em> should receive messages sent to its multicast groups from the local host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac946c14f5f92326c3f062f23ed1d5837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::set_multicast_ttl </td>
          <td>(</td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>ttl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the time-to-live for outgoing multicast datagrams on <em>socket</em>. </p>
<p>By default, this is 1, meaning that multicast packets will not leave the local network.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000102">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ttl</td><td>The time-to-live value for all multicast datagrams on <em>socket</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe942e5157528b217d7af4a7839a9e7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::set_timeout </td>
          <td>(</td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the time in seconds after which I/O operations on <em>socket</em> will time out if they have not yet completed. </p>
<p>On a blocking socket, this means that any blocking <a class="el" href="classGio_1_1Socket.html" title="Low-level socket object.">Socket</a> operation will time out after <em>timeout</em> seconds of inactivity, returning IO_ERROR_TIMED_OUT.</p>
<p>On a non-blocking socket, calls to g_socket_condition_wait() will also fail with IO_ERROR_TIMED_OUT after the given time. Sources created with g_socket_create_source() will trigger after <em>timeout</em> seconds of inactivity, with the requested condition set, at which point calling g_socket_receive(), g_socket_send(), g_socket_check_connect_result(), etc, will fail with IO_ERROR_TIMED_OUT.</p>
<p>If <em>timeout</em> is 0 (the default), operations will never time out on their own.</p>
<p>Note that if an I/O operation is interrupted by a signal, this may cause the timeout to be reset.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000286">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout for <em>socket</em>, in seconds, or 0 for none. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afce7afa0966858f85979cbb884294007"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::set_ttl </td>
          <td>(</td>
          <td class="paramtype">guint&#160;</td>
          <td class="paramname"><em>ttl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the time-to-live for outgoing unicast packets on <em>socket</em>. </p>
<p>By default the platform-specific default value is used.</p>
<dl class="since_2_32"><dt><b><a class="el" href="since_2_32.html#_since_2_32000096">Since glibmm 2.32:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ttl</td><td>The time-to-live value for all unicast packets on <em>socket</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f685bc040e9e10abe093deec0719fd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::Socket::shutdown </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shutdown_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shutdown_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down part of a full-duplex connection. </p>
<p>If <em>shutdown_read</em> is <code>true</code> then the receiving side of the connection is shut down, and further reading is disallowed.</p>
<p>If <em>shutdown_write</em> is <code>true</code> then the sending side of the connection is shut down, and further writing is disallowed.</p>
<p>It is allowed for both <em>shutdown_read</em> and <em>shutdown_write</em> to be <code>true</code>.</p>
<p>One example where this is used is graceful disconnect for TCP connections where you close the sending side, then wait for the other side to close the connection, thus ensuring that the other side saw all sent data.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000109">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shutdown_read</td><td>Whether to shut down the read side. </td></tr>
    <tr><td class="paramname">shutdown_write</td><td>Whether to shut down the write side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="ae33e646694bf6c5062683ba4b79d4fe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::Socket::speaks_ipv4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a socket is capable of speaking IPv4. </p>
<p>IPv4 sockets are capable of speaking IPv4. On some operating systems and under some combinations of circumstances IPv6 sockets are also capable of speaking IPv4. See RFC 3493 section 3.7 for more information.</p>
<p>No other types of sockets are currently considered as being capable of speaking IPv4.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000125">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this socket can be used with IPv4. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a4b4f2145105f84580f0a2659a9e8e5db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Socket.html">Gio::Socket</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GSocket *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 19 2013 10:12:12 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
