.packageName <- "iNZight"
#line 1 "/Users/tom/iNZight/iNZight/R/dataImportExport.R"
iNZDataImportExport <- setRefClass(
    "iNZDataImportExport",
    fields = list(
        dataSet = "data.frame",
        error = "list"
        ),
    methods = list(
        initialize = function() {
            error <<- list(cur = FALSE)
        },
        importData = function(theFile, ext) {
            tmp = unlist(strsplit(basename(theFile), split="\\."))
            dataset.name = paste(tmp[-length(tmp)], collapse = ".")
            ext.tmp = tmp[length(tmp)]                              
            if(length(ext) == 0)
                setError("Check file type", "Error")
            else if(ext.tmp != ext)
                setError("Chosen file is different than the selected file type",
                         "Error")
            else if (ext %in% c("txt", "csv", "infosharecsv")) {
                if (ext == "txt")
                    out <- try(read.table(theFile, header = TRUE, sep = "\t",
                                          na.strings = c("NULL","NA",
                                              "N/A","#N/A","","<NA>"),
                                          check.names = TRUE))
                else if (ext == "csv")
                    out <- try(read.csv(theFile, header = TRUE,
                                        na.strings = c("NULL","NA","N/A",
                                            "#N/A","","<NA>"),
                                        comment.char = "#",
                                        check.names = TRUE))
                else if (ext == "infosharecsv")
                    out <- try(read.infoshare(theFile))
                if (inherits(out, "try-error")) {
                    setError(sprintf("Error loading file: %s\n", basename(theFile)),
                             "Error loading data file")
                } else {
                    attr(out, "name") <- dataset.name ## associate a name with dataSet
                    dataSet <<- out
                }
            } else if (ext %in% c("xls", "xlsx")) {
                if ("RODBC" %in% row.names(installed.packages()))
                    try(require(RODBC), silent = TRUE)
                
                if (ext == "xls") {
                    channel <-  if (exists("odbcConnectExcel"))
                        try(RODBC::odbcConnectExcel(theFile,
                                                    readOnly = TRUE,
                                                    readOnlyOptimize=TRUE))
                    else
                        NULL
                    excelString <- "Excel"
                } else if (ext == "xlsx") {
                    channel <- if (exists("odbcConnectExcel2007"))
                        try(RODBC::odbcConnectExcel2007(theFile,
                                                        readOnly = TRUE,
                                                        readOnlyOptimize=TRUE))
                    else
                        NULL
                    excelString <- "Excel (>= 2007)"
                }
                if (is.null(channel) || inherits(channel, "try-error")) {
                    setError(paste(sprintf("Error loading file: %s\n", basename(theFile)),
                                   paste("Is", excelString, "present on this system?"),
                                   sep = "\n"),
                             "Error loading Excel file")
                    if (exists("odbcCloseAll"))
                        odbcCloseAll()
                } else {                   
                    out <- try(sqlFetch(channel, sqtable = "Sheet1",
                                        na.strings = c("NULL","NA","N/A","#N/A","","<NA>"),
                                        as.is = TRUE)) #no na.omit()
                    if(inherits(out,"try-error")){
                        setError("Please ensure that the Excel worksheet containing the data is named as Sheet1\n\nIf the error persists, please save the dataset as a CSV (comma separated) file")
                    } else {
                        ## convert character to factor
                        out <- lapply(out, function(x) {
                            if(all(is.na(x)))
                                as.factor(as.character(x))
                            else
                                x})
                        out <- as.data.frame(out)
                        
                        attr(out, "name") <- dataset.name ## associate a name with dataSet
                        dataSet <<- out                       
                        odbcCloseAll()
                    }
                }
            }                                                                  
        },
        setError = function(msg, title=msg, icon = "error") {
            error <<- list(cur = TRUE, title = title,
                           icon = icon, msg = msg)
        })
    )
#line 1 "/Users/tom/iNZight/iNZight/R/datasets.R"
#' Census at School 500
#'
#' A dataset containing 500 observations from a New Zealand census of school
#' students.
#'
#' @format A data frame with 500 rows and 10 variables:
#' \describe{
#'   \item{cellsource}{the source of cellphone money}
#'   \item{rightfoot}{length of the right foot, mm}
#'   \item{travel}{travel method used to get to school}
#'   \item{getlunch}{how they get their lunch}
#'   \item{height}{height measurement, cm}
#'   \item{gender}{their biological gender}
#'   \item{age}{their age, years}
#'   \item{year}{their school year}
#'   \item{armspan}{their armspan measurement, cm}
#'   \item{cellcost}{money spent on cellphones}
#' }
#' @source \url{http://new.censusatschool.org.nz/}
"census.at.school.500"


#' Gap Minder
#'
#' A dataset containing variables for countries over several years.
#'
#' @format A data frame with 3577 rows and 55 variables:
#' \describe{
#'   \item{Country}{the country name}
#'   \item{Region.Geo}{geographical region}
#'   \item{Continent}{continent name}
#'   \item{Region}{region name}
#' }
"gapminder"
#line 1 "/Users/tom/iNZight/iNZight/R/functions.R"
.onAttach <- function(libname, pkgname) {
    lwd <- getOption("width")
    ind <- paste(rep(" ", floor(0.05 * lwd)), collapse = "")
    header <- paste(rep("=", lwd), collapse = "")
    parwrap <- function(txt, indent = "")
        paste(strwrap(txt, prefix = ind), collapse = "\n")

    ## Ensure we're using RGtk2
    options("guiToolkit" = "RGtk2")

    packageStartupMessage(header)
    packageStartupMessage("")
    packageStartupMessage(parwrap("You have successfully loaded the iNZight package!"))
    packageStartupMessage("")
    packageStartupMessage(parwrap("To get started with iNZight simply run the following command:"))
    packageStartupMessage("")
    packageStartupMessage(parwrap("iNZight()"))
    packageStartupMessage("")
    packageStartupMessage(header)

    ## try to load extension packages
    #for (lib in c("iNZightModules", "iNZightTS", "iNZightMR")) {
    #    if (lib %in% installed.packages())
    #        eval(parse(text = paste0("require(", lib, ", quietly = TRUE)")))
    #}
}



iNZSaveFile <- function(theFile, ext, ...) {
    ###################################
    ### generic function to save an object
    ## theFile: file name to be saved, possible with path
    ## ext: the desired extension of the file
    ## which: from which device to save (only for plots)
    ## data: data.frame to save (only for datasets)
    ##       one of which/data needs to be present
    ## ... further arguments like fileType to distinguish
    ##     between different .txt files
    ###################################
    args = list(...)
    if (is.null(args$which) && is.null(args$data))
        return(list(msg = "What to save not specified"))
    ## device number 1 is null device (empty)
    if (!is.null(args$which) && args$which == 1)
        return(list(msg = "There is no plot to save"))
    ## Determine whether a user has specified a file just by name
    ## rather than using the file browser
    dirsep <- if (.Platform$OS.type == "windows") "[\\]" else "/"
    ## In the case that a user has given a filename rather than
    ## a file path, set the save location to the current working dir
    if (length(strsplit(theFile, dirsep)[[1]]) == 1)
        theFile <- paste(getwd(), theFile, sep = .Platform$file.sep)
    tmp <- unlist(strsplit(basename(theFile), split="\\.")) # split on dots
    ext.tmp <- tmp[length(tmp)] # take the string after last dot
    if (length(ext) == 0)
        list(msg = "Invalid extension")
    else if (ext.tmp != ext)
        ## if the specified ext is not attached to thefile, attach it
        theFile <- paste(theFile, ext, sep = ".")

    ## change the class of theFile and then use S3 to get correct fn
    class(theFile) <- ext
    .iNZSaveFile(theFile, ext, ...)
}

.iNZSaveFile <- function(theFile, ext, ...)
    UseMethod('.iNZSaveFile')
## create a function for every file extension
.iNZSaveFile.default <- function(theFile, ext, ...) {
    ## do some default behaviour
}

.iNZSaveFile.pdf <- function(theFile, ext, ...) {
    which <- list(...)$which
    curDev <- dev.cur()
    dev.set(which)
    dev.copy2pdf(file = theFile)
    dev.set(curDev)
    TRUE
}

.iNZSaveFile.png <- function(theFile, ext, ...) {
    which <- list(...)$which
    devwidth <- 640
    devheight <- 640
    curDev <- dev.cur()
    dev.set(which)
    dev.copy(png, file = theFile, width = devwidth, height = devheight)
    tmp <- dev.off()
    dev.set(curDev)
    TRUE
}

.iNZSaveFile.bmp <- function(theFile, ext, ...) {
    which <- list(...)$which
    devwidth <- 640
    devheight <- 640
    curDev <- dev.cur()
    dev.set(which)
    dev.copy(bmp, file = theFile, width = devwidth, height = devheight)
    tmp <- dev.off()
    dev.set(curDev)
    TRUE
}

.iNZSaveFile.tiff <- function(theFile, ext, ...) {
    which <- list(...)$which
    devwidth <- 640
    devheight <- 640
    curDev <- dev.cur()
    dev.set(which)
    dev.copy(tiff, file = theFile, width = devwidth, height = devheight)
    tmp <- dev.off()
    dev.set(curDev)
    TRUE
}

.iNZSaveFile.jpg <- function(theFile, ext, ...) {
    which <- list(...)$which
    devwidth <- 640
    devheight <- 640
    curDev <- dev.cur()
    dev.set(which)
    dev.copy(jpeg, file = theFile, width = devwidth, height = devheight)
    tmp <- dev.off()
    dev.set(curDev)
    TRUE
}

.iNZSaveFile.jpeg <- function(theFile, ext, ...) {
    which <- list(...)$which
    devwidth <- 640
    devheight <- 640
    curDev <- dev.cur()
    dev.set(which)
    dev.copy(jpeg, file = theFile, width = devwidth, height = devheight)
    tmp <- dev.off()
    dev.set(curDev)
    TRUE
}

.iNZSaveFile.csv <- function(theFile, ext, ...) {
    data <- list(...)$data
    write.csv(data, file = theFile, row.names = FALSE)
    TRUE
}

.iNZSaveFile.txt <- function(theFile, ext, ...) {
    data <- list(...)$data
    filetype <- list(...)$fileType
    if (filetype == 4)
        sep = " "
    else
        sep = "\t"
    write.table(data, file = theFile, sep = sep, row.names = FALSE)
    TRUE
}


####################################
## modifyList is defined again here
## because R 3.0.1 does not support the
## keep.null argument. R 3.0.2 does, so
## this can be deleted once the R version
## of the release is updated accordingly
####################################
modifyList <- function (x, val, keep.null = FALSE)
{
    stopifnot(is.list(x), is.list(val))
    xnames <- names(x)
    vnames <- names(val)
    vnames <- vnames[vnames != ""]
    if (keep.null) {
        for (v in vnames) {
            x[v] <- if (v %in% xnames && is.list(x[[v]]) && is.list(val[[v]]))
                list(modifyList(x[[v]], val[[v]], keep.null = keep.null))
            else val[v]
        }
    }
    else {
        for (v in vnames) {
            x[[v]] <- if (v %in% xnames && is.list(x[[v]]) &&
                is.list(val[[v]]))
                modifyList(x[[v]], val[[v]], keep.null = keep.null)
            else val[[v]]
        }
    }
    x
}
#line 1 "/Users/tom/iNZight/iNZight/R/gbuttonFix.R"

#GButton$methods(set_icon = function(value, size = "button") {
#                    ## Set icon using a stock icon
#                    icon <- getStockIconByName(value, toolkit=toolkit)
#                    if(!is.null(icon)) {
#                        image <- gtkImageNew()
#                        image$SetFromStock(icon, size=size)
#                        widget$setImage(image)
#                        widget$image$show()
#                    }
#                })
#line 1 "/Users/tom/iNZight/iNZight/R/gimagebutton.R"
gimagebutton <- function(stock.id = NULL, filename, old_cursor = NULL, ...) {
    img <- if (is.null(stock.id)) gimage(filename = filename, ...)
           else gimage(stock.id = stock.id, ...)
    
    hover <- gdkCursorNew("GDK_HAND1")
    addHandler(img, "enter-notify-event", handler=function(h, ...) {
                   getToolkitWidget(h$obj)$getWindow()$setCursor(hover)
                   TRUE
               })
    addHandler(img, "leave-notify-event", handler=function(h, ...) {
                   getToolkitWidget(h$obj)$getWindow()$setCursor(old_cursor)
                   TRUE
               })
    img
}
#line 1 "/Users/tom/iNZight/iNZight/R/gtoolbariNZ.R"
## ## iNZ toolbar class
## ##' @importClassesFrom gWidgets2RGtk2 GToolBar
## GToolBariNZ <- setRefClass("GToolBariNZ",
##                            contains = "GToolBar",
##                            methods=list(
##                                initialize=function(toolkit=NULL,
##                                    toolbar.list=list(),
##                                    style = c("both", "icons", "text", "both-horiz"),
##                                    container = NULL,
##                                    ...) {
##                                    widget <<- gtkToolbar()
##                                    widget$setStyle(match.arg(style))

##                                    initFields(block=widget,
##                                               toolbar_list=list()
##                                               )

##                                    add_toolbar_items(toolbar.list)

##                                    if(!is.null(container))
##                                        add_to_parent(container, .self, ...)

##                                    callSuper(toolkit)
##                                })
##                            )

## .gtoolbariNZ.guiWidgetsToolkitRGtk2 <-
##     function(toolkit,
##              toolbar.list=list(),
##              style = c("both","icons","text","both-horiz"),
##              container = NULL,
##              ... ) {
##         GToolBariNZ$new(toolkit,
##                         toolbar.list = toolbar.list, style = style,
##                         container = container, ...)
##     }

## gtoolbariNZ <- function(
##                      toolbar.list=list(),
##                      style = c("both", "icons", "text", "both-horiz"),
##                      container = NULL,
##                      ... ,
##                      toolkit=guiToolkit()){
##   obj <- .gtoolbariNZ(toolkit,
##                       toolbar.list=toolbar.list,
##                       style=match.arg(style),
##                       container=container ,...
##                     )

##   check_return_class(obj, "GToolBariNZ")
##   return(obj)
## }


## ## generic for toolkit dispatch
## ##
## ## @export
## ## @rdname gtoolbar
## .gtoolbariNZ <- function(toolkit,
##                       toolbar.list=list(),
##                       style = c("both", "icons", "text", "both-horiz"),
##                       container = NULL,
##                       ... )
##            UseMethod( '.gtoolbariNZ' )


## ##' add toolbar items to toolbar
## ##'
## ##' A toolbar item is a list of action items or a toolbar instance
## ##' @inheritParams add
## ##' @rdname gtoolbar
## ##' @method add GToolBar
## ##' @export
## add.GToolBariNZ <- function(obj, child, expand=FALSE, fill=NULL, anchor=NULL, ...) {
##     dispatcher <- function(obj, child) UseMethod("dispatcher")
##     dispatcher.GToolBariNZ <- function(child, obj) obj$add_toolbar_items(svalue(child))
##     dispatcher.list <- function(obj, child) obj$add_toolbar_items(child)
##     dispatcher(child, obj)
## }




## ##' "svalue<-" method
## ##'
## ##' for a toolbar, \code{svalue<-} replaces the toolbar items with new ones specified by value.
## ##' @inheritParams svalue
## ##' @usage \method{svalue}{GToolBar} (obj, index=NULL, ...) <- value
## ##' @rdname gtoolbar
## ##' @method svalue<- GToolBar
## ##' @export
## "svalue<-.GToolBariNZ" <- function(obj, index=NULL, ..., value) NextMethod()

#line 1 "/Users/tom/iNZight/iNZight/R/iNZChangeDataWin.R"
## --------------------------------------------
## Class that handles the filtering of a dataset
## Upon initialization a window with different filter
## options is displayed. Upon choosing one, this
## window is closed and another window with specifics
## for that filter options is opened
## --------------------------------------------

iNZFilterWin <- setRefClass(
    "iNZFilterWin",
    fields = list(
        GUI = "ANY"
        ),
    methods = list(
        initialize = function(gui = NULL) {
            initFields(GUI = gui)
            usingMethods(opt1, opt2, opt3, opt4)
            if (!is.null(GUI)) {
                ## close any current mod windows
               try(dispose(GUI$modWin), silent = TRUE)
               GUI$modWin <<- gwindow("Filter Dataset...", parent = GUI$win,
                                      width = 300, height = 200,
                                      visible = FALSE)
               mainGrp <- ggroup(cont = GUI$modWin, horizontal = FALSE,
                                 expand = TRUE)
               mainGrp$set_borderwidth(15)
               lbl1 <- glabel("Filter data by:")
               font(lbl1) <- list(weight = "bold", style = "normal")
               filterOpt <- gradio(c("levels of a categorical variable",
                                     "numeric condition", "row number",
                                     "randomly"),
                                   horizontal = FALSE, selected = 1)
               add(mainGrp, lbl1)
               add(mainGrp, filterOpt)
               btnGrp <- ggroup(cont = mainGrp, horizontal = TRUE)
               addSpring(btnGrp)
               proceedButton <- gbutton(
                   "- Proceed -",
                   handler = function(h, ...) {
                       opt <-svalue(filterOpt, index = TRUE)
                       dispose(GUI$modWin)
                       do.call(paste("opt", opt, sep = ""),
                               args = list())
                   })
               add(btnGrp, proceedButton)
               visible(GUI$modWin) <<- TRUE
           }
        },
        ## Window for filtering by levels of a categorical variable
        opt1 = function() {
            GUI$modWin <<- gwindow("Filter data by level",
                                   parent = GUI$win, visible = FALSE,
                                   width = 300, height = 450)
            mainGrp <- ggroup(cont = GUI$modWin, horizontal = FALSE,
                              expand = TRUE)
            mainGrp$set_borderwidth(15)
            btnGrp <- ggroup(horizontal = TRUE)
            lbl1 = glabel("Filter data by :")
            font(lbl1) = list(weight = "bold", style = "normal")
            lbl2 = glabel("Select levels to include")
            font(lbl2) = list(weight = "bold", style = "normal")
            lbl3 = glabel("(Hold Ctrl to choose many)")
            ## choose a factor column from the dataset and display
            ## its levels together with their order
            factorIndices <- sapply(GUI$getActiveData(), is.factor)
            factorMenu <- gcombobox(names(GUI$getActiveData())[factorIndices],
                                    selected = 0)
            addHandlerChanged(factorMenu, handler = function(h, ...) {
                factorLvls[] <- levels(GUI$getActiveData()[svalue(factorMenu)][[1]])
            })
            factorLvls <- gtable("", multiple = TRUE, expand = TRUE)
            names(factorLvls) <- "Levels"
            filterButton <- gbutton(
                "-Filter Data-",
                handler = function(h, ...) {
                    if (length(svalue(factorLvls)) > 0) {
                      originalD <- GUI$getActiveDoc()$getModel()$origDataSet
                      ActiveData <- GUI$getActiveData()
#                      attr(ActiveData, "tag") <- "filtered"
                      idx <- GUI$getActiveData()[[svalue(factorMenu)]] %in%
                        svalue(factorLvls)
                      GUI$setDocument(iNZDocument$new(data = originalD))
                      GUI$getActiveDoc()$getModel()$updateData(
                        droplevels(ActiveData[idx,]))
                      dispose(GUI$modWin)
                    }
                })
            tbl <- glayout()
            tbl[1, 1] <- lbl1
            tbl[1, 2] <- factorMenu
            tbl[2, 1:2, expand = TRUE, anchor = c(-1, -1)] <- lbl2
            tbl[3, 1:2, expand = TRUE, anchor = c(-1, -1)] <- lbl3
            add(mainGrp, tbl)
            add(mainGrp, factorLvls, expand = TRUE)
            add(mainGrp, btnGrp)
            addSpring(btnGrp)
            add(btnGrp, filterButton)
            visible(GUI$modWin) <<- TRUE
        },
        ## Window for filtering by numeric condition
        opt2 = function() {
            GUI$modWin <<- gwindow("Filter data by numeric condition",
                                   parent = GUI$win, visible = FALSE,
                                   width = 300, height = 300)
            mainGrp <- ggroup(cont = GUI$modWin, horizontal = FALSE,
                              expand = TRUE)
            mainGrp$set_borderwidth(15)
            btnGrp <- ggroup(horizontal = TRUE)
            operatorGrp <- ggroup(horizontal = TRUE)
            lessthan = gbutton("  <  ", cont = operatorGrp,
                handler = function(h,...) svalue(operator) <- "<")
            lessthan_equal = gbutton(" <= ", cont = operatorGrp,
                handler = function(h,...) svalue(operator) <- "<=")
            greaterthan = gbutton("  >  ", cont = operatorGrp,
                handler = function(h,...) svalue(operator) <- ">")
            greaterthan_equal = gbutton(" >= ",
                cont = operatorGrp,handler = function(h,...) svalue(operator) <- ">=")
            equal = gbutton(" == ",
                cont = operatorGrp,handler = function(h,...) svalue(operator) <- "==")
            not_equal = gbutton(" != ",
                cont = operatorGrp,handler = function(h,...) svalue(operator) <- "!=")
            addSpring(operatorGrp)
            lbl1 = glabel("Type in your subsetting expression")
            font(lbl1) = list(weight = "bold", style = "normal")
            lbl2 = glabel("eg: X >= 20")
            lbl3 = glabel("eg: X == 20")
            lbl4 = glabel("Choose observations in the dataset where :")
            font(lbl4) = list(weight = "bold", style = "normal")
            numIndices <- sapply(GUI$getActiveData(), function(x) !is.factor(x))
            numMenu <- gcombobox(names(GUI$getActiveData())[numIndices],
                                 selected = 0)
            operator <- gedit("", width = 2)
            expr <- gedit("") ## the expression specified by the user
            submitButton <- gbutton(
                "Submit",
                handler = function(h, ...) {
                  originalD <- GUI$getActiveDoc()$getModel()$origDataSet
                  ActiveData <- GUI$getActiveData()
                  subsetExpression <- paste(svalue(numMenu),
                                            svalue(operator),
                                            gsub(pattern = '\\n+', "",
                                                 svalue(expr),
                                                 perl = TRUE))
                  subsetData <- try(
                    droplevels(subset(GUI$getActiveData(),
                           eval(parse(text = eval(subsetExpression)))))
                  )
                  if(class(subsetData)[1] == "try-error"){
                    gmessage(title = "ERROR",
                             msg = "Error in expression!",
                             icon = "error",
                             parent = GUI$modWin)
                  } else {
                    
                    GUI$setDocument(iNZDocument$new(data = originalD))
                    GUI$getActiveDoc()$getModel()$updateData(
                      subsetData)
                    dispose(GUI$modWin)
                    }
                })
            tbl <- glayout()
            tbl[1, 1:7, expand = TRUE, anchor = c(-1, 0)] <- lbl1
            tbl[2, 1:7, expand = TRUE, anchor = c(-1, 0)] <- lbl2
            tbl[3, 1:7, expand = TRUE, anchor = c(-1, 0)] <- lbl3
            tbl[4, 1:7, expand = TRUE, anchor = c(-1, 0)] <- lbl4
            tbl[5, 1:4] <- numMenu
            tbl[5, 5] <- operator
            tbl[5, 6:7, expand = TRUE] <- expr
            tbl[6, 1:7] <- operatorGrp
            add(mainGrp, tbl)
            add(mainGrp, btnGrp)
            addSpring(btnGrp)
            add(btnGrp, submitButton)
            visible(GUI$modWin) <<- TRUE
        },
        ## Window for filtering by row numbers
        opt3 = function() {
            GUI$modWin <<- gwindow("Filter data by specified row number",
                                   parent = GUI$win, visible = FALSE,
                                   width = 300, height = 300)
            mainGrp <- ggroup(cont = GUI$modWin, horizontal = FALSE,
                              expand = TRUE)
            mainGrp$set_borderwidth(15)
            btnGrp <- ggroup(horizontal = TRUE)
            lbl1 <- glabel("Type in the Row.names of observations\nthat need to be excluded")
            font(lbl1) <- list(weight = "bold", style = "normal")
            lbl2 <- glabel("(separate each value by a comma)")
            lbl3 <- glabel("EXAMPLE")
            font(lbl3) <- list(weight = "bold", style = "normal")
            lbl4 <- glabel("1,5,99,45,3")
            unwantedObs <- gedit("")
            submitButton <- gbutton(
                "Submit",
                handler = function(h, ...) {
                  originalD <- GUI$getActiveDoc()$getModel()$origDataSet
                  ActiveData <- GUI$getActiveData()
                  rowNumbers <- try(
                    strsplit(gsub(pattern = '\\s+',
                                  replacement = "",
                                  svalue(unwantedObs),
                                  perl = TRUE),
                             ",", fixed = TRUE)[[1]]
                  )
                  if (inherits(rowNumbers,"try-error") ||
                        is.na(rowNumbers)) {
                    gmessage(title = "ERROR",
                             msg = "Error in typed values.\nCheck for missing commas or non-existing Row.names",
                             icon = "error",
                             parent = GUI$modWin)
                  } else {
                    ranges <- grep(":", rowNumbers)
                    if (length(ranges) > 0) {
                      rowRanges <- rowNumbers[ranges]
                      rowNumbers <- as.numeric(rowNumbers[-ranges])
                      rowRanges <- as.vector(sapply(
                        rowRanges, function(m) eval(parse(text=m))))
                      rowNumbers <- unique(c(rowNumbers, rowRanges))
                    }
                    if(!all(rowNumbers %in%
                              as.numeric(row.names(GUI$getActiveData()))))
                      gmessage(title = "ERROR",
                               msg = "You have entered one or more non-existing Row.names",
                               icon = "error",
                               parent = GUI$modWin)
                    else {
                      GUI$setDocument(iNZDocument$new(data = originalD))
                      idx <- !rownames(ActiveData) %in% rowNumbers
                      ## please notice iNZdataViewWidget/createDfView to show small number of row even when the original data is large
                      GUI$getActiveDoc()$getModel()$updateData(
                        droplevels(ActiveData[idx, ]))
                      # so after the above step, we may update the gdf panel in iNZdataViewWidget
                      dispose(GUI$modWin)
                    }
                  }
                })
            add(mainGrp, lbl1)
            add(mainGrp, lbl2)
            add(mainGrp, lbl3)
            add(mainGrp, lbl4)
            add(mainGrp, unwantedObs, expand = TRUE)
            add(mainGrp, btnGrp)
            addSpring(btnGrp)
            add(btnGrp, submitButton)
            visible(GUI$modWin) <<- TRUE
        },
        ## Window for filtering by random sample
        opt4 = function() {
            GUI$modWin <<- gwindow("Filter data by random sample",
                                   parent = GUI$win, visible = FALSE,
                                   width = 200, height = 100)
            mainGrp <- ggroup(cont = GUI$modWin, horizontal = FALSE,
                              expand = TRUE)
            mainGrp$set_borderwidth(15)
            btnGrp <- ggroup(horizontal = TRUE)
            lbl1 <- glabel("Specify the size of your sample")
            font(lbl1) <- list(weight = "bold", style = "normal")
            numSample <- gspinbutton(from = 1, to = 99999, by = 1)
            sampleSize <- gedit("", width =4)
            submitButton <- gbutton(
                "Submit",
                handler = function(h, ...) {
                  originalD <- GUI$getActiveDoc()$getModel()$origDataSet
                  ActiveData <- GUI$getActiveData()
                  sSize <- as.numeric(svalue(sampleSize))
                  if (svalue(numSample) == 1){ 
                    if (is.na(sSize) || sSize > nrow(GUI$getActiveData()))
                      gmessage(title = "ERROR",
                               msg = "Number of Samples X Sample Size cannot exceed Total 
                                 number of rows",
                               icon = "error",
                               parent = GUI$modWin)
                    else {
                      rdmSample <- sample(1:nrow(GUI$getActiveData()),
                                          size = sSize)
                      GUI$setDocument(iNZDocument$new(data = originalD))
                      GUI$getActiveDoc()$getModel()$updateData(
                        droplevels(ActiveData[rdmSample, ]))
                      dispose(GUI$modWin)
                    }
                  }
                  else{
                    if (is.na(sSize) || sSize > nrow(GUI$getActiveData()))
                      gmessage(title = "ERROR",
                               msg = "T",
                               icon = "error",
                               parent = GUI$modWin)
                    else {
                      rdmSample <- numeric(0)
                      
                      
                      if (sSize*svalue(numSample) < nrow(GUI$getActiveData()))
                        rdmSample = sample(1:nrow(GUI$getActiveData()), 
                                           size = sSize*svalue(numSample))
                      else 
                        return(gmessage(title = "ERROR",
                                        msg = "The total sample number is greater than the sample size",
                                        icon = "error",
                                        parent = GUI$modWin))
                      
                      GUI$setDocument(iNZDocument$new(data = originalD))
                      GUI$getActiveDoc()$getModel()$updateData(
                        droplevels(ActiveData[rdmSample, ]))
                      
                      newVar <- as.character(rep(1:svalue(numSample) , each = sSize))
                      
                      newNames <- "Sample Number"
                      
                      insertData(data = newVar,
                                 name = newNames,
                                 index = ncol(GUI$getActiveData()),
                                 msg = list(
                                   msg = "The new variables are added to the end of the dataset",
                                   icon = "info"
                                 ),
                                 closeAfter = TRUE)
                      
                      
                      
                      #dispose(GUI$modWin)
                    }
                  }
                })
            tbl <- glayout()
            tbl[1,1:2] <- lbl1
            tbl[2, 1] <- "Total number of rows:"
            tbl[2, 2] <- glabel(nrow(GUI$getActiveData()))
            tbl[3, 1] <- "Sample Size:"
            tbl[3, 2] <- sampleSize
            tbl[4, 1] <- "Number of Samples"
            tbl[4, 2] <- numSample
            add(mainGrp, lbl1)
            add(mainGrp, tbl)
            add(mainGrp, btnGrp)
            addSpring(btnGrp)
            add(btnGrp, submitButton)
            visible(GUI$modWin) <<- TRUE
        }, 
        insertData = function(data, name, index, msg = NULL, closeAfter = TRUE) {
          ## insert the new variable in the column after the old variable
          ## or at the end if the old variable is the last column in the
          ## data
          if (index != length(names(GUI$getActiveData()))) {
            newData <- data.frame(
              GUI$getActiveData()[, 1:index],
              data,
              GUI$getActiveData()[, (index+1):ncol(GUI$getActiveData())]
            )
            newNames <- c(
              names(GUI$getActiveData())[1:index],
              name,
              names(GUI$getActiveData())[(index+1):ncol(GUI$getActiveData())]
            )
            newNames <- make.names(newNames, unique = TRUE)
            names(newData) <- newNames
          } else {
            newData <- data.frame(GUI$getActiveData(), data)
            names(newData) <- make.names(c(names(GUI$getActiveData()),
                                           name), unique = TRUE)
          }
          
          if (!is.null(msg))
            do.call(gmessage, msg)
          
          GUI$getActiveDoc()$getModel()$updateData(newData)
          if (closeAfter)
            dispose(GUI$modWin)
        })
)



## --------------------------------------------
## Class that handles the reshaping of a dataset
## --------------------------------------------

iNZReshapeDataWin <- setRefClass(
  "iNZReshapeDataWin",
  fields = list(
    GUI = "ANY"
  ),
  methods = list(
    initialize = function(gui = NULL) {
      initFields(GUI = gui)
      if (!is.null(GUI)) {
        ## close any current mod windows
        try(dispose(GUI$modWin), silent = TRUE)
        GUI$modWin <<- gwindow("Filter data by numeric condition",
                                   parent = GUI$win, visible = FALSE)
            mainGrp <- ggroup(cont = GUI$modWin, horizontal = FALSE,
                              expand = TRUE)
            mainGrp$set_borderwidth(15)
            btnGrp <- ggroup(horizontal = TRUE)
            lbl1 <- glabel("Reshape your dataset so that groups\nas columns are transformed to cases by variables")
            conv.image <- gimage(system.file("images/groups-wide-to-tall.png",
                                             package = "iNZight"))
            reshapeButton <- gbutton(
                "Reshape",
                handler = function(h, ...) {
                    if (ncol(GUI$getActiveData()) <= 1)
                        gmessage("Unable to reshape datasets with a single column", "Error", icon = "error")
                    else {
                        GUI$getActiveDoc()$getModel()$updateData(
                            wide.to.tall(GUI$getActiveData()))
                        dispose(GUI$modWin)
                    }

                })
            add(mainGrp, lbl1)
            add(mainGrp, conv.image)
            add(mainGrp, btnGrp)
            addSpring(btnGrp)
            add(btnGrp, reshapeButton)
            visible(GUI$modWin) <<- TRUE
            }
        },
        wide.to.tall = function(data) {
            varnames <- names(data)
            values <- unlist(data)
            names(values) <- NULL
            group.labels <- factor(rep(varnames, each = nrow(data)), levels = names(data))
            data <- data.frame(group.labels, values)
            names(data) <- c("group", "value")
            data
        })
)


## --------------------------------------------
## Class that handles the sortby of a dataset
## --------------------------------------------
iNZSortbyDataWin <- setRefClass(
  "iNZSortbyDataWin",
  fields = list(
    GUI = "ANY"
  ),
  methods = list(
    initialize = function(gui = NULL) {
      initFields(GUI = gui)
      if (!is.null(GUI)) {
        ## close any current mod windows
        try(dispose(GUI$modWin), silent = TRUE)
        GUI$modWin <<- gwindow("Sort data by variables",
                               parent = GUI$win, visible = FALSE)
        mainGrp <- ggroup(cont = GUI$modWin, horizontal = FALSE,
                          expand = TRUE)
        mainGrp$set_borderwidth(15)
        btnGrp <- ggroup(horizontal = TRUE)
        lbl1 <- glabel("Sort by")
        font(lbl1) <- list(weight = "bold", style = "normal")
        lbl2 <- glabel("Variable")
        nameList <- names(GUI$getActiveData())
        SortByButton <- gbutton(
          "Sort Now",
          handler = function(h, ...) {
            dataSet <- GUI$getActiveData()
            argList <- list()
            for (i in 1:4) {
              con <- eval(parse(text=paste(c("svalue(droplist_var",i, ")"), collapse="")))
              con2 <- eval(parse(text=paste(c("svalue(radio_var",i, ")"), collapse="")))
              if (con != "") {
                datai <- dataSet[, con]
                if (inherits(datai, "character") | inherits(datai, "factor"))
                  datai <- xtfrm(datai)
                if (con2 != "increasing")
                  datai <- -datai
                argList[[length(argList) + 1]] <- datai
              }
            }
            
            if (identical(argList,list()))
              return(gmessage("Select at leat one variable!",
                              parent = GUI$win))
            idx <- do.call("order", argList)
            GUI$getActiveDoc()$getModel()$updateData(
              GUI$getActiveData()[idx, ])
            dispose(GUI$modWin)
            
          })
        
        label_var1 <- glabel("1st")
        label_var2 <- glabel("2nd")
        label_var3 <- glabel("3rd")
        label_var4 <- glabel("4th")
        droplist_var1 <- gcombobox(c("",nameList), selected = 1)                  
        droplist_var2 <- gcombobox(c("",nameList), selected= 1)
        droplist_var3 <- gcombobox(c("",nameList), selected = 1)
        droplist_var4 <- gcombobox(c("",nameList), selected = 1)
        radio_var1 <- gradio(c("increasing","decreasing"), horizontal = TRUE)
        radio_var2 <- gradio(c("increasing","decreasing"), horizontal = TRUE)
        radio_var3 <- gradio(c("increasing","decreasing"), horizontal = TRUE)
        radio_var4 <- gradio(c("increasing","decreasing"), horizontal = TRUE)
        tbl <- glayout()
        tbl[1, 1, expand = TRUE, anchor = c(-1, -1)] <- label_var1
        tbl[1, 2, expand = TRUE, anchor = c(-1, -1)] <- droplist_var1
        tbl[1, 3, expand = TRUE, anchor = c(-1, -1)] <- radio_var1
        tbl[2, 1, expand = TRUE, anchor = c(-1, -1)] <- label_var2
        tbl[2, 2, expand = TRUE, anchor = c(-1, -1)] <- droplist_var2
        tbl[2, 3, expand = TRUE, anchor = c(-1, -1)] <- radio_var2
        tbl[3, 1, expand = TRUE, anchor = c(-1, -1)] <- label_var3
        tbl[3, 2, expand = TRUE, anchor = c(-1, -1)] <- droplist_var3
        tbl[3, 3, expand = TRUE, anchor = c(-1, -1)] <- radio_var3
        tbl[4, 1, expand = TRUE, anchor = c(-1, -1)] <- label_var4
        tbl[4, 2, expand = TRUE, anchor = c(-1, -1)] <- droplist_var4
        tbl[4, 3, expand = TRUE, anchor = c(-1, -1)] <- radio_var4
        add(mainGrp, lbl1, anchor = c(-1, -1))
        addSpring(mainGrp)
        add(mainGrp, lbl2, anchor = c(-1, -1))
        add(mainGrp, tbl)
        add(mainGrp, btnGrp)
        addSpring(btnGrp)
        add(btnGrp, SortByButton)
        visible(GUI$modWin) <<- TRUE
      }
    }
  )
)


## --------------------------------------------
## Class that handles aggregate the data set
## --------------------------------------------
iNZAgraDataWin <- setRefClass(
  "iNZAgraDataWin",
  fields = list(
    GUI = "ANY"
  ),
  methods = list(
    initialize = function(gui = NULL) {
      initFields(GUI = gui)
      if (!is.null(GUI)) {
        ## close any current mod windows
        try(dispose(GUI$modWin), silent = TRUE)
        GUI$modWin <<- gwindow("Aggregation to the data",
                               parent = GUI$win, visible = FALSE)
        mainGrp <- ggroup(cont = GUI$modWin, horizontal = FALSE,
                          expand = TRUE)
        mainGrp$set_borderwidth(15)
        btnGrp <- ggroup(horizontal = TRUE)
        nameList <- names(Filter(is.factor,GUI$getActiveData()))
        heading <- glabel("Aggregate over variables:")
        font(heading) <- list(weight = "bold", style = "normal")
        AgraButton <- gbutton(
          "Aggregate Now",
          handler = function(h, ...) {
            originalD <- GUI$getActiveDoc()$getModel()$origDataSet
            dataSet <- GUI$getActiveData()
            con <- c(svalue(droplist_var1), svalue(droplist_var2), svalue(droplist_var3))
            if (all(con %in% ""))
              return(gmessage("Select at leat one variable!",
                              parent = GUI$win))
            con <- con[which(con!="")]
            con2 <- c("mean","median","sum","sd","IQR","length")[svalue(func.table, index=TRUE)]
            if(length(con2) == 0)
              return(gmessage("Select at leat one function!",
                              parent = GUI$win))
            
          
            out <- ddply(na.omit(dataSet), as.quoted(con), numcolwise(con2[1]))
            nameVec <- c(con, paste0(names(Filter(is.numeric, dataSet)), ".", con2[1]))
            names(out) <- nameVec 
            
            if (length(con2) > 1) {
              for (i in 2:length(con2)){
                out1 <- ddply(na.omit(dataSet), as.quoted(con), numcolwise(con2[i]))  
                nameVec <- c(con, paste0(names(Filter(is.numeric, dataSet)), ".", con2[i]))
                names(out1) <- nameVec 
                out = join(out,out1, by=con)
              }
            }
            id = sort(names(out)[-(1:length(con))])
            GUI$setDocument(iNZDocument$new(data = originalD))
            GUI$getActiveDoc()$getModel()$updateData(out[, c(con, id)])
            
            
            dispose(GUI$modWin)
              
            
          })
        label_var1 <- glabel("1st")
        label_var2 <- glabel("2nd")
        label_var3 <- glabel("3rd")
        droplist_var1 <- gcombobox(c("",nameList), selected = 1)
        droplist_var2 <- gcombobox(c("",nameList), selected= 1)
        droplist_var3 <- gcombobox(c("",nameList), selected = 1)
        func.frame <- data.frame(c("Mean", "Median", "Sum", "Sd", "IQR", "Count"))
        names(func.frame) <- "Summeries: "
        func.table <- gtable(func.frame, multiple=TRUE)
        func.table$remove_popup_menu() # remove the popup menu from gtable()
        tbl <- glayout()
        tbl[2, 1, expand = TRUE, anchor = c(-1, -1)] <- label_var1
        tbl[2, 2, expand = TRUE, anchor = c(-1, -1)] <- droplist_var1
        tbl[3, 1, expand = TRUE, anchor = c(-1, -1)] <- label_var2
        tbl[3, 2, expand = TRUE, anchor = c(-1, -1)] <- droplist_var2
        tbl[4, 1, expand = TRUE, anchor = c(-1, -1)] <- label_var3
        tbl[4, 2, expand = TRUE, anchor = c(-1, -1)] <- droplist_var3
        tbl[5:25, 1:2, expand =TRUE, anchor = c(-1, -1)] <- func.table
        add(mainGrp, heading)
        addSpring(mainGrp)
        add(mainGrp, tbl)
        add(mainGrp, btnGrp)
        #addSpring(btnGrp)
        add(btnGrp, AgraButton)
        visible(GUI$modWin) <<- TRUE
      }
    }
  )
)


iNZstackVarWin <- setRefClass(
  "iNZstackVarWin",
  fields = list(
    GUI = "ANY"
  ),
  methods = list(
    initialize = function(gui = NULL) {
      initFields(GUI = gui)
      if (!is.null(GUI)) {
        ## close any current mod windows
        try(dispose(GUI$modWin), silent = TRUE)
        GUI$modWin <<- gwindow("Stack data by Variables",
                               parent = GUI$win, visible = FALSE)
        mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
        ## instructions through glabels
        lbl1 <- glabel("Choose variables to stack")
        font(lbl1) <- list(weight = "bold",
                           family = "normal")
        lbl2 <- glabel("(Hold Ctrl to choose many)")
        font(lbl2) <- list(weight = "bold",
                           family = "normal")
        ## display only numeric variables
        numIndices <- sapply(GUI$getActiveData(), function(x) !is.factor(x))
        numVar <- gtable(names(GUI$getActiveData())[numIndices],
                         multiple = TRUE)
        names(numVar) <- "Variables"
        StackButton <- gbutton("Stack", handler = function(h, ...) {
          if (length(svalue(numVar)) > 0) {
            measure.vars <- svalue(numVar)
            dat <- GUI$getActiveData()
            out <- reshape2:::melt.data.frame(dat, measure.vars = measure.vars, 
                                              variable.name = "stack.variable",
                                              value.name = "stack.value")
            GUI$getActiveDoc()$getModel()$updateData(out)
            
            
            dispose(GUI$modWin)
          }
        })
        add(mainGroup, lbl1)
        add(mainGroup, lbl2)
        add(mainGroup, numVar, expand = TRUE)
        add(mainGroup, StackButton)
        add(GUI$modWin, mainGroup, expand = TRUE, fill = TRUE)
        visible(GUI$modWin) <<- TRUE
      }
    })
)
#line 1 "/Users/tom/iNZight/iNZight/R/iNZControlWidget.R"
iNZControlWidget <- setRefClass(
    "iNZControlWidget",
    fields = list(
        GUI = "ANY",
        ctrlGp = "ANY",
        V1box = "ANY",
        V2box = "ANY",
        G1box = "ANY",
        G2box = "ANY",
        playButton = "list",
        playdelay = "numeric"
        ),
    methods = list(
        initialize = function(gui) {
            ctrlGp <<- ggroup(horizontal = FALSE)
            initFields(GUI = gui, playdelay = 0.6)
            ## set up glayout
            tbl <- glayout(expand = TRUE, homogeneous = FALSE, cont = ctrlGp, spacing = 5)

            ### DRAG/DROP MENUS

            V1box <<- gcombobox(c("Select/Drag-drop Variable 1", colnames(GUI$getActiveData())))
            V2box <<- gcombobox(c("Select/Drag-drop Variable 2", colnames(GUI$getActiveData())))
            G1box <<- gcombobox(c("Select/Drag-drop Subset Variable 1", colnames(GUI$getActiveData())))
            G2box <<- gcombobox(c("Select/Drag-drop Subset Variable 2", colnames(GUI$getActiveData())))

            tbl[1,1:5, anchor = c(0,0), expand = TRUE] <- V1box
            tbl[3,1:5, anchor = c(0,0), expand = TRUE] <- V2box
            tbl[5,1:5, anchor = c(0,0), expand = TRUE] <- G1box
            tbl[7,1:5, anchor = c(0,0), expand = TRUE] <- G2box


            ### CLEAR BUTTONS

            ## -- Variable 1
            V1clearbtn <- gimagebutton(stock.id = "cancel",
                                  handler = function(h,...) {
                                      svalue(V1box, index = TRUE) <<- 1
                                      changePlotSettings(list(x = NULL))
                                  })
            ## V1clearbtn$set_icon("Cancel")
            tbl[1,7, anchor = c(0,0)] <- V1clearbtn

            ## old_cursor <- getToolkitWidget(GUI$win)$getWindow()$getCursor()
            ## cross <- gdkCursorNew("GDK_HAND1")
            ## addHandler(switchV12, "enter-notify-event", handler=function(h,...) {
            ##                getToolkitWidget(switchV12)$getWindow()$setCursor(cross)
            ##                TRUE
            ##            })
            ## addHandler(switchV12, "leave-notify-event", handler=function(h,...) {
            ##                getToolkitWidget(switchV12)$getWindow()$setCursor(old_cursor)
            ##                TRUE
            ##            })

            ## -- Variable 2
            V2clearbtn <- gimagebutton(stock.id = "cancel",
                                  handler = function(h,...) {
                                      svalue(V2box, index = TRUE) <<- 1
                                      changePlotSettings(list(y = NULL,
                                                              varnames = list(
                                                                  y = NULL)),
                                                         reset = { GUI$plotType != "dot" })
                                  })
            ## V2clearbtn$set_icon("Cancel")
            tbl[3,7, anchor = c(0,0)] <- V2clearbtn

            ## -- Grouping Variable 1
            G1clearbtn <- gimagebutton(stock.id = "cancel",
                                  handler = function(h,...) {
                                      svalue(G1box, index = TRUE) <<- 1
                                      ## change handler will handle the rest
                                  })
            tbl[5,7, anchor = c(0,0)] <- G1clearbtn

            ## -- Grouping Variable 2
            G2clearbtn <- gimagebutton(stock.id = "cancel",
                                  handler = function(h,...) {
                                      svalue(G2box, index = TRUE) <<- 1
                                  })
            tbl[7,7, anchor = c(0,0)] <- G2clearbtn


            ## "SWITCH" buttons:
            switchV12 <- gimagebutton("go-down")
            addHandlerClicked(switchV12, function(h, ...) {
                                  if (svalue(V1box, TRUE) == 1 || svalue(V2box, TRUE) == 1) {
                                      gmessage("Need both Variable 1 and Variable 2 selected", icon = "error")
                                      return()
                                  }
                                  
                                  V1 <- svalue(V1box)
                                  V2 <- svalue(V2box)
                                  
                                  blockHandlers(V1box)
                                  blockHandlers(V2box)
                                  
                                  svalue(V1box) <<- V2
                                  svalue(V2box) <<- V1
                                  
                                  valX <- svalue(V1box)
                                  newX <- GUI$getActiveDoc()$getData()[valX][[1]]
                                  newXname <- valX
                                  
                                  valY <- svalue(V2box)
                                  newY <- GUI$getActiveDoc()$getData()[valY][[1]]
                                  newYname <- valY
                                  
                                  changePlotSettings(list(
                                      x = newX, y = newY,
                                      xlab = NULL, ylab = NULL,
                                      main = NULL,
                                      varnames = list(x = newXname, y = newYname)
                                      ), reset = TRUE)
                                  
                                  unblockHandlers(V1box)
                                  unblockHandlers(V2box)
                              })
            switchV23 <- gimagebutton("go-down")
            addHandlerClicked(switchV23, function(h, ...) {
                                  if (svalue(V2box, TRUE) == 1 && svalue(G1box, TRUE) == 1) {
                                      gmessage("Need at least one of Variable 2 and Subset Variable 1 selected", icon = "error")
                                      return()
                                  }
                                  
                                  V2 <- svalue(V2box, TRUE)
                                  G1 <- svalue(G1box, TRUE)

                                  blockHandlers(V2box)
                                  blockHandlers(G1box)

                                  deleteSlider(pos = 6)
                                  svalue(V2box, TRUE) <<- G1
                                  svalue(G1box, TRUE) <<- V2

                                  if (svalue(V2box, TRUE) == 1) {
                                      valY <- NULL
                                      newY <- NULL
                                  } else {
                                      valY <- svalue(V2box)
                                      newY <- GUI$getActiveDoc()$getData()[valY][[1]]
                                  }
                                  newYname <- valY

                                  if (svalue(G1box, TRUE) == 1) {
                                      changePlotSettings(list(y = newY, ylab = NULL, xlab = NULL,
                                                              main = NULL,
                                                              g1 = NULL,
                                                              g1.level = NULL,
                                                              varnames = list(
                                                                  y = newYname,
                                                                  g1 = NULL)
                                                              ), reset = TRUE)
                                  } else {
                                      valG1 <- svalue(G1box)
                                      newG1 <-  iNZightPlots:::convert.to.factor(GUI$getActiveDoc()$getData()[valG1][[1]])
                                      newG1name <- valG1

                                      createSlider(pos = 6, valG1)
                                      changePlotSettings(list(y = newY, ylab = NULL, xlab = NULL,
                                                              main = NULL,
                                                              g1 = newG1,
                                                              g1.level = "_MULTI",
                                                              varnames = list(
                                                                  y = newYname,
                                                                  g1 = newG1name)
                                                              ))
                                  }

                                  unblockHandlers(V2box)
                                  unblockHandlers(G1box)
                                  
                              })
            switchV34 <- gimagebutton("go-down")
            addHandlerClicked(switchV34, function(h, ...) {
                                  if (svalue(G1box, TRUE) == 1 && svalue(G2box, TRUE) == 1) {
                                      gmessage("Need at least one subsetting variable selected", icon = "error")
                                      return()
                                  }

                                  G1 <- svalue(G1box, TRUE)
                                  G2 <- svalue(G2box, TRUE)

                                  blockHandlers(G1box)
                                  blockHandlers(G2box)

                                  deleteSlider(pos = 6)
                                  deleteSlider(pos = 8)
                                  svalue(G2box, TRUE) <<- G1
                                  svalue(G1box, TRUE) <<- G2

                                  if (svalue(G1box, TRUE) == 1) {
                                      varG1 <- NULL
                                      newG1 <- NULL
                                      newG1name <- NULL
                                      newG1level <- NULL
                                  } else {
                                      valG1 <- svalue(G1box)
                                      newG1 <- iNZightPlots:::convert.to.factor(GUI$getActiveDoc()$getData()[valG1][[1]])
                                      newG1name <- valG1
                                      newG1level <- "_MULTI"
                                      createSlider(pos = 6, valG1)
                                  }
                                  if (svalue(G2box, TRUE) == 1) {
                                      varG2 <- NULL
                                      newG2 <- NULL
                                      newG2name <- NULL
                                      newG2level <- NULL
                                  } else {
                                      valG2 <- svalue(G2box)
                                      newG2 <- iNZightPlots:::convert.to.factor(GUI$getActiveDoc()$getData()[valG2][[1]])
                                      newG2name <- valG2
                                      newG2level <- "_ALL"
                                      createSlider(pos = 8, valG2)
                                  }

                                  changePlotSettings(list(main = NULL,
                                                          g1 = newG1, g2 = newG2,
                                                          g1.level = newG1level, g2.level = newG2level,
                                                          varnames = list(
                                                              g1 = newG1name,
                                                              g2 = newG2name)
                                                          ))

                                  unblockHandlers(G1box)
                                  unblockHandlers(G2box)
                              })

            tbl[1, 6] <- switchV12
            tbl[3, 6] <- switchV23
            tbl[5, 6] <- switchV34

            ## add drop functionality to the fields

            ## -- Variable 1
            addDropTarget(
                V1box,
                handler = function(h, ...) {
                    svalue(h$obj) <- h$dropdata
                })
            addHandlerChanged(
                V1box,
                handler = function(h, ...) {
                    if (svalue(V1box, TRUE) == 1) {
                        newX <- NULL
                        newXname <- NULL
                    } else {
                        val <- svalue(V1box)
                        newX <- GUI$getActiveDoc()$getData()[val][[1]]
                        newXname <- val
                    }
                    
                    changePlotSettings(list(
                        x = newX,
                        xlab = NULL,
                        main = NULL,
                        varnames = list(x = newXname)
                    ), reset = TRUE)
                })
            ## -- Variable 2
            addDropTarget(
                V2box,
                handler = function(h, ...) {
                    svalue(h$obj) <- h$dropdata
                })
            addHandlerChanged(
                V2box,
                handler = function(h, ...) {
                    if (svalue(V2box, TRUE) == 1) {
                        newY <- NULL
                        newYname <- NULL
                    } else {
                        val <- svalue(V2box)
                        newY <- GUI$getActiveDoc()$getData()[val][[1]]
                        newYname <- val
                    }
                    
                    changePlotSettings(list(
                        y = newY,
                        ylab = NULL,
                        main = NULL,
                        varnames = list(y = newYname)
                    ), reset = TRUE)
                })
            ## slider 1
            addDropTarget(
                G1box,
                handler = function(h, ...) {
                    svalue(h$obj) <- h$dropdata
                })
            addHandlerChanged(
                G1box,
                handler = function(h, ...) {
                    if (svalue(G1box) == svalue(G2box)) {
                        svalue(G1box, index = TRUE) <<- 1
                        gmessage("You cannot use the same variable in both subsetting slots.",
                                 parent = GUI$win)
                    } else {
                        deleteSlider(pos = 6)
                        if (svalue(G1box, index = TRUE) > 1) {
                            val <- svalue(G1box)
                            createSlider(pos = 6, val)
                            changePlotSettings(list(
                                g1 = iNZightPlots:::convert.to.factor(
                                    GUI$getActiveDoc()$getData()[val][[1]]
                                    ),
                                g1.level = "_MULTI",
                                main = NULL,
                                varnames = list(
                                    g1 = val)
                                ))
                        } else {
                            changePlotSettings(list(g1 = NULL,
                                                    g1.level = NULL,
                                                    varnames = list(
                                                        g1 = NULL)
                                                    ), reset = TRUE)
                        }
                    }
                })

            ## slider 2
            addDropTarget(
                G2box,
                handler = function(h, ...) {
                    svalue(h$obj) <- h$dropdata
                })
            addHandlerChanged(
                G2box,
                handler = function(h, ...) {
                    if (svalue(G2box) == svalue(G1box)) {
                        svalue(G2box, index = TRUE) <<- 1
                        gmessage("You cannot use the same variable in both subsetting slots.",
                                 parent = GUI$win)
                    } else {
                        deleteSlider(pos = 8)
                        if (svalue(G2box, index = TRUE) > 1) {
                            val <- svalue(G2box)
                            createSlider(pos = 8, val)
                            changePlotSettings(list(
                                g2 = iNZightPlots:::convert.to.factor(
                                    GUI$getActiveDoc()$getData()[val][[1]]
                                    ),
                                g2.level = "_ALL",
                                main = NULL,
                                varnames = list(
                                    g2 = val)
                                ))
                        } else {
                            changePlotSettings(list(g2 = NULL,
                                                    g2.level = NULL,
                                                    varnames = list(
                                                        g2 = NULL)
                                                    ), reset = TRUE)
                        }
                    }
                })
        },
        ## change the plotSettings
        changePlotSettings = function(setList, reset = FALSE) {
            GUI$getActiveDoc()$setSettings(setList, reset)
        },
        updateVariables = function() {
            datavars <- colnames(GUI$getActiveData())

            v1 <- if (svalue(V1box) %in% datavars) which(datavars == svalue(V1box)) + 1 else 1
            V1box$set_items(c(V1box$get_items()[1], datavars))
            V1box$set_value(GUI$ctrlWidget$V1box$get_items()[v1])

            v2 <- if (svalue(V2box) %in% datavars) which(datavars == svalue(V2box)) + 1 else 1
            V2box$set_items(c(V2box$get_items()[1], datavars))
            V2box$set_value(GUI$ctrlWidget$V2box$get_items()[v2])

            g1 <- if (svalue(G1box) %in% datavars) which(datavars == svalue(G1box)) + 1 else 1
            G1box$set_items(c(G1box$get_items()[1], datavars))
            G1box$set_value(GUI$ctrlWidget$G1box$get_items()[g1])

            g2 <- if (svalue(G2box) %in% datavars) which(datavars == svalue(G2box)) + 1 else 1
            G2box$set_items(c(G2box$get_items()[1], datavars))
            G2box$set_value(GUI$ctrlWidget$G2box$get_items()[g2])
        },
        createSlider = function(pos, dropdata) {
            ## make sure there is no slider at the pos
            deleteSlider(pos)

            ## ##################################
            ## ## This is a workaround for the current bug in
            ## ## gWidgets2RGtk2. Remove this code once the bug
            ## ## is fixed! Comes in 2 parts
            ## ##################################
            ## if (pos == 8) {
            ##     childPos <- which(sapply(ctrlGp$children[[1]]$child_positions,
            ##                          function(x) x$x == 10))
            ##     if (length(childPos) > 0) {
            ##         g2Data <- svalue(ctrlGp$children[[1]][9, 3])
            ##         deleteSlider(10)
            ##     }
            ## }
            ## ##################################
            ## ## End of woraround part1
            ## ##################################

            ## create a ggroup for the slider at the specified
            ## pos in the glayout
            tbl <- ctrlGp$children[[1]]
            tbl[pos, 1:5, expand = TRUE] <- (hzGrp <- ggroup(fill = "x"))

            sliderGrp <- ggroup(horizontal = FALSE)

            ## build the level names that are used for the slider
            grpData <- GUI$getActiveData()[dropdata][[1]]
            grpData <- iNZightPlots:::convert.to.factor(grpData)
            if (pos == 6)
                lev <- c("_MULTI", levels(grpData))
            else
                lev <- c("_ALL", levels(grpData), "_MULTI")
            lev <- factor(lev, levels = lev)
            slider <- gslider(from = lev,
                              value = 1)
            add(sliderGrp, slider, expand = FALSE)
            if (pos == 6)
                grp = "g1"
            else
                grp = "g2"
            ## update the plot settings whenever the slider changes
            addHandlerChanged(slider, handler = function(h, ...) {
                              changePlotSettings(
                                  structure(list(
                                      as.character(svalue(h$obj))),
                                            .Names = paste(
                                                grp,
                                                "level",
                                                sep = ".")
                                            )
                                  )
                          })
            lbl <- levels(grpData)
            ## if the level names are too long, replace them with nr
            if (sum(nchar(lbl)) > 42)
                lbl <- 1:length(lbl)
            ## add * or _ to beginning of labels
            if (pos == 6)
                lbl <- c("_MULTI", lbl)
            else
                lbl <- c("_ALL", lbl, "_MULTI")
            ## only add label if it is short enough
            ## if (sum(nchar(lbl)) + 3 * length(lbl) < 50)
            ##    add(sliderGrp, glabel(paste(lbl, collapse = "   ")))

            ## Play button
            PLAY <- function(data) {
                playButton$levi <<- playButton$levi + 1
                if (playButton$levi > playButton$Nlev) {
                    playButton$playtimer$stop_timer()
                    changePlotSettings(data)
                    playBtn$set_value(img.playicon)
                    playButton$playtimer <<- NULL
                } else {
                    changePlotSettings(structure(list(playButton$levi),
                                                 .Names = paste(grp, "level", sep = ".")))
                }
            }
            clickPlay <- function(h, ...) {
                if (!is.null(playButton$playtimer)) {
                    ## time is running - so stop the animation
                    playButton$playtimer$stop_timer()
                    changePlotSettings(playButton$oldSet)
                    playBtn$set_value(img.playicon)
                    playButton$playtimer <<- NULL
                    return()
                }
                oldSet <- GUI$getActiveDoc()$getSettings()
                playBtn$set_value(img.stopicon)
                playButton <<- list(playtimer = NULL,
                                    Nlev = length(levels(grpData)),
                                    levi = 0, oldSet = oldSet)
                PLAY(oldSet)
                playButton$playtimer <<- gtimer(playdelay * 1000, PLAY, data = oldSet, one.shot = FALSE)
            }
            img.playicon <- system.file("images/icon-play.png", package = "iNZight")
            img.stopicon <- system.file("images/icon-stop.png", package = "iNZight")
            playBtn <- gimagebutton(filename = img.playicon, size = "button", handler = clickPlay)
            add(hzGrp, sliderGrp, expand = TRUE)
            

            ## Play time delay - time in milliseconds
            img.clockicon <- system.file("images/icon-clock.png", package = "iNZight")
            delayBtn <- gimagebutton(filename = img.clockicon, size = "button",
                                     handler = function(h, ...) {
                                         w <- gwindow(title = "Play Settings", width = 200, height = 80,
                                                      parent = GUI$win)
                                         g <- gvbox(spacing = 10, container = w)
                                         g$set_borderwidth(10)

                                         g1 <- ggroup(container = g)
                                         glabel("Time delay between plots :", container = g1)
                                         spin <- gspinbutton(from = 0.1, to = 3, by = 0.1, value = playdelay, container = g1)
                                         glabel("(seconds)", container = g1)

                                         g2 <- ggroup(container = g)
                                         addSpring(g2)
                                         gbutton("OK", container = g, handler = function(h, ...) {
                                                     playdelay <<- svalue(spin)
                                                     dispose(w)
                                                 })
                                     })
            delaySpin <- gspinbutton(from = 0.1, to = 3, by = 0.1, value = playdelay,
                                     handler = function(h, ...) playdelay <<- svalue(h$obj))

            ## Add things to layout:
            tbl[pos, 6, anchor = c(0, 0), expand = FALSE] <- delayBtn
            tbl[pos, 7, anchor = c(0, 0), expand = FALSE] <- playBtn
            
            
            ## ##################################
            ## ## start of workaround part2
            ## ##################################
            ## if (exists("g2Data")) {
            ##     createSlider(10, g2Data)
            ## }
            ## ##################################
            ## ## end of workaround part2
            ## ##################################
        },
        deleteSlider = function(pos) {
            ## get the child that is at the specified positions
            childPos <- which(sapply(ctrlGp$children[[1]]$child_positions,
                                     function(x) x$x == pos))
            while(length(childPos) > 0) {
                ##childPos <- names(ctrlGp$children[[1]]$child_positions)[[childPos]]
                ## delete all the current children of sliderGrp
                try({
                    ctrlGp$children[[1]]$remove_child(
                        ctrlGp$children[[1]]$child_positions[[childPos[1]]]$child)
                    childPos <- which(sapply(ctrlGp$children[[1]]$child_positions,
                                             function(x) x$x == pos))
                }, silent = TRUE)
            }
        },
        ## reset the widget to its original state
        ## (same as triggering all 4 clear buttons)
        resetWidget = function() {
            invisible(sapply(c(1,3,5,7), function(x) {
                ctrlGp$children[[1]][x, 7]$invoke_change_handler()
            }))
        })
    )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZDataModWin.R"
## --------------------------------------------
## The super class for the data modification window
## When a new data modification window is opened,
## a current one is closed if it exists
## List:
## iNZconToCatWin: Convert variables to a categorical type
## iNZtrnsWin: transform variables using various functions
## iNZcllpsWin: collapse multiple factor levels into one
## iNZrenameWin: rename factor levels
## iNZreorderWi: reorder factor levels
## iNZcmbCatWin: combine categorical variables
## iNZcrteVarWin: create new variables using an expression
## iNZfrmIntWin: form class intervals for a numeric variable
## iNZrnmVarWin: rename variables. This overwrites the old variable name, i.e. does not create a new variable
## iNZstdVarWin: standardise variables
## iNZdeleteVarWin: delete variables
## iNZmissCatWin: Missing as Cat
## iNZrankNumWin: Rank the numerical variables X (vector, matrix)
## iNZctocatmulWin: Convert multiple variables to categorical type in the same time
## -------------------------------------------
iNZDataModWin <- setRefClass(
    "iNZDataModWin",
    fields = list(
        GUI = "ANY"
        ),
    methods = list(
        initialize = function(gui = NULL) {
            initFields(GUI = gui)
            usingMethods(insertData)
            if (!is.null(GUI)) {
               try(dispose(GUI$modWin), silent = TRUE) ## close any current mod windows
               GUI$modWin <<- gwindow(parent = GUI$win,
                                      visible = FALSE)
            }
        },
        ## insert a column with a certain name at specified index
        ## success msg is optional
        insertData = function(data, name, index, msg = NULL, closeAfter = TRUE) {
                ## insert the new variable in the column after the old variable
                ## or at the end if the old variable is the last column in the
                ## data
                if (index != length(names(GUI$getActiveData()))) {
                    newData <- data.frame(
                        GUI$getActiveData()[, 1:index],
                        data,
                        GUI$getActiveData()[, (index+1):ncol(GUI$getActiveData())]
                        )
                    newNames <- c(
                        names(GUI$getActiveData())[1:index],
                        name,
                        names(GUI$getActiveData())[(index+1):ncol(GUI$getActiveData())]
                        )
                    newNames <- make.names(newNames, unique = TRUE)
                    names(newData) <- newNames
                } else {
                    newData <- data.frame(GUI$getActiveData(), data)
                    names(newData) <- make.names(c(names(GUI$getActiveData()),
                                                   name), unique = TRUE)
                }

                if (!is.null(msg))
                    do.call(gmessage, msg)

                GUI$getActiveDoc()$getModel()$updateData(newData)
                if (closeAfter)
                    dispose(GUI$modWin)
        })
    )

## Convert variables to a categorical type
iNZconToCatWin <- setRefClass(
    "iNZconToCatWin",
    contains = "iNZDataModWin",
    fields = list(
        varData = "ANY" ## data that is dragged into droptarget
        ),
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Convert to Categorical"
            size(GUI$modWin) <<- c(200, 250)
            mainGroup <- ggroup(horizontal = FALSE)
            mainGroup$set_borderwidth(15)
            lbl1 <- glabel("1. Drag and drop a variable name onto the\nlabel below  to create a categorical version\nof that variable")
            font(lbl1) <- list(weight="bold", family = "normal")
            dropLbl <- glabel("DROP VARIABLE HERE")
            font(dropLbl) <- list(size = 14)
            lbl2 <- glabel("2. Type name for the new variable: ")
            font(lbl2) <- list(weight="bold", family = "normal")
            name.txt <- gedit("N/A", width = 20)
            okButton <- gbutton("Update Data",
                                handler = function(h, ...) {
                                    convert(svalue(name.txt), svalue(dropLbl))
                                })
            font(okButton) = list(weight="bold", family = "normal")
            tbl <- glayout(container = mainGroup)
            tbl[1, 1, expand = TRUE, anchor = c(-1, 0)] <- lbl1
            tbl[2, 1] <- gseparator()
            tbl[3, 1] <- dropLbl
            tbl[4, 1] <- gseparator()
            tbl[5, 1, expand = TRUE, anchor = c(-1, 0)] <- lbl2
            tbl[6, 1] <- name.txt
            tbl[7, 1] <- okButton
            addDropTarget(dropLbl,
                          handler = function(h, ...) {
                              dropData <- GUI$getActiveDoc()$getData()[h$dropdata][[1]]
                              if (all(is.factor(dropData)))
                                  gmessage("Already a categorical variable!",
                                           parent = GUI$win)
                              else {
                                  svalue(h$obj) <- h$dropdata
                                  svalue(name.txt) <- paste(h$dropdata, ".cat",
                                                            sep = "")
                                  varData <<- dropData
                              }
                          })
            add(mainGroup, tbl)
            add(GUI$modWin, mainGroup, expand = TRUE)
            visible(GUI$modWin) <<- TRUE
        },
        ## convert the variable with name 'orgVar' to a factor
        ## with name 'name' and insert into data
        convert = function(name, orgVar) {
            if (name == "" || !is.character(name))
                gmessage("Please choose a non-empty name for the new variable")
            else {
                out <- as.factor(varData)
                name <- gsub('\\n+', "", name, perl = TRUE)
                index <- which(names(GUI$getActiveData()) == orgVar)

                insertData(out, name, index, closeAfter = FALSE)
            }
        })
    )

## transform variables using various functions
iNZtrnsWin <- setRefClass(
    "iNZtrnsWin",
    contains = "iNZDataModWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            ## need to specify the methods that we want to use in
            ## do.call later on
            usingMethods(trnsfrm, sqr, recip)
            svalue(GUI$modWin) <<- "Transform Variables"
            mainGroup <- ggroup(horizontal = FALSE)
            mainGroup$set_borderwidth(15)
            lbl1 <- glabel("Drag and drop variable names onto the labels below\nto create new transformed variables")
            font(lbl1) <- list(weight="bold", family = "normal", size = 11)
            lnLbl <- glabel("LOG (e)")
            font(lnLbl) <- list(weight="bold", family = "normal",
                                size = 14, color = "navy")
            logLbl <- glabel("LOG (10)")
            font(logLbl) <- list(weight="bold", family = "normal",
                                 size = 14, color = "navy")
            expLbl <- glabel("EXPONENTIAL")
            font(expLbl) <- list(weight="bold", family = "normal",
                                 size = 14, color = "navy")
            sqrLbl <- glabel("SQUARE")
            font(sqrLbl) <- list(weight="bold", family = "normal",
                                 size = 14, color = "navy")
            rootLbl <- glabel("SQUARE ROOT")
            font(rootLbl) <- list(weight="bold", family = "normal",
                                  size = 14, color = "navy")
            recLbl <- glabel("RECIPROCAL")
            font(recLbl) <- list(weight="bold", family = "normal",
                                 size = 14, color = "navy")
            addTransformation(lnLbl, "log", "log.e")
            addTransformation(logLbl, "log10", "log.10")
            addTransformation(expLbl, "exp", "exp")
            addTransformation(sqrLbl, "sqr", "sqr")
            addTransformation(rootLbl, "sqrt", "root")
            addTransformation(recLbl, "recip", "recip")

            tbl <- glayout(container = mainGroup)
            tbl[1, 1, expand = TRUE, anchor = c(-1, 0)] <- lbl1
            tbl[2, 1] <- gseparator()
            tbl[3, 1, expand = TRUE, anchor = c(0, 0)] <- lnLbl
            tbl[4, 1, expand = TRUE, anchor = c(0, 0)] <- logLbl
            tbl[5, 1, expand = TRUE, anchor = c(0, 0)] <- expLbl
            tbl[6, 1, expand = TRUE, anchor = c(0, 0)] <- sqrLbl
            tbl[7, 1, expand = TRUE, anchor = c(0, 0)] <- rootLbl
            tbl[8, 1, expand = TRUE, anchor = c(0, 0)] <- recLbl
            add(mainGroup, tbl)
            add(GUI$modWin, mainGroup, expand = TRUE)
            visible(GUI$modWin) <<- TRUE
        },
        ## check whether the data is illegible for transformation
        checkData = function(varData) {
            if (all(is.factor(varData))) {
                gmessage(title = "ERROR",
                         msg = "Categorical variables cannot be transformed",
                         parent = GUI$modWin)
                FALSE
            } else
                TRUE
        },
        ## add a drop target to a transformation field
        ## obj: the glabel object to be used as dropTarget
        ## fn: the function used for transformation
        ## nameAdd: the string that is pasted on to the var name
        addTransformation = function(obj, fn, nameAdd) {
            addDropTarget(obj, handler = function(h, ...) {
                dropData <- GUI$getActiveDoc()$getData()[h$dropdata][[1]]
                ## check whether we can transform this variable
                if (checkData(dropData)) {
                    trnsform <- do.call(trnsfrm, list(varData = dropData,
                                                      varName = h$dropdata,
                                                      trnsFn = fn,
                                                      trnsName = nameAdd))
                    do.call(insertData, modifyList(trnsform, list(
                        index = which(names(GUI$getActiveData()) == h$dropdata),
                        closeAfter = FALSE))
                            )
                }
            })
        },
        ## transform a vector and its name
        ## varData: the vector to be transformed
        ## varName: the original name of the column
        ## trnsFn: the function used for transformation
        ## trnsName: the string added on to the varName
        trnsfrm = function(varData, varName, trnsFn, trnsName) {
            out <- round(do.call(trnsFn, list(varData)), 3)
            name <- paste(trnsName, ".", varName, sep = "")
            list(data = out, name = name)
        },
        sqr = function(x) {
            x^2
        },
        recip = function(x) {
            1/x
        })
    )

## collapse multiple factor levels into one
iNZcllpsWin <- setRefClass(
    "iNZcllpsWin",
    contains = "iNZDataModWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Collapse Levels"
            size(GUI$modWin) <<- c(100, 100)
            mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
            mainGroup$set_borderwidth(15)
            ## instructions through glabels
            lbl1 <- glabel("Choose a variable")
            font(lbl1) <- list(weight = "bold",
                               family = "normal")
            lbl2 <- glabel("Choose two or more levels")
            font(lbl2) <- list(weight = "bold",
                               family = "normal")
            lbl3 <- glabel("(Hold Ctrl to choose many)")
            font(lbl3) <- list(weight = "bold",
                               family = "normal")
            ## choose a factor column from the dataset and display
            ## its level in a gtable
            factorIndices <- sapply(GUI$getActiveData(), is.factor)
            factorMenu <- gcombobox(names(GUI$getActiveData())[factorIndices],
                                    selected = 0)
            addHandlerChanged(factorMenu, handler = function(h, ...) {
                factorLvls[] <- levels(GUI$getActiveData()[svalue(factorMenu)][[1]])
            })
            factorLvls <- gtable("", multiple = TRUE, expand = TRUE)
            names(factorLvls) <- "Levels"
            cllpsButton <- gbutton(
                " - COLLAPSE -",
                handler = function(h, ...) {
                    if (checkLevels(svalue(factorLvls))) {
                        cnf <- gconfirm(
                            parent = GUI$modWin,
                            msg = paste("Collapse the levels\n",
                                paste(svalue(factorLvls), collapse = " + "),
                                "\ninto one level with the name\n'",
                                paste(svalue(factorLvls), collapse = "_"),
                                "'?")
                            )
                        if (cnf) {
                            insertData(
                                data = collapse(GUI$getActiveData()[
                                    svalue(factorMenu)][[1]],
                                    svalue(factorLvls)),
                                name = paste(
                                    svalue(factorMenu),
                                    ".coll", sep = ""),
                                index = which(names(
                                    GUI$getActiveData()) == svalue(factorMenu)),
                                closeAfter = TRUE)
                        }
                    }
                })
            add(mainGroup, lbl1)
            add(mainGroup, factorMenu)
            add(mainGroup, lbl2)
            add(mainGroup, lbl3)
            add(mainGroup, factorLvls, expand = TRUE)
            add(mainGroup, cllpsButton)
            add(GUI$modWin, mainGroup, expand = TRUE, fill = TRUE)
            visible(GUI$modWin) <<- TRUE
        },
        ## check whether the specified levels are illegible
        ## for collapsing
        checkLevels = function(levels) {
            if (is.null(levels) || length(levels) < 2) {
                gmessage(title = "ALERT",
                         icon = "warning",
                         msg = "Need to select at least two levels to collapse",
                         parent = GUI$modWin)
                FALSE
            } else
                TRUE
        },
        ## collapse two or more levels into one, return the new factor
        ## varData: the original vector
        ## levels: the levels to collapse
        collapse = function(varData, levels) {
            newLevel <- paste(levels, collapse = "_")
            newFactor <- as.character(varData)
            newFactor[varData %in% levels] <- newLevel
            newFactor <- as.factor(newFactor)
            newFactor
        })
    )

## rename factor levels
iNZrenameWin <- setRefClass(
    "iNZrenameWin",
    contains = "iNZDataModWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Rename Factor Levels"
            size(GUI$modWin) <<- c(600, 200)
            ## ggroup does not automatically add scrollbars and gWidget2 does not
            ## have a function to do so. We therefore wrap around the RGtk2 class
            ## gtkScrolledWindow around the ggroup
            scrolledWindow <- gtkScrolledWindow()
            ## setting this will only display a scrollbar if necessary
            scrolledWindow$setPolicy("GTK_POLICY_AUTOMATIC","GTK_POLICY_AUTOMATIC")
            mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
            mainGroup$set_borderwidth(15)
            ## instructions through glabels
            lbl1 <- glabel("Variable to rename:")
            font(lbl1) <- list(weight = "bold",
                               family = "normal")
            lbl2 <- glabel("Name of the new variable:")
            font(lbl2) <- list(weight = "bold",
                               family = "normal")
            ## choose a factor column from the dataset and display
            ## its levels together with their order
            factorIndices <- sapply(GUI$getActiveData(), is.factor)
            factorMenu <- gcombobox(names(GUI$getActiveData())[factorIndices],
                                    selected = 0)
            addHandlerChanged(factorMenu, handler = function(h, ...) {
                svalue(factorName) <- paste(svalue(factorMenu),
                                            ".rename", sep = "")
                displayLevels(tbl,
                              GUI$getActiveData()[svalue(factorMenu)][[1]])
            })
            factorName <- gedit("")
            renameButton <- gbutton("-RENAME-", handler = function(h, ...) {
                newFactor <- changeLevels(
                    tbl,
                    GUI$getActiveData()[svalue(factorMenu)][[1]])
                ## newFactor will be FALSE, if the user input was wrong
                if (newFactor)
                    insertData(data = newFactor,
                               name = svalue(factorName),
                               index = which(names(
                                   GUI$getActiveData()) == svalue(factorMenu)),
                               msg = list(
                                   msg = paste("The new factor can be found under the name '",
                                       svalue(factorName), "'", sep = ""),
                                   icon = "info"),
                               closeAfter = FALSE
                               )
            })
            tbl <- glayout()
            tbl[1, 1, expand = TRUE, anchor = c(-1, 0)] <- lbl1
            tbl[1, 2, expand = TRUE, anchor = c(1, 0)] <- factorMenu
            tbl[2, 1:2, expand = TRUE, anchor = c(-1, 0)] <- lbl2
            tbl[3, 1:2, expand = TRUE] <- factorName
            add(mainGroup, tbl, expand = TRUE)
            add(mainGroup, renameButton)
            ## method of gtkScrolledWindow to add a GtkWidget (not a gWidgets2 class)
            ## as a child using a viewport
            scrolledWindow$addWithViewport(mainGroup$widget)
            add(GUI$modWin, scrolledWindow, expand = TRUE, fill = TRUE)
            visible(GUI$modWin) <<- TRUE
        },
        displayLevels = function(tbl, factorData) {
            ## try to delete currently displayed levels
            ## the first 4 children of tbl refer to the permanent ones
            ## i.e. everything up to and including the gedit to rename
            ## the factor
            if (length(tbl$children) > 4) {
                try(invisible(
                    sapply(tbl$children[5:length(tbl$children)],
                           tbl$remove_child)))
            }

            lbl3 <- glabel("Levels")
            font(lbl3) <- list(weight = "bold",
                               family = "normal")
            lbl4 <- glabel("Order")
            font(lbl4) <- list(weight = "bold",
                               family = "normal")
            tbl[4, 1, expand = TRUE, anchor = c(-1, 0)] <- lbl3
            tbl[4, 2, expand = TRUE, anchor = c(-1, 0)] <- lbl4
            invisible(sapply(levels(factorData), function(x) {
                pos <- which(levels(factorData) == x)
                tbl[4 + pos, 1, expand = TRUE, anchor = c(-1, 0)] <- glabel(x)
                tbl[4 + pos, 2] <- gedit(x)
            }))
        },
        changeLevels = function(tbl, factorData) {
            if (length(tbl$children) < 5) {
                gmessage(msg = "Please choose a factor to reorder",
                         icon = "error",
                         parent = GUI$modWin)
                return(FALSE)
            }
            ## the first 4 children dont refer to the factor levels
            ## each factor lvl has 2 entries in the glayout
            ## the 5th entry refers to the glabels "Levels" and "Order"
            nrLevels <- (length(tbl$children) - 4)/2 - 1
            facLevels <- sapply(tbl[5:(5+nrLevels-1), 1], svalue)
            newFacLevels <- sapply(tbl[5:(5+nrLevels-1), 2], svalue)
            names(facLevels) <- newFacLevels
            ## check if all order numbers are unique
            if (anyDuplicated(newFacLevels) > 0) {
                gmessage(msg = "Please choose unique names for the levels",
                         icon = "error",
                         parent = GUI$modWin)
                FALSE
            }
            else {
                levels(factorData) <- as.list(facLevels)
                factorData
            }
        },
        sortByFreq = function(tbl, factorData) {
            tb <- table(factorData)
            tb <- names(tb[order(tb, decreasing = TRUE)])
            newOrder <- sapply(levels(factorData),
                               function(x) which(x == tb))
            invisible(sapply(1:length(tb),
                             function(i) svalue(tbl[4 + i, 2]) <- newOrder[i]))
        })
    )

## reorder factor levels
iNZreorderWin <- setRefClass(
    "iNZreorderWin",
    contains = "iNZDataModWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Reorder Factor Levels"
            ## ggroup does not automatically add scrollbars and gWidget2 does not
            ## have a function to do so. We therefore wrap the RGtk2 class
            ## gtkScrolledWindow around the ggroup
            scrolledWindow <- gtkScrolledWindow()
            ## setting this will only display a scrollbar if necessary
            scrolledWindow$setPolicy("GTK_POLICY_AUTOMATIC","GTK_POLICY_AUTOMATIC")
            
            mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
            mainGroup$set_borderwidth(15)
            ## instructions through glabels
            lbl1 <- glabel("Variable to reorder:")
            font(lbl1) <- list(weight = "bold",
                               family = "normal")
            lbl2 <- glabel("Name of the new variable:")
            font(lbl2) <- list(weight = "bold",
                               family = "normal")
            ## choose a factor column from the dataset and display
            ## its levels together with their order
            factorIndices <- sapply(GUI$getActiveData(), is.factor)
            factorMenu <- gcombobox(names(GUI$getActiveData())[factorIndices],
                                    selected = 0)
            addHandlerChanged(factorMenu, handler = function(h, ...) {
                svalue(factorName) <- paste(svalue(factorMenu),
                                            ".reord", sep = "")
                displayLevels(tbl,
                              GUI$getActiveData()[svalue(factorMenu)][[1]])
                ## block the handlers before changing the sortby dropdown
                ## because the signal order is messed up, which causes
                ## the wrong signal to be emitted first
                blockHandlers(sortMenu)
                svalue(sortMenu, index = TRUE) <- 1
                unblockHandlers(sortMenu)
            })
            factorName <- gedit("")
            reorderButton <- gbutton("-REORDER-", handler = function(h, ...) {
                newFactor <- changeLevels(
                    tbl,
                    GUI$getActiveData()[svalue(factorMenu)][[1]])
                ## newFactor will be FALSE, if the user input was wrong
                #if (all(newFactor != FALSE))
                    insertData(data = newFactor,
                               name = svalue(factorName),
                               index = which(names(
                                   GUI$getActiveData()) == svalue(factorMenu)),
                               msg = list(
                                   msg = paste("The new factor can be found under the name '",
                                       svalue(factorName), "'", sep = ""),
                                   icon = "info"),
                               closeAfter = FALSE
                               )
            })
            tbl <- glayout()
            tbl[1, 1, expand = TRUE, anchor = c(-1, 0)] <- lbl1
            tbl[1, 2, expand = TRUE, anchor = c(1, 0)] <- factorMenu
            tbl[2, 1:2, expand = TRUE, anchor = c(-1, 0)] <- lbl2
            tbl[3, 1:2, expand = TRUE] <- factorName
            sortGrp <- ggroup()
            sortLbl <- glabel("Sort by:", cont = sortGrp, expand = TRUE)
            sortMenu <- gcombobox(c("Manual", "Frequency"),
                                  selected = 1, cont = sortGrp, expand = TRUE)
            addHandlerChanged(sortMenu, handler = function(h, ...) {
                if (length(tbl$children) > 4) {
                    if (svalue(sortMenu, index = TRUE) == 2) {
                        sortByFreq(tbl,
                                   GUI$getActiveData()[svalue(factorMenu)][[1]])
                    }
                }
            })
            add(mainGroup, tbl, expand = TRUE)
            add(mainGroup, sortGrp)
            add(mainGroup, reorderButton)
            ## method of gtkScrolledWindow to add a GtkWidget (not a gWidgets2 class)
            ## as a child using a viewport
            scrolledWindow$addWithViewport(mainGroup$widget)
            add(GUI$modWin, scrolledWindow, expand = TRUE, fill = TRUE)
            visible(GUI$modWin) <<- TRUE
        },
        displayLevels = function(tbl, factorData) {
            ## try to delete currently displayed levels
            ## the first 4 children of tbl refer to the permanent ones
            ## i.e. everything up to and including the gedit to rename
            ## the factor
            if (length(tbl$children) > 4) {
                childEntries <- which(sapply(
                    tbl$child_positions, function(child) child$x) > 4)
                try(invisible(
                    sapply(tbl$child_positions[childEntries],
                           function(entry) tbl$remove_child(entry$child)))
                    )
            }

            lbl3 <- glabel("Levels")
            font(lbl3) <- list(weight = "bold",
                               family = "normal")
            lbl4 <- glabel("Order")
            font(lbl4) <- list(weight = "bold",
                               family = "normal")
            tbl[4, 1, expand = TRUE, anchor = c(-1, 0)] <- lbl3
            tbl[4, 2, expand = TRUE, anchor = c(-1, 0)] <- lbl4
            invisible(sapply(levels(factorData), function(x) {
                pos <- which(levels(factorData) == x)
                tbl[4 + pos, 1, expand = TRUE, anchor = c(-1, 0)] <- glabel(x)
                tbl[4 + pos, 2] <- gedit(pos)
            }))
        },
        changeLevels = function(tbl, factorData) {
            if (length(tbl$children) < 5) {
                return(gmessage(msg = "Please choose a factor to reorder",
                         icon = "error",
                         parent = GUI$modWin))
                
            }
            ## the first 4 children dont refer to the factor levels
            ## each factor lvl has 2 entries in the glayout
            ## the 5th entry refers to the glabels "Levels" and "Order"
            childEntries <- which(sapply(
                tbl$child_positions, function(child) child$x) > 4)
            ## gWidets2 reorders the children of glayout in some weird way,
            ## so we find the order by x value, then y value (i.e. as entries
            ## tbl[4,1], tbl[4,2], tbl[5,2], ...)
            origOrder <- order(
                sapply(tbl$child_positions[childEntries], function(child) child$x),
                sapply(tbl$child_positions[childEntries], function(child) child$y))
            facLevels <- sapply(
                tbl$child_positions[childEntries][origOrder[seq(
                    1, length(origOrder), by = 2)]],
                function(child) svalue(child$child))
            facOrder <- sapply(
                tbl$child_positions[childEntries][origOrder[seq(
                    2, length(origOrder), by = 2)]],
                function(child) svalue(child$child))
            facOrder <- as.integer(facOrder)
            facOrder <- sapply(1:length(facLevels), function(x) which(facOrder == x))
            ## check if all order numbers are unique
            if (anyDuplicated(facOrder) > 0) {
                return(gmessage(msg = "Please choose a unique order for the levels",
                         icon = "error",
                         parent = GUI$modWin))
                
            }
            else if (max(facOrder) > length(facOrder)) {
                return(gmessage(msg = "Please remove holes from the order sequence",
                         icon = "error",
                         parent = GUI$modWin))
                
            }
            else {
                newFactor <- factor(factorData, levels = facLevels[facOrder])
                newFactor
            }
        },
        sortByFreq = function(tbl, factorData) {
            tb <- table(factorData)
            tb <- names(tb[order(tb, decreasing = TRUE)])
            newOrder <- sapply(levels(factorData),
                               function(x) which(x == tb))
            invisible(
                sapply(
                    1:length(newOrder),
                    function(i) {
                        xEntries <- sapply(tbl$child_positions,
                                           function(entry) entry$x) == (4 + i)
                        yEntries <- sapply(tbl$child_positions[xEntries],
                                           function(entry) entry$y) == 2
                        svalue(tbl$child_positions[[which(
                            xEntries)[yEntries]]]$child) <- newOrder[i]
                    }
                    ))
        })
    )


## combine categorical variables
iNZcmbCatWin <- setRefClass(
    "iNZcmbCatWin",
    contains = "iNZDataModWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Combine Categorical Variables"
            size(GUI$modWin) <<- c(250, 450)
            mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
            mainGroup$set_borderwidth(15)
            ## instructions through glabels
            lbl1 <- glabel("Choose a variables you want to combine")
            font(lbl1) <- list(weight = "bold",
                               family = "normal")
            lbl2 <- glabel("(Hold Ctrl to choose many)")
            font(lbl2) <- list(weight = "bold",
                               family = "normal")
            lbl3 <- glabel("New Variable Name")
            font(lbl3) <- list(weight = "bold",
                               family = "normal")
            ## choose a factor column from the dataset and display
            ## its level in a gtable
            factorIndices <- sapply(GUI$getActiveData(), is.factor)
            factorNames <- gtable(names(GUI$getActiveData())[factorIndices],
                                  multiple = TRUE, expand = TRUE)
            names(factorNames) <- "Categorical Variables"
            newName <- gedit()
            ## automatically fill the name field when variables are selected
            addHandlerSelectionChanged(factorNames, handler = function(h, ...) {
                if (length(svalue(factorNames)) > 0)
                    svalue(newName) <- paste(svalue(factorNames), collapse = ".")
            })
            cmbButton <- gbutton(
                " - COMBINE-",
                handler = function(h, ...) {
                    if (checkSelection(svalue(factorNames),
                                       svalue(newName))) {
                        cnf <- gconfirm(
                            parent = GUI$modWin,
                            msg = paste("Combine the variables\n",
                                paste(svalue(factorNames), collapse = " + "),
                                "\ninto one variable with the name\n'",
                                svalue(newName),
                                "'?", sep = "")
                            )
                        if (cnf) {
                            insertData(
                                data = combine(svalue(factorNames)),
                                name = svalue(newName),
                                index = ncol(GUI$getActiveData()),
                                msg = list(
                                    msg = "The new factor was added to the end of the data",
                                    icon = "info",
                                    parent = GUI$modWin
                                    ),
                                closeAfter = TRUE)
                        }
                    }
                })
            add(mainGroup, lbl1)
            add(mainGroup, lbl2)
            add(mainGroup, factorNames, expand = TRUE)
            add(mainGroup, lbl3)
            add(mainGroup, newName)
            add(mainGroup, cmbButton)
            add(GUI$modWin, mainGroup, expand = TRUE, fill = TRUE)
            visible(GUI$modWin) <<- TRUE
        },
        ## check whether the specified variables are illegible
        ## for combining
        checkSelection = function(levels, name) {
            if (is.null(levels) || length(levels) < 2) {
                gmessage(title = "ALERT",
                         icon = "warning",
                         msg = "Need to select at least two variables to combine",
                         parent = GUI$modWin)
                FALSE
            } else if (length(name) == 0) {
                gmessage(title = "ALERT",
                         icon = "warning",
                         msg = "Please specify a non-empty name for the new variable",
                         parent = GUI$modWin)
                FALSE
            } else
                TRUE
        },
        ## combine two or more factors into one, return the new factor
        ## facNames: the original factor names
        combine = function(facNames) {
            factor(do.call(mapply, c(as.list(GUI$getActiveData()[facNames]),
                                    FUN = paste, sep = ".")))
        })
    )

## create new variables using an expression
iNZcrteVarWin <- setRefClass(
    "iNZcrteVarWin",
    contains = "iNZDataModWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Create New Variables"
            size(GUI$modWin) <<- c(450, 200)
            mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
            mainGroup$set_borderwidth(15)
            lbl1 = glabel("Type in an expression to compute a new variable")
            font(lbl1) <- list(weight="bold", family = "normal")
            lbl2 = glabel("EXAMPLES")
            font(lbl2) <- list(weight="bold", family = "normal")
            newVarName = gedit("new.variable", width = 15) ## name of the new variable
            newVarExp = gedit("  ") ## expression used to create new var
            submitButton = gbutton(" - SUBMIT -", handler = function(h,...) {
                dataSet <- GUI$getActiveData()
                newValues = try(eval(parse(
                    text = paste("with(dataSet,",
                        gsub(pattern = '\\n+', "", svalue(newVarExp), perl = TRUE),
                        ")"))))
                if(class(newValues)[1] == "try-error")
                    gmessage(title = "ERROR",
                             msg = "Error in expression!",
                             icon = "error", parent = GUI$modWin)
                else {
                    newName = gsub(
                        pattern = '\\n+', "",
                        svalue(newVarName), perl = TRUE)
                    insertData(
                        data = newValues,
                        name = newName,
                        index = ncol(GUI$getActiveData()),
                        msg = list(
                            msg = paste("The new variable",
                                newName,
                                "will be inserted as the last column of the dataset"),
                            icon = "info",
                            parent = GUI$modWin
                            ),
                        closeAfter = TRUE)
                }
            })
            tbl <- glayout()
            tbl[1,2, anchor = c(-1,1)] = "av.height"
            tbl[1,3, anchor = c(-1,1)] = " = "
            tbl[1,4, anchor = c(-1,1), expand = TRUE] = "(m.height + f.height)/2"
            tbl[2,2, anchor = c(-1,1)] = "wgt.diff"
            tbl[2,3, anchor = c(-1,1)] = " = "
            tbl[2,4, anchor = c(-1,1), expand = TRUE] = "wgt.After - wgt.Before"
            tbl[4,2,anchor = c(-1,1)] = newVarName
            tbl[4,3,anchor = c(-1,1)] = " = "
            tbl[4,4, expand = TRUE, anchor = c(-1,1)] = newVarExp
            add(mainGroup, lbl1)
            add(mainGroup, lbl2)
            add(mainGroup, tbl)
            add(mainGroup, submitButton)
            add(GUI$modWin, mainGroup, expand = TRUE, fill = TRUE)
            visible(GUI$modWin) <<- TRUE
        })
    )


## form class intervals for a numeric variable
iNZfrmIntWin <- setRefClass(
    "iNZfrmIntWin",
    contains = "iNZDataModWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Form Class Intervals"
            size(GUI$modWin) <<- c(400, 400)
            mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
            mainGroup$set_borderwidth(15)
            lbl1 = glabel("Choose variable :")
            font(lbl1) = list(weight = "bold", style = "normal")
            lbl2 = glabel("New variable    :")
            font(lbl2) = list(weight = "bold", style = "normal")
            lbl3 = glabel("New level names :")
            font(lbl3) = list(weight = "bold", style = "normal")
            lbl4 = glabel("Method :")
            font(lbl4) = list(weight = "bold", style = "normal")
            lbl5 = glabel("Number of intervals :")
            font(lbl5) = list(weight = "bold", style = "normal")
            newVarName = gedit("")
            ## choose a numeric column from the dataset
            numIndices <- sapply(GUI$getActiveData(), function(x) !is.factor(x))
            NumericListMenu = gcombobox(names(GUI$getActiveData())[numIndices],
                selected = 0, handler = function(h,...) {
                    svalue(newVarName) = paste(svalue(h$obj),"f", sep = ".")
                })
            binSlider = gslider(from = 2, to = 20, by = 1)
            levelNameChoices = gradio(c("(open left, closed right]", "[closed left, open right)"),
                horizontal = FALSE, selected = 1)
            binningChoices = gradio(c("Equal width intervals",
                "Equal count intervals", "Specified intervals"),
                horizontal = FALSE, selected = 1)
            proceedButton <- gbutton("- Proceed -", handler = function(h, ...) {
                 
              bins <- svalue(binSlider)
              levelLabels <- TRUE
              if (svalue(levelNameChoices) == "[closed left, open right)")
                levelLabels <- FALSE
              
              dataSet <- GUI$getActiveData()
              VarValues <- dataSet[, svalue(NumericListMenu)] 
              if (svalue(binningChoices) == "Equal width intervals")
                newVarValues <- try(cut(VarValues, bins, 
                                        right = levelLabels, include.lowest = TRUE))
              else if (svalue(binningChoices) == "Equal count intervals")
                newVarValues <- try(cut(VarValues, 
                                        quantile(VarValues, probs=seq(0,1,1/bins),na.rm=TRUE), 
                                        include.lowest = TRUE,
                                        right = levelLabels))
              
              else if(svalue(binningChoices) == "Specified intervals"){
                bins <- bins # due to the R lazy evaluation, I active them here.
                VarValues = VarValues
                newVarName = newVarName
                dataSet = dataSet
                levelLabels = levelLabels
                e1 <- environment()
                e1$open <- TRUE
                opt(bins = bins, VarValues = VarValues, 
                    newVarName = newVarName,
                    dataSet = dataSet,
                    levelLabels = levelLabels,
                    env = e1)  # assign the value into opt() environment
                  return()
                
              }
              ####%%%%%%%%%%%%%
              if(class(newVarValues)[1] == "try-error")
                gmessage(title = "ERROR",
                         msg = "Error in cutting intervals!",
                         icon = "error", parent = GUI$modWin)
              else {
                newName = gsub(
                  pattern = '\\n+', "",
                  svalue(newVarName), perl = TRUE)
                insertData(
                  data = newVarValues,
                  name = newName,
                  index = ncol(GUI$getActiveData()),
                  msg = list(
                    msg = paste("The new variable",
                                newName,
                                "will be inserted as the last column of the dataset"),
                    icon = "info",
                    parent = GUI$modWin
                  ),
                  closeAfter = TRUE)
              }
            })
            tbl <- glayout()
            tbl[1, 1] <- lbl1
            tbl[1, 2] <- NumericListMenu
            tbl[2, 1] <- lbl2
            tbl[2, 2] <- newVarName
            tbl[3, 1] <- lbl5
            tbl[4, 1:2] <- binSlider
            tbl[5, 1] <- lbl3
            tbl[5, 2] <- lbl4
            tbl[6, 1] <- levelNameChoices
            tbl[6, 2] <- binningChoices
            tbl[7, 2] <- proceedButton
            add(mainGroup, tbl)
            add(GUI$modWin, mainGroup, expand = TRUE, fill = TRUE)
            visible(GUI$modWin) <<- TRUE
        }, 
        opt = function(bins, VarValues, newVarName, levelLabels, dataSet, env) {
          # windows for "Specified intervals"
          textboxList =  list()
          breaksNeeded = bins - 1
          
          newVarName # because R is lazy eval, we need to activate here first.
          env # because R is lazy eval, we need to activate here first.
          newBreaks = glayout()
          
          parentmodeWin <- GUI$modWin  # copy the previouos mod windows before we create a new one.
          
          GUI$modWin <<- gwindow("User Intervals", 
                                 parent = GUI$win, width = 150, height = 200)
          #addhandlerunrealize(levelNamesWin, handler = function(h,...){dispose(levelNamesWin)})
          breaksMain = ggroup(horizontal = FALSE, cont = GUI$modWin)
          
          
          lbl1 = glabel(paste("Specified", bins, "intervals.\nNeed", breaksNeeded, "break points"))
          font(lbl1) = list(weight = "bold", style = "normal")
          
          add(breaksMain, lbl1)
          newBreaks[1,2] = glabel(as.character(min(VarValues, na.rm = TRUE)))
          
          
          for(i in 1:breaksNeeded){                                                     #,",width = 60, height = 20 )"
            eval(parse(text=paste(c("textboxList$","lbl",i, "= gtext(\"","\"",",width = 80, height = 20)"), collapse="")))
            newBreaks[i+1,2] = eval(parse(text = paste(c("textboxList$","lbl",i), collapse="")))
          }
          
          
          newBreaks[breaksNeeded+2,2] = glabel(as.character(max(VarValues, na.rm = TRUE)))
          
          
          visible(newBreaks) = TRUE
          add(breaksMain, newBreaks)
          
          out <- NULL
          finalButton = gbutton("Submit Breaks", handler = function(h,...){
            
            cutOffPoints = numeric(0)
            for(i in 1:breaksNeeded)
              cutOffPoints= c(cutOffPoints, gsub(pattern = '\\n+', replacement = "", x = svalue(textboxList[[i]]), perl = TRUE))
            
            
            cutOffPoints = c(min(VarValues, na.rm = TRUE), 
                             gsub(pattern = '\\s+', replacement = "", x = cutOffPoints, perl = TRUE), 
                             max(VarValues, na.rm = TRUE))
            
            x <- NULL
            if(any(cutOffPoints %in% c("", " ", "", "   ", "\n", "\n\n")))
              gmessage(title = "ERROR", message = "Fill in all text boxes", icon = "error", parent = GUI$modWin)
            else if(length(unique(cutOffPoints[c(-1,-length(cutOffPoints))])) != length(cutOffPoints)-2)
              gmessage(title = "ERROR", message = "Breaks must be unique values.", icon = "error", parent = GUI$modWin)
            else{
              
              x <- TRUE
              newVarValues = try(cut(VarValues, cutOffPoints, include.lowest = TRUE, right = levelLabels))
              if(class(newVarValues)[1] == "try-error")
                gmessage(title = "ERROR",
                         msg = "Error in cutting intervals!",
                         icon = "error", parent = GUI$modWin)
              else {
                newName = gsub(
                  pattern = '\\n+', "",
                  svalue(newVarName), perl = TRUE)
                insertData(
                  data = as.factor(newVarValues),
                  name = newName,
                  index = ncol(GUI$getActiveData()),
                  msg = list(
                    msg = paste("The new variable",
                                newName,
                                "will be inserted as the last column of the dataset"),
                    icon = "info",
                    parent = GUI$modWin
                  ),
                  closeAfter = TRUE)
              }
              
            }
            dispose(parentmodeWin)
          }
          )
          add(breaksMain, finalButton)
          
        }
    )    
)




## rename variables. This overwrites the old variable name, i.e. does not
## create a new variable
iNZrnmVarWin <- setRefClass(
    "iNZrnmVarWin",
    contains = "iNZDataModWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Rename Variables"
            size(GUI$modWin) <<- c(600, 200)
            ## ggroup does not automatically add scrollbars and gWidget2 does not
            ## have a function to do so. We therefore wrap the RGtk2 class
            ## gtkScrolledWindow around the ggroup
            scrolledWindow <- gtkScrolledWindow()
            ## setting this will only display a scrollbar if necessary
            scrolledWindow$setPolicy("GTK_POLICY_AUTOMATIC","GTK_POLICY_AUTOMATIC")
            mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
            mainGroup$set_borderwidth(15)
            lbl1 <- glabel("Old Variables")
            lbl2 <- glabel("New Variables")
            oldNames <- names(GUI$getActiveData())
            tbl <- glayout()
            tbl[1, 1, expand = TRUE, anchor = c(-1, -1)] <- lbl1
            tbl[1, 2, expand = TRUE, anchor = c(-1, -1)] <- lbl2
            invisible(sapply(1:length(oldNames), function(pos) {
                tbl[1 + pos, 1] <- glabel(oldNames[pos])
                tbl[1 + pos, 2] <- gedit(oldNames[pos])
            }))
            renameButton <- gbutton('- RENAME -',
                                    handler = function(h, ...) {
                newNames <- sapply(tbl[, 2], svalue)
                GUI$getActiveDoc()$getModel()$setNames(newNames[-1])
                dispose(GUI$modWin)
            })
            add(mainGroup, tbl)
            add(mainGroup, renameButton)
            ## method of gtkScrolledWindow to add a GtkWidget (not a gWidgets2 class)
            ## as a child using a viewport
            scrolledWindow$addWithViewport(mainGroup$widget)
            add(GUI$modWin, scrolledWindow, expand = TRUE, fill = TRUE)
            visible(GUI$modWin) <<- TRUE
        })
    )

## standardise variables
iNZstdVarWin <- setRefClass(
    "iNZstdVarWin",
    contains = "iNZDataModWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Standardise Variables"
            size(GUI$modWin) <<- c(250, 450)
            mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
            mainGroup$set_borderwidth(15)
            ## instructions through glabels
            lbl1 <- glabel("Choose a variables you want to standardise")
            font(lbl1) <- list(weight = "bold",
                               family = "normal")
            lbl2 <- glabel("(Hold Ctrl to choose many)")
            font(lbl2) <- list(weight = "bold",
                               family = "normal")
            ## display only numeric variables
            numIndices <- sapply(GUI$getActiveData(), function(x) !is.factor(x))
            numVar <- gtable(names(GUI$getActiveData())[numIndices],
                             multiple = TRUE)
            names(numVar) <- "Variables"
            stdButton <- gbutton("Standardise", handler = function(h, ...) {
                if (length(svalue(numVar)) > 0) {
                    index <- which(numIndices)[svalue(numVar, index = TRUE)]
                    newVar <- scale(GUI$getActiveData()[, index],
                                    center = TRUE, scale = TRUE)
                    newNames <- paste(names(GUI$getActiveData())[index],
                                      ".std", sep = "")
                    insertData(data = newVar,
                               name = newNames,
                               index = ncol(GUI$getActiveData()),
                               msg = list(
                                   msg = "The new variables are added to the end of the dataset",
                                   icon = "info"
                                   ),
                               closeAfter = TRUE)
                }
            })
            add(mainGroup, lbl1)
            add(mainGroup, lbl2)
            add(mainGroup, numVar, expand = TRUE)
            add(mainGroup, stdButton)
            add(GUI$modWin, mainGroup, expand = TRUE, fill = TRUE)
            visible(GUI$modWin) <<- TRUE
        })
    )

## delete variables
iNZdeleteVarWin <- setRefClass(
    "iNZdeleteVarWin",
    contains = "iNZDataModWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Delete Variables"
            mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
            mainGroup$set_borderwidth(15)
            ## instructions through glabels
            lbl1 = glabel("Select Variables to delete")
            font(lbl1) <- list(weight="bold", family = "normal")
            lbl2 = glabel("(Hold Ctrl to choose many)")
            font(lbl2) <- list(weight="bold", family = "normal")
            listOfVars = gtable(names(GUI$getActiveData()),
                multiple = TRUE, expand = TRUE)
            names(listOfVars) = "Variables"
            deleteButton = gbutton(
                "- Delete -",
                handler = function(h,...) {
                    if (length(svalue(listOfVars)) > 0) {
                        confirmDel <- gconfirm(
                            title = "Are you sure?",
                            msg = paste(
                                "Do you want to delete the",
                                "following variables:\n",
                                paste(svalue(listOfVars),
                                      collapse = "\n")
                                ),
                            icon = "question")
                        if (confirmDel) {
                            dataSet <- GUI$getActiveData()
                            dataSet <- dataSet[, !(names(dataSet) %in%
                                                   svalue(listOfVars)),
                                               drop = FALSE]
                            GUI$getActiveDoc()$getModel()$updateData(dataSet)
                            dispose(GUI$modWin)
                        }
                    }
            })
            add(mainGroup, lbl1)
            add(mainGroup, lbl2)
            add(mainGroup, listOfVars, expand = TRUE)
            add(mainGroup, deleteButton)
            add(GUI$modWin, mainGroup, expand = TRUE, fill = TRUE)
            visible(GUI$modWin) <<- TRUE
        })
    )

## Missing as Cat
iNZmissCatWin <- setRefClass(
    "iNZmissCatWin",
    contains = "iNZDataModWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Missing as Categorical"
            mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
            mainGroup$set_borderwidth(15)
            ## instructions through glabels
            lbl1 = glabel("Select Variables to be transformed\nResulting Variables will be categorical with a level for missing observations")
            font(lbl1) <- list(weight="bold", family = "normal")
            lbl2 = glabel("(Hold Ctrl to choose many)")
            font(lbl2) <- list(weight="bold", family = "normal")
            listOfVars = gtable(names(GUI$getActiveData()),
                multiple = TRUE, expand = TRUE)
            names(listOfVars) = "Variables"
            convertButton = gbutton(
                "- Convert -",
                handler = function(h,...) {
                    if (length(svalue(listOfVars)) > 0) {
                        dataToConvert <- GUI$getActiveData()[, svalue(listOfVars,
                                                                      index = TRUE),
                                                             drop = FALSE]
                        facIndices <- sapply(dataToConvert, is.factor)
                        ## replace NA with 'missing' and 'observed' otherwise
                        ## for non-factors
                        dataToConvert[, !facIndices][!is.na(
                            dataToConvert)[, !facIndices]] <- "observed"
                        dataToConvert[,!facIndices][is.na(
                            dataToConvert)[, !facIndices]] <- "missing"

                        ## replace NA with 'missing' for factors
                        dataToConvert[, facIndices] <- sapply(
                            dataToConvert[, facIndices],
                            function(x) {
                                levels(x) <- c(levels(x), "missing")
                                x[is.na(x)] <- "missing"
                                x
                            })
                        ## convert non-factors to factors
                        dataToConvert[, !facIndices] <- do.call(
                            cbind.data.frame,
                            lapply(dataToConvert[, !facIndices, drop = FALSE],
                                   factor))

                        newNames <- paste(names(
                            GUI$getActiveData())[svalue(listOfVars, index = TRUE)],
                                          "_miss", sep = "")
                        insertData(data = dataToConvert,
                                   name = newNames,
                                   index = ncol(GUI$getActiveData()),
                                   msg = list(
                                       msg = "The new variables are added to the end of the dataset",
                                       icon = "info"
                                       ),
                                   closeAfter = TRUE)
                    }
                })
            add(mainGroup, lbl1)
            add(mainGroup, lbl2)
            add(mainGroup, listOfVars, expand = TRUE)
            add(mainGroup, convertButton)
            add(GUI$modWin, mainGroup, expand = TRUE, fill = TRUE)
            visible(GUI$modWin) <<- TRUE
        })
    )


# iNZrankNumWin: Rank the numerical variables X (vector, matrix)
iNZrankNumWin <- setRefClass(
  "iNZrankNumWin",
  contains = "iNZDataModWin",
  methods = list(
    initialize = function(gui) {
      callSuper(gui)
      svalue(GUI$modWin) <<- "Ranking Variables"
      size(GUI$modWin) <<- c(250, 450)
      mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
      mainGroup$set_borderwidth(15)
      ## instructions through glabels
      lbl1 <- glabel("Rank the numerical variables X (vector, matrix)")
      font(lbl1) <- list(weight = "bold",
                         family = "normal")
      lbl2 <- glabel("(Hold Ctrl to choose many)")
      font(lbl2) <- list(weight = "bold",
                         family = "normal")
      ## display only numeric variables
      numIndices <- sapply(GUI$getActiveData(), function(x) !is.factor(x))
      numVar <- gtable(names(GUI$getActiveData())[numIndices],
                       multiple = TRUE)
      names(numVar) <- "Variables"
      rankButton <- gbutton("Rank", handler = function(h, ...) {
        if (length(svalue(numVar)) > 0) {
          index <- which(numIndices)[svalue(numVar, index = TRUE)]
          data <- GUI$getActiveData()[, index]
          if (length(index)>1){
          newVar <- sapply(data, rank, ties.method = "min", na.last = "keep")
          }
          else 
            newVar <- rank(data, ties.method = "min", na.last = "keep")
          
          newNames <- paste(names(GUI$getActiveData())[index],
                            ".rank", sep = "")
          
          insertData(data = newVar,
                     name = newNames,
                     index = ncol(GUI$getActiveData()),
                     msg = list(
                       msg = "The new variables are added to the end of the dataset",
                       icon = "info"
                     ),
                     closeAfter = TRUE)        
        }
        else {
          gmessage("Select at leat one variable!",
                   parent = GUI$win)
        }
      })
      add(mainGroup, lbl1)
      add(mainGroup, lbl2)
      add(mainGroup, numVar, expand = TRUE)
      add(mainGroup, rankButton)
      add(GUI$modWin, mainGroup, expand = TRUE, fill = TRUE)
      visible(GUI$modWin) <<- TRUE
    })
)

## Convert multiple variables to categorical type in the same time
iNZctocatmulWin <- setRefClass(
  "iNZctocatmulWin",
  contains = "iNZDataModWin",
  methods = list(
    initialize = function(gui) {
      callSuper(gui)
      svalue(GUI$modWin) <<- "Convert multiple Variables to categorical type"
      size(GUI$modWin) <<- c(250, 450)
      mainGroup <- ggroup(expand = TRUE, horizontal = FALSE)
      mainGroup$set_borderwidth(15)
      ## instructions through glabels
      lbl1 <- glabel("Choose variables you want to convert")
      font(lbl1) <- list(weight = "bold",
                         family = "normal")
      lbl2 <- glabel("(Hold Ctrl to choose many)")
      font(lbl2) <- list(weight = "bold",
                         family = "normal")
      ## display only numeric variables
      numIndices <- sapply(GUI$getActiveData(), function(x) !is.factor(x))
      numVar <- gtable(names(GUI$getActiveData())[numIndices],
                       multiple = TRUE)
      names(numVar) <- "Variables"
      ctmcButton <- gbutton("Convert", handler = function(h, ...) {
        if (length(svalue(numVar)) > 0) {
          index <- which(numIndices)[svalue(numVar, index = TRUE)]
          
          if (length(index) > 1)
            newData <- sapply(GUI$getActiveData()[, index], as.factor)
          else
            newData <- as.factor(GUI$getActiveData()[, index])
          newNames <- paste(names(GUI$getActiveData())[index],
                            ".cat", sep = "")
          insertData(data = newData,
                     name = newNames,
                     index = ncol(GUI$getActiveData()),
                     msg = list(
                       msg = "The new variables are added to the end of the dataset",
                       icon = "info"
                     ),
                     closeAfter = TRUE)
        }
      })
      add(mainGroup, lbl1)
      add(mainGroup, lbl2)
      add(mainGroup, numVar, expand = TRUE)
      add(mainGroup, ctmcButton)
      add(GUI$modWin, mainGroup, expand = TRUE, fill = TRUE)
      visible(GUI$modWin) <<- TRUE
    })
)
#line 1 "/Users/tom/iNZight/iNZight/R/iNZDataViewWidget.R"
iNZDataViewWidget <- setRefClass(
    "iNZDataViewWidget",
    fields = list(
        GUI = "ANY", ## the iNZight GUI object
        dataGp = "ANY", ## group containing the 2 different view groups
        dfView = "ANY", ## group that contains data view
        varView = "ANY", ## group that contains variable view
        ## max size before dataview gets deactived
        dataThreshold = "numeric"
        ),
    methods = list(
        initialize = function(gui, dataThreshold) {
            initFields(GUI = gui,
                       dataThreshold = dataThreshold)
            dataGp <<- ggroup(horizontal = TRUE, expand = TRUE)
            dataSet <- GUI$getActiveData()
            ## create the data.frame view
            createDfView()
            ## create the variable view
            createVarView()
            ## start in dataView if size is less than 200k
            if (nrow(dataSet) * ncol(dataSet) <= dataThreshold)
                visible(dfView) <<- TRUE
            else
                visible(varView) <<- TRUE
        },
        ## recreate both views with active dataset
        updateWidget = function() {
            view <- visible(dfView)
            ## delete the currently displayed views
            try(invisible(sapply(dataGp$children,
                                 function(x) delete(dataGp, x))),
                silent = TRUE)
            ## create the data.frame view
            createDfView()
            ## create the variable view
            createVarView()
            dataSet <- GUI$getActiveData()
            if(!view || (nrow(dataSet) * ncol(dataSet) > dataThreshold))
                visible(varView) <<- TRUE
            else
                visible(dfView) <<- TRUE

        },
        ## only update the variable view
        updateVarView = function() {
            view <- visible(varView)
            createVarView()
            visible(varView) <<- view
        },
        ## only update the data.frame view
        updateDfView = function() {
            view <- visible(dfView)
            createDfView()
            visible(dfView) <<- view
        },
        ## create the data.frame view (invisible)
        createDfView = function() {
            dataSet <- GUI$getActiveData()
            dfView <<- ggroup(container = dataGp, expand = TRUE)
            
            ## only create the gdf if the dataset is small enough
            if (nrow(dataSet) * ncol(dataSet) <= dataThreshold) {
                visible(dfView) <<- FALSE
                dfWidget <- gdf(dataSet, expand = TRUE)
                ## dfWidget$remove_popup_menu() ## - called by $add_dnd_columns()
                assign("Obj", dfWidget, envir = .GlobalEnv)
                dfWidget$add_dnd_columns()
                add(dfView, dfWidget, expand = TRUE)
                ## if the data.frame gets edited, update the iNZDocument
                addHandlerChanged(
                    dfWidget,
                    handler = function(h, ...) {
                        X1 <- dfWidget[]
                        if(class(X1) != "data.frame")
                            newData <- data.frame(X1)
                        GUI$getActiveDoc()$getModel()$updateData(X1)})
            } else {
                visible(dfView) <<- FALSE
            }
        },
        ## create variable view (invisible)
        createVarView = function() {
            dataSet <- GUI$getActiveData()
            varView <<- ggroup(container = dataGp, expand = TRUE)
            visible(varView) <<- FALSE
            ## if more than 19 columns are in the dataSet, split the variable
            ## view into 2 tables
            N <- 19

            ## prefix variable type to variable names
            vnames <- names(dataSet)
            ## These are explicitely removes by `gsub` in the addDropSource handler below
            vtypes <- ifelse(sapply(dataSet, is.numeric), "(n)", "(c)")

            vnames <- paste(vtypes, vnames)
                        
            # if(length(names(dataSet)) > N && length(names(dataSet)) < 80) {
            if(length(dataSet) < 100000 && length(names(dataSet)) > 80) {
                varWidget <- list(
                    gtable(vnames[1:floor(N/2)], expand = TRUE),
                    gtable(vnames[(floor(N/2)+1):ncol(dataSet)],
                           expand = TRUE))
                names(varWidget[[1]]) <- "VARIABLES"
                names(varWidget[[2]]) <- "...CONTINUED"
            } else {
                varWidget <- list(gtable(vnames, expand = TRUE))
                names(varWidget[[1]]) <- "VARIABLES (n = numeric, c = categorical)"
            }
            ## use the variable view as dropsource and add to data group
            invisible(lapply(varWidget, function(x) {
                add(varView, x, expand = TRUE)
                x$remove_popup_menu()
                addDropSource(x, handler = function(h, ...) {
                    ## Remove the variable type from the tag (otherwise `variable doesn't exist`)
                    gsub("\\([cn]\\) ", "", svalue(h$obj))  # matches '(c) ' and '(n) '
                })}))
        },
        ## change the currently active View
        changeView = function() {
            if(visible(dfView)) {
                visible(dfView) <<- FALSE
                visible(varView) <<- TRUE
            } else {
                visible(varView) <<- FALSE
                visible(dfView) <<- TRUE
            }
        },
        ## set view to data.frame view
        dataView = function() {
            visible(varView) <<- FALSE
            visible(dfView) <<- TRUE
        },
        ## set view to list of columns
        listView = function() {
            visible(dfView) <<- FALSE
            visible(varView) <<- TRUE
        })
    )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZDocument.R"
iNZDataModel <- setRefClass(
    "iNZDataModel",
    properties(fields = list(
                   dataSet = "ANY",
                   origDataSet = "ANY",
                   rowDataSet = "ANY",
                   dataDesign = "ANY"),
               prototype = list(
                   dataSet = data.frame(empty = " "),
                   origDataSet = data.frame(empty = " "),
                   rowDataSet = data.frame(Row.names = 1, empty = " "),
                   dataDesign = NULL)),
    contains = "PropertySet", ## need this to add observer to object
    methods = list(
        initialize = function(data = NULL) {
            if(!is.null(data)) {
                .self$setData(data)
            }
        },
        setData = function(data) {
            names(data) <- make.names(names(data), unique = TRUE)
            dataSet <<- data
            origDataSet <<- data
            rowData <- data.frame(Row.names = 1:nrow(data), data,
                                  check.names = TRUE)
            rowDataSet <<- rowData
        },
        updateData = function(data) {
            dataSet <<- data
        },
        setNames = function(newNames) {
            newNames <- make.names(newNames, unique = TRUE)
            names(dataSet) <<- newNames
        },
        getData = function() {
            dataSet
        },
        getRowData = function() {
            rowDataSet
        },
        addDataObserver = function(FUN, ...) {
            .self$dataSetChanged$connect(FUN, ...)
        },
        addObjObserver = function(FUN, ...) {
            .self$changed$connect(FUN, ...)
        },
        setDesign = function(strata=NULL, clus1=NULL, clus2=NULL,
                             wt=NULL, nest=NULL, fpc=NULL, gui, ...) {
            if (is.null(strata) & is.null(clus1) & is.null(clus2) &
                is.null(wt) & is.null(nest) & is.null(fpc)) {
                dataDesign <<- NULL
            } else {
                dataDesign <<- list(strata = strata,
                                    clus1  = clus1,
                                    clus2  = clus2,
                                    wt     = wt,
                                    fpc    = fpc,
                                    nest   = nest)
            }
        },
        createSurveyObject = function() {
            des <- getDesign()

            id <- if (is.null(des$clus1) & is.null(des$clus2)) {
                "~ 1"
            } else if (is.null(des$clus1)) {
                paste("~", des$clus2)
            } else if (is.null(des$clus2)) {
                paste("~", des$clus1)
            } else {
                paste("~", des$clus1, "+", des$clus2)
            }

            strata <- if (is.null(des$strata)) "NULL" else paste("~", des$strata)
            weights <- if (is.null(des$wt)) "NULL" else paste("~", des$wt)
            fpcs <- if (is.null(des$fpc)) "NULL" else paste("~", des$fpc)

            obj <-
                parse(text =
                      paste0(
                          "svydesign(",
                          "id = ", id, ", ",
                          "strata = ", strata, ", ",
                          "weights = ", weights, ", ",
                          "fpc = ", fpcs, ", ",
                          "nest = ", des$nest, ", ",
                          "data = dataSet)"
                          )
                      )
            eval(obj)
        },
        getDesign = function() {
            dataDesign
        }
        )
    )

iNZPlotSettings <- setRefClass(
    "iNZPlotSettings",
    properties(fields = list(
                   settings = "list",
                   defaultSettings = "list"),
               prototype = list(
                   settings = list(),
                   defaultSettings = list())),
    contains = "PropertySet", ## need this to add observer to object
    methods = list(
        initialize = function(settings = NULL) {
            if(!is.null(settings))
                settings <<- settings
            else
                settings <<- unclass(iNZightPlots:::inzpar())
            defaultSettings <<- unclass(iNZightPlots:::inzpar())
        },
        getSettings = function() {
            settings
        },
        ## change the plot settings
        ## reset: if TRUE, the default plot settings are loaded
        ##        for the additions to the plot
        setSettings = function(setList, reset = FALSE) {
            if (reset)
                setList <- modifyList(setList,
                                      defaultSettings,
                                      keep.null = TRUE)
            settings <<- modifyList(settings, setList,
                                    keep.null = TRUE)
            defaultSettings <<- modifyList(
                defaultSettings,
                extractDefaults(settings),
                keep.null = TRUE)
        },
        ## reset the plot settings (except the data fields)
        resetSettings = function() {
            setSettings(unclass(iNZightPlots:::inzpar()))
        },
        ## extract a sub-list of a settings list
        ## than can be used to merge with defaultSettings
        extractDefaults = function(theSettings) {
            defaultFields <- c("cex", "bg", "col.pt", "col.pt", "cex.pt", "cex.dotpt",
                               "alpha", "fill.pt", "pch", "internal.labels")
            theSettings[defaultFields]
        },
        addSettingsObserver = function(FUN, ...) {
            .self$settingsChanged$connect(FUN, ...)
        },
        addObjObserver = function(FUN, ...) {
            .self$changed$connect(FUN, ...)
        })
    )

iNZDocument <- setRefClass(
    "iNZDocument",
    fields = list(
        dataModel = "iNZDataModel",
        plotSettings = "iNZPlotSettings"
        ),
    methods = list(
        initialize = function(data=NULL, settings=NULL) {
            initFields(dataModel = iNZDataModel$new(data),
                       plotSettings = iNZPlotSettings$new(settings))
        },
        getModel = function() {
            dataModel
        },
        getPlotSettings = function() {
            plotSettings
        },
        getData = function() {
            dataModel$getData()
        },
        getSettings = function() {
            plotSettings$getSettings()
        },
        getRowData = function() {
            dataModel$getRowData()
        },
        setSettings = function(setList, reset = FALSE) {
            plotSettings$setSettings(setList, reset)
        },
        ## update the settings to take in current x,y values
        ## from the dataset
        updateSettings = function() {
            settings <- plotSettings$settings
            if (!is.null(settings$x) && !is.null(settings$varnames$x)) {
                settings$x <- getData()[[settings$varnames$x]]
            }
            if (!is.null(settings$y) && !is.null(settings$varnames$y)) {
                settings$y <- getData()[[settings$varnames$y]]
            }
            setSettings(settings)
        },
        addDataObserver = function(FUN, ...) {
            dataModel$addDataObserver(FUN, ...)
        },
        addSettingsObserver = function(FUN, ...) {
            plotSettings$addSettingsObserver(FUN, ...)
        },
        addDataObjObserver = function(FUN, ...) {
            dataModel$addObjObserver(FUN, ...)
        },
        addSettingsObjObserver = function(FUN, ...) {
            plotSettings$addObjObserver(FUN, ...)
        }
        )
    )


iNZDataNameWidget <- setRefClass(
    "iNZDataNameWidget",
    fields = list(
        GUI = "ANY",  ## the iNZight GUI object
        datName = "ANY", ## the string for the data set name
        nameLabel = "ANY"
        ),
    methods = list(
        initialize = function(gui) {
            initFields(GUI = gui,
                       datName = "No data loaded")
            nameLabel <<- glabel(.self$datName)
        },
        updateWidget = function() {
            dataSet <- GUI$getActiveData()

            if(is.null(dataSet)){
                datName <<- "No data loaded"
            } else {
                if((names(dataSet)[1] == "empty"))
                    datName <<- "No data loaded"
                else {
                    datName <<- attr(dataSet, "name", exact = TRUE)
                }
            }

            svalue(nameLabel) <<- .self$datName
        }
        )
    )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZGUI.R"
#' iNZight GUI Class
#'
#' Main class that builds the iNZight GUI
#' @field iNZDocuments A list of documents containing data, plot settings, etc.
#' @field activeDoc The numeric ID of the currently active document
#' @import methods utils grDevices colorspace
#' @export iNZGUI
#' @exportClass iNZGUI
iNZGUI <- setRefClass(
    "iNZGUI",
    properties(fields = list(
                   ## list of iNZDocuments (contain data, plotSettings)
                   iNZDocuments = "list",
                   ## the active document of the iNZDocuments list
                   activeDoc = "numeric",
                   ## the main GUI window
                   win = "ANY",
                   menubar = "ANY",

                   ## left group
                   leftMain = "ANY",
                   moduleWindow = "ANY",
                   activeModule = "ANY",
                   gp1 = "ANY",
                   ## middle group
                   gp2 = "ANY",

                   ## the Widget containing the 2 data views
                   dataViewWidget = "ANY",
                   ## the widget handling the switching between the
                   ## 2 data views
                   viewSwitcherWidget = "ANY",
                   dataNameWidget = "ANY",
                   ## widget that handles the plot notebook
                   plotWidget = "ANY",
                   plotToolbar = "ANY",
                   ## widget that handles the drag/drop buttons
                   ## under the dataViewWidget
                   ctrlWidget = "ANY",
                   ## Save the summary and inference buttons to allow disabling
                   sumBtn = "ANY",
                   infBtn = "ANY",
                   ## every window that modifies plot/data
                   ## this way we can ensure to only have one
                   ## open at the time
                   modWin = "ANY",
                   ## the current plot and its type (scatter, dot, etc...)
                   curPlot = "ANY",
                   plotType = "ANY",
                   OS = "character",
                   prefs.location = "character",
                   preferences = "list"
                   ),
               prototype = list(
                   activeDoc = 1,
                   plotType = "none"
                   )
               ),
    methods = list(
        ## Start the iNZight GUI
        ##   data: data.frame, starts the gui with data already in it
        ##   disposerR: logical, if true R session is closed upon
        ##              closing the gui
        ## This is the main method of iNZight and calls all the other
        ## methods of the GUI class.
        initializeGui = function(data = NULL, disposeR = FALSE) {
            "Initiates the GUI"
            iNZDocuments <<- list(iNZDocument$new(data = data))
            win.title <- paste("iNZight (v",
                               packageDescription("iNZight")$Version,
                               ")", sep = "")

            OS <<- if (.Platform$OS == "windows") "windows" else if (Sys.info()["sysname"] == "Darwin") "mac" else "linux"

            ## We must set the correct directory correctly ...
            switch(OS,
                   "windows" = {
                       done <- FALSE
                       if (file.exists(file.path("~", "iNZightVIT"))) {
                           setwd(file.path("~", "iNZightVIT"))

                           ## Now check to see if there is a library in there ...
                           if (!file.exists("modules"))
                               dir.create("modules")
                       } else {
                           ## Create it:
                           conf <- gconfirm(paste("Do you want to create an iNZightVIT directory",
                                                  "in your My Documents folder to save data and preferences?"),
                                            title = "Create Folder", icon = "question")
                           
                           if (conf) {
                               if ( dir.create(file.path("~", "iNZightVIT")) ) {
                                   ## copy the Data folder:
                                   ##try(file.copy("Data.lnk", file.path("~", "iNZightVIT")), TRUE)
                                   ##try(file.symlink("data", file.path("~", "iNZightVIT")), TRUE)
                                   
                                   ##setwd(file.path("~", "iNZightVIT"))

                                   dir.create(file.path("~", "iNZightVIT", "modules"))
                                   
                                   done <- TRUE
                               }

                               if (!done)
                                   gmessage("iNZight was unable to create the folder.")
                           }
                       }
                       
                       ## Set the library path if it exists
                       if (file.exists(file.path("~", "iNZightVIT", "modules")))
                           .libPaths(file.path("~", "iNZightVIT", "modules"))
                   },
                   "mac" = {
                       done <- FALSE
                       if (file.exists(file.path("~", "Documents", "iNZightVIT"))) {
                           setwd(file.path("~", "Documents", "iNZightVIT"))
                           
                           ## Now check to see if there is a library in there ...
                           if (!file.exists("modules")) 
                               modulesLib <- dir.create("modules")
                       } else {
                           ## Create it:
                           conf <- gconfirm(paste("Do you want to create an iNZightVIT directory",
                                                  "in your Documents folder to save data and preferences?"),
                                            title = "Create Folder", icon = "question")

                           if (conf) {
                               if ( dir.create(file.path("~", "Documents", "iNZightVIT")) ) {
                                   dir.create(file.path("~", "Documents", "iNZightVIT", "modules"))
                                   try(setwd(Sys.getenv("R_DIR")), TRUE)

                                   done <- TRUE
                               }

                               if (!done)
                                   gmessage("iNZight was unable to create the folder.")
                           }

                           ## Set the library path if it exists
                           if (file.exists(file.path("~", "Documents", "iNZightVIT", "modules")))
                               .libPaths(file.path("~", "DocumentS", "iNZightVIT", "modules"))

                           if (!done)
                               try(setwd(Sys.getenv("R_DIR")), TRUE)
                       }
                   },
                   "linux" = {
                       ## no need to do anything (yet..)
                   })
                

            ## Grab settings file (or try to!)
            getPreferences()

            ## Check for updates ... need to use try incase it fails (no connection etc)
            ## RCurl no longer supports R < 3, so it wont be available on Mac SL version.
            if (requireNamespace("RCurl", quietly = TRUE)) {
                connected <- RCurl::url.exists("r.docker.stat.auckland.ac.nz")
            } else connected <- FALSE

            if (connected) {
                ## DON'T ASK UNTIL DATABSE UP ONLINE
                ## if (preferences$track == "ask") {
                if (FALSE) {
                    preferences$track <<-
                        gconfirm("iNZight would like to use anonymous usage information. Are you ok for us to collect this information?",
                                 title = "Share usage information?", icon = "question")
                    savePreferences()
                }

                if (preferences$check.updates) {
                    ap <- suppressWarnings(try(numeric_version(available.packages(
                        contriburl = contrib.url("http://r.docker.stat.auckland.ac.nz/R",
                            getOption("pkgType")))[,"Version"]), TRUE))
                    if (!inherits(ap, "try-error")) {
                        if (length(ap) > 0) {
                            ip <- try(numeric_version(installed.packages()[names(ap), "Version"]), TRUE)
                            if (!inherits(ip, "try-error")) {
                                if (any(ap > ip))
                                    win.title <- paste(win.title, " [updates available]")
                            }
                        }
                    }
                }


                ## --- TURNED OFF PERMANENTLY UNTIL DATABASE BACK ONLINE                
                ## if (preferences$track) {
                if (FALSE) {
                    try({
                        version = packageVersion("iNZight")
                        os <- "Linux"
                        if (.Platform$OS == "windows") {
                            os = "Windows"
                        } else if (Sys.info()["sysname"] == "Darwin") {
                            os = "Mac OS X"
                            osx.version <- try(system("sw_vers -productVersion", intern = TRUE), silent = TRUE)
                            if (!inherits(osx.version, "try-error")) {
                                os = paste("Mac OS X", osx.version)
                            }
                        }


                        ## have they updated before?
                        if (is.null(preferences$track.id)) {
                            ## compatibility mode ---
                            hash.id <- "new"

                            if (os == "Windows") {
                                libp <- "prog_files"
                            } else if (os != "Linux") {
                                ## i.e., mac
                                libp <- "Library"
                            } else {
                                ## linux - save in library..
                                libp <- .libPaths()[which(sapply(.libPaths(), function(p)
                                                                 "iNZight" %in% list.files(p)))[1]]
                            }

                            if (file.exists(file.path(libp, "id.txt"))) {
                                hash.id <- readLines(file.path(libp, "id.txt"))
                                unlink(file.path(libp, "id.txt"))  ## delete the old one
                            }

                            ## only if not already tracking
                            if (hash.id == "new") {
                                track.url <- paste0("http://r.docker.stat.auckland.ac.nz/R/tracker/index.php?track&v=",
                                                    version, "&os=", gsub(" ", "%20", os), "&hash=", hash.id)
                                f <- try(url(track.url,  open = "r"), TRUE)

                                ## write the hash code to their installation:
                                hash.id <- readLines(f)


                                ## try(writeLines(hash.id, file.path(libp, "id.txt")), silent = TRUE)
                            }

                            preferences$track.id <<- hash.id
                            savePreferences()
                        } else {
                            hash.id <- preferences$track.id
                            try(url(paste0("http://r.docker.stat.auckland.ac.nz/R/tracker/index.php?track&v=",
                                           version, "&os=", gsub(" ", "%20", os), "&hash=", hash.id), open = "r"), TRUE)
                        }
                    })
                }
            }

            popOut <- preferences$popout

            win <<- gwindow(win.title, visible = FALSE,
                            width = if (popOut) NULL else preferences$window.size[1],
                            height = preferences$window.size[2])

            gtop <- ggroup(horizontal = FALSE, container = win,
                           use.scrollwindow = FALSE)
            menugrp <- ggroup(container = gtop)
            initializeMenu(menugrp, disposeR)
            g <- gpanedgroup(container = gtop, expand = TRUE)

            ## Left side group
            leftMain <<- ggroup(container = g, expand = FALSE)
            if (!popOut) size(leftMain) <<- c(220, -1)
            gp1 <<- gvbox(container = leftMain, expand = TRUE)

            ## Right group
            gp2 <<- ggroup(horizontal = FALSE, container = g, expand = !popOut)


            ## set up widgets in the left group

            ## set up dataViewWidget, added below
            ## dataThreshold is used as maximum nr of cells
            ## before data.frame view gets deactivated
            dataThreshold <- 200000
            initializeDataView(dataThreshold)

            ## set up buttons to switch between data/var view
            add(gp1, .self$initializeViewSwitcher(dataThreshold)$viewGroup)

            ## display the name of the data set
            add(gp1, .self$initializeDataNameWidget()$nameLabel)

            ## display the data
            add(gp1, dataViewWidget$dataGp, expand = TRUE)

            ## set up the drag and drop fields
            add(gp1, initializeControlWidget()$ctrlGp, expand = FALSE)

            ## set up the summary buttongs
            add(gp1, initializeSummaryBtns())

            ## set up widgets in the right group
            grpRight <- ggroup(horizontal = popOut,
                               container = gp2, expand = TRUE)
            ## set up plot notebook
            initializePlotWidget()
            if (!popOut) add(grpRight, plotWidget$plotNb, expand = TRUE)
            else addSpace(grpRight, 10)

            ## set up plot toolbar
            plotToolbar <<- ggroup(horizontal = !popOut, container = grpRight, spacing = 10)
            size(plotToolbar) <<- if (popOut) c(-1, -1) else c(-1, 45)
            initializePlotToolbar(plotToolbar)

            visible(win) <<- TRUE

            ## ensures that all plot control btns are visible on startup
            #svalue(g) <- 0.375
            ## first plot(empty) needs to be added after window is drawn
            ## to ensure the correct device nr
            if (popOut)
                iNZightTools::newdevice()
            else
                plotWidget$addPlot()

            ## draw the iNZight splash screen
            plotSplashScreen()
            
            ## add what is done upon closing the gui
            closerHandler(disposeR)
        },
        ## set up the menu bar widget
        initializeMenu = function(cont, disposeR) {
            actionList <- list(
                import = gaction(
                  #1
                    label = "Import Data...", icon = "symbol_diamond",
                    tooltip = "Import a new Dataset",
                    handler = function(h, ...) iNZImportWin$new(.self)
                    ),
                export = gaction(
                  #2
                    label = "Export Data...", icon = "symbol_diamond",
                    handler = function(h, ...) iNZSaveWin$new(.self,
                        type = "data",
                        data = .self$getActiveData())
                    ),
                conToCat = gaction(
                  #3
                    label = "Convert to Categorical...",
                    icon = "symbol_diamond",
                    tooltip = "Convert a variable to a categorical type",
                    handler = function(h, ...) iNZconToCatWin$new(.self)
                    ),
                trns = gaction(
                  #4
                    label = "Transform Variables...",
                    icon = "symbol_diamond",
                    tooltip = "Transform a variable using a function",
                    handler = function(h, ...) iNZtrnsWin$new(.self)
                    ),
                clps = gaction(
                  #5
                    label = "Collapse Levels...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZcllpsWin$new(.self)
                    ),
                reordLvl = gaction(
                  #6
                    label = "Reorder Levels...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZreorderWin$new(.self)
                    ),
                renmLvl = gaction(
                  #7
                    label = "Rename Levels...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZrenameWin$new(.self)
                    ),
                cmbnCat = gaction(
                  #8
                    label = "Combine Categorical Variables...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZcmbCatWin$new(.self)
                    ),
                create = gaction(
                  #9
                    label = "Create New Variables...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZcrteVarWin$new(.self)
                    ),
                ## The code for displaying this window is already there
                ## just the functionality of forming the intervals is
                ## left to be implemented
                 frmInt = gaction(
                   #10
                   label = "Form Class Intervals...",
                     icon = "symbol_diamond",
                     handler = function(h, ...) iNZfrmIntWin$new(.self)
                     ),
                renmVar = gaction(
                  #11
                    label = "Rename Variables...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZrnmVarWin$new(.self)
                    ),
                stdVar = gaction(
                  #12
                    label = "Standardize Variables...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZstdVarWin$new(.self)
                    ),
                slctCases = gaction(
                  #13
                    label = "Filter Dataset...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZFilterWin$new(.self)
                    ),
                rshpData = gaction(
                  #14
                    label = "Reshape Dataset...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZReshapeDataWin$new(.self)
                    ),
                rstrData = gaction(
                  #15
                    label = "Restore Dataset",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                      setDocument(iNZDocument$new(data = getActiveDoc()$getModel()$origDataSet))
                        #getActiveDoc()$getModel()$updateData(
                        #    getActiveDoc()$getModel()$origDataSet)
                    }
                    ),
                home = gaction(
                  #16
                    label = "iNZightVIT Home",
                    icon = "symbold_diamond",
                    handler = function(h, ...) {
                        dispose(win)
                        iNZightVIT(disposeR = disposeR)
                    }),
                tsMod = gaction(
                  #17
                    label = "Time Series...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        ##module = "iNZightTSMod"
                        ##initializeModule(module)
                        ##iNZightTSMod$new(.self)
                        ign <- gwindow("...", visible = FALSE)
                        tag(ign, "dataSet") <- getActiveData()
                        e <- list(obj = ign)
                        e$win <- win
                        iNZightModules::timeSeries(e)
                    }
                    ),
                modelFit = gaction(
                  #18
                    label = "Model Fitting...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        ign <- gwindow("...", visible = FALSE)
                        tag(ign, "dataSet") <- getActiveData()
                        e <- list(obj = ign)
                        e$win <- win
                        iNZightModules::modelFitting(e)
                    }
                    ),
                threeDPlot = gaction(
                  #19
                    label = "3D Plot...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        ign <- gwindow("...", visible = FALSE)
                        tag(ign, "dataSet") <- getActiveData()
                        e <- list(obj = ign)
                        e$win <- win
                        iNZightModules::plot3D(e)
                    }
                    ),
                scatterMatrix = gaction(
                  #20
                    label = "Pairs...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        iNZscatterMatrix$new(.self)
                    }
                    ),
                deleteVariables = gaction(
                  #21
                    label = "Delete Variables...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        iNZdeleteVarWin$new(.self)
                    }
                    ),
                allPlots = gaction(
                  #22
                    label = "All 1-variable Plots",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                       iNZallPlots$new(.self)
                    }
                    ),
                allSummaries = gaction(
                  #23
                    label = "All 1-variable Summaries",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        iNZallSummaries$new(.self)
                    }
                    ),
                exploreMissingness = gaction(
                  #24
                    label = "Missing Values",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        iNZExploreMissing$new(.self)
                    }
                    ),
                missToCat = gaction(
                  #25
                    label = "Missing to Categorical...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZmissCatWin$new(.self)
                    ),
                all2Plots = gaction(
                  #26
                    label = "Explore 2-variable Plots...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        iNZall2Plots$new(.self)
                    }
                    ),
                sortBy = gaction(
                  #27
                  label = "Sort data by variables...",
                  icon = "symbol_diamond",
                  handler = function(h, ...){
                    iNZSortbyDataWin$new(.self)
                  }
                ),
                agraData = gaction(
                  #28
                  label = "Aggregate data...",
                  icon = "symbol_diamond",
                  handler = function(h, ...){
                      iNZAgraDataWin$new(.self)
                  }
                ),
                rankNum = gaction(
                  #29
                  label = "Rank Numerical Variables...",
                  icon = "symbol_diamond",
                  handler = function(h, ...) iNZrankNumWin$new(.self)
                  ),
                convert2mc = gaction(
                  #30
                  label = "Convert to Categorial (Multiple)...",
                  icon = "symbol_diamond",
                  handler = function(h, ...) iNZctocatmulWin$new(.self)
                  ),
                stackVar = gaction(
                  #31
                    label = "Stack variables...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZstackVarWin$new(.self)
                ),
                multipleResponse = gaction(
                    ## 32
                    label = "Multiple Response...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        iNZightModules::iNZightMultiRes$new(.self)
                    }
                ),
                aboutiNZight = gaction(
                    ## 33
                    label = "About",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        w <- gwindow("About iNZight", width = 500, height = 400, visible = TRUE, parent = win)
                        g <- gvbox(expand = FALSE, cont = w, spacing = 5)
                        g$set_borderwidth(10)
                        mainlbl <- glabel("iNZight", container = g)
                        font(mainlbl) <- list(weight = "bold", family = "normal", size = 20)
                        verlbl <- glabel(paste("Version", packageDescription("iNZight")$Version), container = g)
                        font(verlbl) <- list(weight = "normal", family = "normal", size = 10)
                        addSpace(g, 10)
                        copylbl <- glabel("Copyright (C) 2014 University of Auckland", container = g)
                        font(copylbl) <- list(weight = "normal", family = "normal", size = 8)
                        addSpace(g, 15)
                        gpltxt <- gtext(expand = TRUE, cont = g, wrap = TRUE)
                        insert(gpltxt, paste("\n\nThis program is free software; you can redistribute it and/or",
                                             "modify it under the terms of the GNU General Public License",
                                             "as published by the Free Software Foundation; either version 2",
                                             "of the License, or (at your option) any later version.\n"),
                               font.attr = list(size = 9)) -> l1
                        insert(gpltxt, paste("This program is distributed in the hope that it will be useful,",
                                             "but WITHOUT ANY WARRANTY; without even the implied warranty of",
                                             "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
                                             "GNU General Public License for more details.\n"),
                               font.attr = list(size = 9)) -> l2
                        insert(gpltxt, paste("You should have received a copy of the GNU General Public License",
                                             "along with this program; if not, write to the Free Software",
                                             "Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n"),
                               font.attr = list(size = 9)) -> l3
                        insert(gpltxt, paste("You can view the full licence here:\nhttp://www.gnu.org/licenses/gpl-2.0-standalone.html"),
                               font.attr = list(size = 9)) -> l4
                        addSpace(g, 5)
                        contactlbl <- glabel("For help, contact inzight_support@stat.auckland.ac.nz", container = g)
                        font(contactlbl) <- list(weight = "normal", family = "normal", size = 8)
                        visible(w) <- TRUE
                    }
                ),
                faqPage = gaction(
                    ## 34
                    label = "FAQ",
                    icon  = "symbol_diamond",
                    handler = function(h, ...) {
                        browseURL("https://www.stat.auckland.ac.nz/~wild/iNZight/support/faq/")
                    }
                ),
                contactPage = gaction(
                    ## 35
                    label = "Contact Support/Report a Bug",
                    icon  = "symbol_diamond",
                    handler = function(h, ...) {
                        browseURL("https://www.stat.auckland.ac.nz/~wild/iNZight/support/contact/")
                    }
                ),
                prefs = gaction (
                    ## 36
                    label = "Preferences",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZPrefsWin$new(.self)
                ),
                exit = gaction(
                    ## 37
                    label = "Exit",
                    icon = "symbold_diamond",
                    handler = function(h, ...) if (disposeR) q(save = "no") else dispose(win)
                ),
                aboutiNZight = gaction(
                    ## 38
                    label = "Privacy",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        w <- gwindow("Privacy", width = 500, height = 250, visible = TRUE, parent = win)
                        g <- gvbox(expand = FALSE, cont = w, spacing = 5)
                        g$set_borderwidth(10)

                        mainlbl <- glabel("iNZight User Privacy", container = g)
                        font(mainlbl) <- list(weight = "bold", family = "normal", size = 20)

                        gpltxt <- gtext(expand = TRUE, cont = g, wrap = TRUE)
                        insert(gpltxt, paste("\n\nTo provide us with information about our users and their behaviour,",
                                             "we collect ANONYMOUS information about iNZight, such as the version number",
                                             "you are using, the operating system, and how frequently iNZight is updated.",
                                             "We collect ABSOLUTELY NO personal information from your computer. We place",
                                             "a unique cookie that allows us to identify unique users, however this is not",
                                             "in any way connected to your personal information.\n"),
                               font.attr = list(size = 9)) -> l1
                        insert(gpltxt, paste("If you wish to remain completely anonymous, then you can turn off the sharing of",
                                             "usage information by going to 'File' > 'Preferences' and deselecting the appropriate box.\n"),
                               font.attr = list(size = 9)) -> l2
                        visible(w) <- TRUE
                    }
                ),
                guideBasics = gaction(
                    ## 39
                    label = "The Basics",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        browseURL("https://www.stat.auckland.ac.nz/~wild/iNZight/user_guides/basics/")
                    }
                ),
                guideInterface = gaction(
                    ## 40
                    label = "The Interface",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        browseURL("https://www.stat.auckland.ac.nz/~wild/iNZight/user_guides/interface/")
                    }
                ),
                guidePlotOptions = gaction(
                    ## 41
                    label = "Plot Options",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        browseURL("https://www.stat.auckland.ac.nz/~wild/iNZight/user_guides/plot_options/")
                    }
                ),
                guideVariables = gaction(
                    ## 42
                    label = "Variables Menu",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        browseURL("https://www.stat.auckland.ac.nz/~wild/iNZight/user_guides/variables/")
                    }
                ),
                guideDataOptions = gaction(
                    ## 43
                    label = "Dataset Menu",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        browseURL("https://www.stat.auckland.ac.nz/~wild/iNZight/user_guides/data_options/")
                    }
                ),
                guideAdditional = gaction(
                    ## 44
                    label = "Advanced Menu",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        browseURL("https://www.stat.auckland.ac.nz/~wild/iNZight/user_guides/add_ons/")
                    }
                ),
                specifyDesign = gaction(
                    ## 45
                    label = "[BETA] Specify Survey Design ...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) iNZSurveyDesign$new(.self)
                ),
                removeDesign = gaction(
                    ## 46
                    label = "Remove Design",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        .self$getActiveDoc()$getModel()$setDesign()
                        ## ENABLE A WHOLE LOT OF STUFF
                        enabled(menubar$menu_list[["Dataset"]][[3]]) <<- TRUE
                        enabled(menubar$menu_list[["Variables"]][["Numeric Variables"]][[2]]) <<- TRUE
                        enabled(menubar$menu_list[["Plot"]][[3]]) <<- TRUE
                        enabled(sumBtn) <<- TRUE
                        enabled(infBtn) <<- TRUE
                    }
                ),
                ############ MAPS ############
                maps = gaction(
                    ## 47
                    label = "Maps...",
                    icon = "symbol_diamond",
                    handler = function(h, ...) {
                        iNZightModules::iNZightMapMod$new(.self)
                    }
                ),
                import = gaction(
                    ## 48
                    label = "Example data...", icon = "symbol_diamond",
                    tooltip = "Load Example Data",
                    handler = function(h, ...) iNZImportExampleWin$new(.self)
                )
                #####################################################
                ###  big suggestion
                ###  any new update function should be placing below to match the actionList[[number]]
                ###  so next one should be #31 and placing below.
                ###################################################
            )
            ## home button is disabled if package 'vit' is not loaded
            if (!'package:vit' %in% search())
                enabled(actionList[[16]]) <- FALSE

            ## disable modules if packages are not loaded
            if (!requireNamespace("iNZightModules", quietly = TRUE)) {
                invisible(sapply(actionList[c(19,17,18,32,47)], function(x) {
                                     enabled(x) <- FALSE}))
            }
            if (!requireNamespace("iNZightMR", quietly = TRUE))
                enabled(actionList[[24]]) <- FALSE
            menuBarList <- list(
                "File" = list(
                    actionList[[16]],
                    gseparator(),
                    actionList[[1]],
                    actionList[[2]],
                    gseparator(),
                    actionList[[48]],
                    gseparator(),
                    actionList[[36]],
                    actionList[[37]]
                    ),
                "Dataset" = list(
                    actionList[[13]],
                    actionList[[27]],
                    actionList[[28]],
                    actionList[[31]],
                    actionList[[15]],
                    gseparator(),
                    actionList[[45]],
                    actionList[[46]]
                    ),
                "Variables" = list(
                    actionList[[3]],
                    "Categorical Variables" = actionList[c(6,5,7,8)],
                    "Numeric Variables" = actionList[c(4,12,10, 29,30)],
                    actionList[[11]],
                    actionList[[9]],
                    actionList[[25]],
                    actionList[[14]],
                    actionList[[21]]
                    ),
                "Plot" = list(
                    ),
                "Advanced" = list(
                    ## This will be automated in future
                    "Quick Explore" = actionList[c(24, 22, 23, 26, 20)],
                    actionList[[19]],
                    actionList[[17]],
                    actionList[[18]],
                    actionList[[32]],
                    actionList[[47]]
                    ),
                "Help" = list(
                    actionList[[33]],
                    actionList[[38]],
                    "User Guides" = actionList[39:44],
                    actionList[[34]],
                    actionList[[35]]
                    )
                )
            
            if (!"package:vit" %in% search()) { # remove ...
                menuBarList[[1]][[2]] <- NULL  ## gseparator
                menuBarList[[1]][[1]] <- NULL  ## iNZightVIT Home
            }
            
            menubar <<- gmenu(menuBarList, container = cont)

            ## if (all(dim(.self$getActiveData()) == 1)) {
            ##     one day, get around to disabling the menu bar before data is loaded
            ## }
        },
        ## set up buttons to switch between data and variable view
        initializeViewSwitcher = function(dataThreshold) {
            viewSwitcherWidget <<- iNZViewSwitcher$new(.self, dataThreshold)
            .self$viewSwitcherWidget
        },
        ## set up the display to show the name of the data set
        initializeDataNameWidget = function() {
            ## create the widget
            dataNameWidget <<- iNZDataNameWidget$new(.self)

             ## if the list of active document changes, update the data set name
            addActDocObs(function() {
                dataNameWidget$updateWidget()
            })
            ## if the dataSet changes, update the data set name
            getActiveDoc()$addDataObserver(
                function() {
                    dataNameWidget$updateWidget()
                }
            )
            .self$dataNameWidget
        },
        ## set up the widget to display/edit the loaded dataSet
        initializeDataView = function(dataThreshold) {
            ## create the widget
            dataViewWidget <<- iNZDataViewWidget$new(.self, dataThreshold)
            ## if the list of active document changes, update the data view
            addActDocObs(function() {
                dataViewWidget$updateWidget()
                viewSwitcherWidget$updateWidget()
            })
            ## if the dataSet changes, update the variable View
            getActiveDoc()$addDataObserver(
                function() {
                    dataViewWidget$updateWidget()
                    viewSwitcherWidget$updateWidget()
                    getActiveDoc()$updateSettings()
                }
            )
            ## if the settings change, redraw the plot
            getActiveDoc()$addSettingsObjObserver(function() updatePlot())
        },
        ## set up the buttons used for drag and drop and control of
        ## the plot; they update the plotSettings
        initializeControlWidget = function() {
            ## if plotSettings change, update the plot
            getActiveDoc()$addSettingsObserver(function() updatePlot())
            ctrlWidget <<- iNZControlWidget$new(.self)

            ## if the list of active document changes, update the data view
            addActDocObs(
                function() {
                    ctrlWidget$updateVariables()
                }
            )
            ## if the dataSet changes, update the variable View
            getActiveDoc()$addDataObserver(
                function() {
                    ctrlWidget$updateVariables()
                }
            )

            .self$ctrlWidget
        },
        ## set up the summary and inference buttons under the
        ## drag and drop fields
        initializeSummaryBtns = function() {
            sumGrp <- ggroup()
            sumBtn <<- gbutton(
                "Get Summary",
                handler = function(h, ...) {
                    curSet <- getActiveDoc()$getSettings()
                    if (!is.null(curSet$x)) {
                        if (is.numeric(curSet$x) & is.numeric(curSet$y)) {
                            tmp.x <- curSet$y
                            curSet$y <- curSet$x
                            curSet$x <- tmp.x
                            v <- curSet$varnames
                            curSet$varnames$x <- v$y
                            curSet$varnames$y <- v$x
                        }

                        ## Design or data?
                        curMod <- getActiveDoc()$getModel()
                        if (!is.null(curMod$dataDesign)) {
                            curSet$data <- NULL
                            curSet$design <- curMod$createSurveyObject()
                        }

                        w <- gwindow("Summary", width = 850, height = 400,
                                     visible = FALSE, parent = win)
                        g <- gtext(text = paste(do.call(
                                       iNZightPlots:::getPlotSummary,
                                       curSet),
                                       collapse = "\n"),
                                   expand = TRUE, cont = w, wrap = FALSE,
                                   font.attr = list(family = "monospace"))
                        visible(w) <- TRUE
                    } else {
                        gmessage("Please select at least one variable",
                                 parent = win)
                    }
                })
            infBtn <<- gbutton(
                "Get Inference",
                handler = function(h, ...) {
                    curSet <- getActiveDoc()$getSettings()
                    if (!is.null(curSet$x)) {
                        if (is.numeric(curSet$x) & is.numeric(curSet$y)) {
                            tmp.x <- curSet$y
                            curSet$y <- curSet$x
                            curSet$x <- tmp.x
                            v <- curSet$varnames
                            curSet$varnames$x <- v$y
                            curSet$varnames$y <- v$x
                        }

                        ## Design or data?
                        curMod <- getActiveDoc()$getModel()
                        if (!is.null(curMod$dataDesign)) {
                            curSet$data <- NULL
                            curSet$design <- curMod$createSurveyObject()
                        }

                        w <- gwindow("Choose Method", width = 100,
                                     height = 100, parent = win)
                        g <- ggroup(cont = w, horizontal = FALSE)
                        lbl <- glabel("Choose Method to \nGenerate Inference:",
                                      cont = g)
                        rd <- gradio(c("Normal", "Bootstrap"), cont = g)
                        btn <- gbutton("ok", handler = function(h, ...) {
                            sets <- curSet
                            sets <- modifyList(
                                sets,
                                list(bs.inference = (svalue(rd, index = TRUE) == 2),
                                     summary.type = "inference",
                                     inference.type = "conf",
                                     inference.par = NULL)
                                )

                            infType <- svalue(rd, index = TRUE)
                            dispose(w)

                            infTitle <- "Inference Information"
                            if (infType == 2) {
                                ## Not sure why this acts weird. At least on Linux, the text inside `wBoots` doesn't becoem visible until the
                                ## function has finished.
                                wBoots <- gwindow("Please wait while iNZight performs bootstrap simulations ...", visible = FALSE,
                                                  parent = win, width=850, height=400)
                                gBoots <- gtext("Currently performing bootstrap simulations.\nDepending on the size of your data, this may take a while.",
                                                cont = wBoots, expand = TRUE,
                                                font.attr = list(family = "monospace"))
                                visible(wBoots) <- TRUE
                            }

                            w2 <- gwindow(infTitle, width = 850, height = 400,
                                          visible = FALSE, parent = win)
                            g2 <- gtext(
                                paste(
                                    do.call(
                                        iNZightPlots:::getPlotSummary,
                                        sets),
                                    collapse = "\n"),
                                expand = TRUE, cont = w2, wrap = FALSE,
                                font.attr = list(family = "monospace"))
                            visible(w2) <- TRUE
                            try(dispose(wBoots), silent = TRUE)
                        }, cont = g)

                    } else {
                        gmessage("Please select at least one variable",
                                 parent = win)
                    }
                })
            font(sumBtn) <<- list(weight = "bold",
                                 family = "normal",
                                 color = "navy")
            font(infBtn) <<- list(weight = "bold",
                                 family = "normal",
                                 color = "navy")
            add(sumGrp, sumBtn, expand = TRUE)
            add(sumGrp, infBtn, expand = TRUE)
            sumGrp
        },
        ## set up the widget with the plot notebook
        initializePlotWidget = function() {
            plotWidget <<- iNZPlotWidget$new(.self)
        },
        ## set up the buttons under the plot to interact with the plot
        initializePlotToolbar = function(cont) {
            plotToolbar <<- iNZPlotToolbar$new(.self, cont)
        },
        ## if set upon gui startup, close the R sessions when
        ## the gui is closed
        closerHandler = function(disposeR) {
            addHandlerUnrealize(win, handler = function(h, ...) {
                if (disposeR) {
                    confirm <- gconfirm(
                        title = "Are you sure?",
                        msg = "Do you wish to quit iNZightVIT?",
                        icon = "question",
                        parent = win)
                    if (confirm)
                        q(save = "no")
                    else
                        FALSE
                } else {
                    try(dev.off(), silent = TRUE)
                    dispose(win)
                }
            })
        },
        ## plot with the current active plot settings
        updatePlot = function(allow.redraw = TRUE) {
            curPlSet <- getActiveDoc()$getSettings()
            if(!is.null(curPlSet$x)){
              # Switch x and y:
                if (is.numeric(curPlSet$x) & is.numeric(curPlSet$y)) {
                    x.tmp <- curPlSet$y
                    curPlSet$y <- curPlSet$x
                    curPlSet$x <- x.tmp

                    x.tmp <- curPlSet$varnames$y
                    curPlSet$varnames$y <- curPlSet$varnames$x
                    curPlSet$varnames$x <- x.tmp
                }
                ## Design or data?
                curMod <- getActiveDoc()$getModel()
                if (!is.null(curMod$dataDesign)) {
                    curPlSet$data <- NULL
                    curPlSet$design <- curMod$createSurveyObject()
                }

                ## "swap" the behaviour around
                curPlSet$internal.labels <- !curPlSet$internal.labels

                ## Suppress the warnings produced by iNZightPlot ...
                suppressWarnings({
                    curPlot <<- unclass(do.call(iNZightPlot, curPlSet))
                    if (allow.redraw & !is.null(attr(curPlot, "dotplot.redraw")))
                        if (attr(curPlot, "dotplot.redraw"))
                            curPlot <<- unclass(do.call(iNZightPlot, curPlSet))
                })                
                plotType <<- attr(curPlot, "plottype")
            } else {
                iNZightPlots:::resetPlot()
                plotType <<- "none"
            }
        },
        ## set a new iNZDocument and make it the active one
        setDocument = function(document) {
            ## reset control widget
            ctrlWidget$resetWidget()
            ## add a iNZDocument to the end of the doc list
            iNZDocuments <<- c(iNZDocuments, list(document))
            ## set the active document to the one we added
            activeDoc <<- length(iNZDocuments)
            ## if the dataSet changes, update the variable View
            ## and the settings to take into account possible
            ## change of currently selected data
            getActiveDoc()$addDataObserver(
                function() {
                    dataViewWidget$updateWidget()
                    getActiveDoc()$updateSettings()

                    ## Also, update list of variables in drop-downs:
                    ctrlWidget$updateVariables()
                }
                )
            ## if plotSettings change, update the plot
            getActiveDoc()$addSettingsObserver(function() updatePlot())
        },
        getActiveDoc = function() {
            iNZDocuments[[activeDoc]]
        },
        getActiveData = function() {
            iNZDocuments[[activeDoc]]$getData()
        },
        getActiveRowData = function() {
            iNZDocuments[[activeDoc]]$getRowData()
        },
        ## add observer to the activeDoc class variable
        addActDocObs = function(FUN, ...) {
            .self$activeDocChanged$connect(FUN, ...)
        },
        ## data check
        checkData = function(module) {
            data = .self$getActiveData()
            vars = names(data)
            ret = TRUE

            ## If dataset is empty (no data imported) display type 1 message,
            ## otherwise check whether imported data is appropriate for module
            ## (if wrong data type, display type 2 message)
            if (length(vars) == 1 && vars[1] == "empty") {
                ## check for empty data
                displayMsg(module, type = 1)
                ret = FALSE
            }

            return(ret)
        },
        ## display warning message
        displayMsg = function(module, type) {
            if (type == 1) {
                gmessage(msg = paste("A dataset is required to use the", module, "module"),
                         title = "Empty data", icon = "error")
            } else if (type == 2) {
                gmessage(msg = paste("Imported dataset is not appropriate for", module, "module"),
                         title = "Inappropriate data type", icon = "error")
            }
        },
        ## initialize module window
        initializeModule = function(module) {
            ## If module is already installed load it,
            ## otherwise ask for a download then install & load
            if (module %in% rownames(installed.packages())) {
                require(module, character.only = TRUE)
            } else {
                install = gconfirm("The module is not found. Would you like to download it?")
                if (install) {
                    install.packages(module, repo = "http://r.docker.stat.auckland.ac.nz/R")
                    require(mod, character.only = TRUE)
                }
            }

            ## once module is loaded, check data
            if (checkData(module)) {
                ## if there is not a module open,
                ## initialize and open a module window
                if (length(leftMain$children) == 1) {
                    initializeModuleWindow()
                    source(paste0("../iNZightModules/R/", module, ".R"))
                    cmd = paste0(module, "$new(.self)")
                    eval(parse(text = cmd))
                    visible(moduleWindow) <<- TRUE
                } else {
                    newModuleWindow(module)
                }
            } else {
                return()
            }
        },
        ## create a gvbox object into the module window (ie, initialize it)
        ## NOTE: should be run every time when a new module is open
        initializeModuleWindow = function(mod) {
            ## create a gvbox in moduleWindow
            moduleWindow <<- gvbox(container = leftMain, expand = TRUE)
            visible(gp1) <<- FALSE

            if (!missing(mod))
                activeModule <<- mod
        },
        ## --- PREFERENCES SETTINGS and LOCATIONS etc ...
        defaultPrefs = function() {
            ## The default iNZight settings:
            list(track = "ask", track.id = NULL,
                 check.updates = TRUE,
                 window.size = c(1020, 700),
                 popout = FALSE)
        },
        checkPrefs = function(prefs) {
            allowed.names <- c("track", "track.id", "check.updates", "window.size", "popout")

            ## Only keep allowed preferences --- anything else is discarded
            prefs <- prefs[names(prefs) %in% allowed.names]
            defs <- defaultPrefs()

            ## TRACK = TRUE | FALSE | "ask"
            prefs$track <-
                if (is.null(prefs$track)) defs$track
                else if (!is.na(prefs$track) & (prefs$track == "ask" | is.logical(prefs$track))) prefs$track
                else defs$track


            ## check.updates = TRUE | FALSE
            prefs$check.updates <-
                if (is.null(prefs$check.updates)) defs$check.updates
                else if (!is.na(prefs$check.updates) & is.logical(prefs$check.updates)) prefs$check.updates
                else defs$check.updates

            ## window.size = c(WIDTH, HEIGHT)
            prefs$window.size <-
                if (is.null(prefs$window.size)) defs$window.size
                else if (length(prefs$window.size) != 2) defs$window.size
                else if (is.numeric(prefs$window.size)) prefs$window.size
                else defs$window.size

            ## pop-out layout = FALSE
            prefs$popout <-
                if (is.null(prefs$popout)) defs$popout
                else if (is.logical(prefs$popout)) prefs$popout
                else defs$popout

            prefs

        },
        getPreferences = function() {
            ## --- GET THE PREFERENCES
            ## Windows: the working directory will be set as $INSTDIR (= C:\Program Files (x86) by default)
            ##      NOTE: "~" -> C:\Users\<user>\Documents on windows!!!!!
            ##     1. ~\iNZightVIT\.inzight -> this is where it goes for Most users
            ##     2. ~\.inzight -> fallback for R users
            ##
            ## Mac: the working directory will be set as /Applications/iNZightVIT/
            ##     1. ~/Documents/iNZightVIT/.inzight -> again, default
            ##     2. ~/.inzight -> fallback for R users
            ##
            ## Linux: user installs manually, at least for now, working directory will be wherever they run R from ...
            ##     1. ~/.inzight
            ##     2. $(pwd)/.inzight -> overrides (1) if present

            ## If Windows or Mac, set the working directory to Documents/iNZightVIT if possible ...
            
            prefs.location <<-
                switch(OS,
                       "windows" = {
                           if (file.exists(file.path("~", "iNZightVIT"))) {
                               path <- file.path("~", "iNZightVIT", ".inzight")
                           } else {
                               path <- file.path("~", ".inzight")
                           }
                           
                           path
                       },
                       "mac" = {
                           if (file.exists(file.path("~", "Documents", "iNZightVIT"))) {
                               path <- file.path("~", "Documents", "iNZightVIT", ".inzight")
                           } else {
                               path <- file.path("~", ".inzight")
                           }
                           
                           path
                       },
                       "linux" = {
                           path <- file.path("~", ".inzight")
                           
                           if (file.exists(".inzight"))
                               path <- file.path(".inzight")

                           path
                       })

            tt <- try({
                preferences <<-
                    if (file.exists(prefs.location)) {
                        checkPrefs(dget(prefs.location))
                    } else {
                        defaultPrefs()
                    }
            }, TRUE)
            
            if (inherits(tt, "try-error"))
                preferences <<- defaultPrefs()
        },
        savePreferences = function() {
            ## attempt to save the preferences in the expected location:
            tt <- try(dput(preferences, prefs.location), silent = TRUE)
            if (inherits(tt, "try-error")) {
                gmessage(paste("iNZight was unable to save your preferences, so",
                               "they won't carry over into the next session."),
                         title = "Unable to save preferences", icon = "warning")
            }            
        },
        plotSplashScreen = function() {
            if (requireNamespace("png", quietly = TRUE)) {
                img <- png::readPNG(system.file("images/inzight_splash.png", package = "iNZight"))
                grid::grid.newpage()
                grid::pushViewport(grid::viewport())
                grid::grid.raster(img)

                grDevices::dev.flush()
            }
        })
    )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZImportExampleWin.R"
iNZImportExampleWin <-
    setRefClass(
        "iNZImportExampleWin",
        fields = list(
            GUI = "ANY",
            importFileWin = "ANY",
            datasets = "ANY"
            ),
        methods = list(

            initialize = function(gui) {
                initFields(GUI = gui)

                ## packages that have data in them:
                pkgsL <- list("iNZight" = "Default",
                              "iNZightMR" = "Multiple Response",
                              "iNZightTS" = "Time Series",
                              "iNZightMaps" = "Maps",
                              "survey" = "Survey Package")
                pkgs <- unlist(pkgsL)  ## becomes a named vector

                pkgs <- pkgs[names(pkgs) %in% rownames(installed.packages())]
                
                ## create the window
                importFileWin <<- gwindow("Load Example Data", parent = GUI$win, visible = FALSE,
                                          height = 200, width = 600)
                mainGrp <- gvbox(container = importFileWin, expand = TRUE, fill = TRUE)
                mainGrp$set_borderwidth(15)
                
                tbl <- glayout(container = mainGrp, homogeneous = TRUE)
                ii <- 1

                ## select box populated with packages (defined above)
                lbl <- glabel("Module (package) :")
                dsPkg <- gcombobox(pkgs, selected = 1)
                tbl[ii, 1, anchor = c(1, 0), expand = TRUE] <- lbl
                tbl[ii, 2:4, anchor = c(-1, 0), expand = TRUE] <- dsPkg
                ii <- ii + 1


                ## select box populated with datasets in chosen package
                lbl <- glabel("Dataset :")
                dsData <- gcombobox("", selected = 0)
                tbl[ii, 1, anchor = c(1, 0), expand = TRUE] <- lbl
                tbl[ii, 2:4, anchor = c(-1, 0), expand = TRUE] <- dsData
                ii <- ii + 1

                
                tbl[ii, 1, anchor = c(1, 0), expand = TRUE] <- glabel("Title :")
                dsTitle <- glabel("")
                tbl[ii, 2:4, anchor = c(-1, 0), expand = TRUE] <- dsTitle

                addSpring(mainGrp)

                setDataMenu <- function() {
                    datasets <<- data(package = names(pkgs)[svalue(dsPkg, index = TRUE)])$results
                    dsData$set_items(datasets[, "Item"])
                }
                setDataMenu()

                ## Change Handlers:
                addHandlerChanged(dsPkg, function(h, ...) {
                                      ## set the dataset menu
                                      setDataMenu()
                                  })
                addHandlerChanged(dsData, function(h, ...) {
                                      svalue(dsTitle) <- datasets[svalue(dsData, index = TRUE), "Title"]
                                  })

                
                ## OK / Cancel buttons
                btnGrp <- ggroup(cont = mainGrp)
                addSpring(btnGrp)

                cancelBtn <- gbutton("Cancel", expand = TRUE, cont = btnGrp,
                                     handler = function(h, ...) {
                                         dispose(importFileWin)
                                     })

                okBtn <- gbutton("OK", expand = TRUE, cont = btnGrp,
                                 handler = function(h, ...) {
                                     ## Set the data - will need to 'load' it into an evironment, then
                                     ## reassign it:
                                     ind <- svalue(dsData, index = TRUE)
                                     dataName <- dname <- datasets[ind, "Item"]
                                     pkgname <- names(pkgs)[svalue(dsPkg, index = TRUE)]
                                     
                                     if (pkgname == "survey") {
                                         if (grep('\\(.+\\)', dname)) {
                                             dataName <- gsub("\\)", "", gsub(".+\\(", "", dataName))
                                             dname <- gsub(" \\(.+", "", dname)
                                         }
                                     }
                                     
                                     tmp.env <- new.env()
                                     data(list = dataName, package = pkgname, envir = tmp.env)

                                     ## Set the name to the title (or Item if title missing)
                                     attr(tmp.env[[dname]], "name") <-
                                         ifelse(datasets[ind, "Title"] == "", dname, datasets[ind, "Title"])
                                     
                                     GUI$setDocument(iNZDocument$new(data = tmp.env[[dname]]))

                                     ## clean up
                                     rm("tmp.env")
                                     dispose(importFileWin)
                                 })
                
                
                visible(importFileWin) <<- TRUE
                
            }
            
            )
        )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZImportWin.R"
iNZImportWin <- setRefClass("iNZImportWin",
                            fields = list(
                                GUI = "ANY",
                                importFileWin = "ANY"
                                ),
                            methods = list(
                                initialize = function(GUI) {
                                    initFields(GUI = GUI)
                                    ## set up main import window
                                    importFileWin <<- gwindow("File Browser", 
                                                              parent = GUI$win)
                                    fileMainGp = ggroup(container = importFileWin, horizontal = FALSE)
                                    filetbl = glayout(container = fileMainGp)
                                    ## create list of possible file extensions
                                    l = list()
                                    l[[gettext("Tab-delimited Text files")]] = c("txt")
                                    l[[gettext("CSV files")]] = c("csv")
                                    l[[gettext("2007 Excel files")]] = c("xlsx")
                                    l[[gettext("97-2003 Excel files")]] = c("xls")
                                    l[[gettext("Infoshare CSV files")]] = c("infosharecsv")
                                    fileExtensions = l
                                    ## set up filebrowse and dropdown
                                    filterList = lapply(fileExtensions, function(i)
                                        list(patterns = paste("*.",i,sep="")))
                                    ll = list()
                                    ll$"All files " = list(patterns=c("*"))
                                    filterList = c(ll,filterList)                                  
                                    filetbl[2,2] = glabel("Local file")
                                    filetbl[2,3] <- (filebrowse = gfilebrowse(text="Specify a file",
                                                         initial.dir = file.path(".", "data"),
                                                         action=invisible,
                                                         container=filetbl, filter=filterList, quote=FALSE))
                                    filetbl[3,2:3] <- gseparator(container = filetbl)
                                    filetbl[4,2] = gettext("File type is")
                                    filetbl[4,3] <- (filetype =
                                                     gcombobox(c("<use file extension to determine>",
                                                                 sapply(
                                                                     names(filterList[!filterList %in% ll]),
                                                                     .self$popchar)),
                                                               container = filetbl))
                                    visible(filetbl) <- TRUE
                                    ## set up the buttons
                                    buttonGp = ggroup(container = fileMainGp)
                                    addSpring(buttonGp)
                                    okButton = gbutton("OK",
                                        handler = function(h, ...) {
                                            .self$okButtonHandler(h,
                                                                  fileBrowse = filebrowse,
                                                                  fileType = filetype, 
                                                                  fileExtensions = fileExtensions, ...)
                                            })
                                    cancelButton = gbutton("Cancel",
                                        handler = function(h, ...) dispose(importFileWin))
                                    add(buttonGp, okButton)
                                    add(buttonGp, cancelButton)
                                    add(fileMainGp,
                                        #glabel("Space for extra options : to define NA string, header presence etc."))                                                                   
                                        glabel(""))
                                    },
                                    pop = function(x) {
                                        x[-length(x)]
                                    },
                                    popchar = function(str) {
                                        paste(.self$pop(unlist(strsplit(str,""))),collapse="")
                                    },
                                    okButtonHandler = function(h, fileBrowse, fileType,
                                        fileExtensions,...) {
                                        theFile = svalue(fileBrowse)
                                        ext = NULL ## the extension, figure out
                                        if(theFile == "Specify a file" || !file.exists(theFile)) {
                                            ## raise error
                                        }else{
                                            ## file is now theFile
                                            ## get extension type from droplist
                                            fileType = svalue(fileType)
                                            if(fileType != "<use file extension to determine>") {
                                                ## use filterList to get
                                                fileType = paste(fileType,"s", sep="", collapse="") ## append s back
                                                ext = fileExtensions[[fileType]][1]
                                                sprintf("Set extension to %s \n",ext)
                                            } else if(is.null(ext)) {
                                                tmp = unlist(strsplit(basename(theFile), split="\\."))
                                                ext = tmp[length(tmp)]
                                            }
                                            dataImportObj <- iNZDataImportExport$new()
                                            dataImportObj$importData(theFile, ext)
                                            ## if an error occured during the file import, raise a msg
                                            ## otherwise set the document in the GUI object
                                            if(dataImportObj$error$cur)
                                                gmessage(title = dataImportObj$error$title,
                                                         msg = dataImportObj$error$msg,
                                                         icon = dataImportObj$error$icon,
                                                         parent = importFileWin)
                                            else {
                                                GUI$setDocument(iNZDocument$new(data = dataImportObj$dataSet))
                                                dispose(importFileWin)
                                            }
                                        }                                        
                                    }
                                )
                            )
                            
#line 1 "/Users/tom/iNZight/iNZight/R/iNZPlotInfWin.R"
## --------------------------------------------
## The super class for the plot modification window
## The different windows that are opened through the
## 'Inference Information' button are subclasses of this superclass
## The window that is opened depends on the variables
## currently selected in the control widget (or in the iNZDocument,
## which is the same since the two are linked together)
## --------------------------------------------

iNZPlotInfWin <- setRefClass(
    "iNZPlotInfWin",
    fields = list(
        GUI = "ANY",
        parTab = "ANY",
        metTab = "ANY",
        typTab = "ANY",
        btnTab = "ANY",
        curSet = "list",
        intBtn = "ANY"
        ),
    methods = list(
        initialize = function(gui = NULL) {
            initFields(GUI = gui)
            if (!is.null(GUI)) {
                ## close modification window if one is open
                if (length(GUI$leftMain$children) > 1) {
                    delete(GUI$leftMain, GUI$leftMain$children[[2]])
                }
                GUI$initializeModuleWindow()

                updateSettings()

                mainGrp <- gvbox(container = GUI$moduleWindow, expand = TRUE)
                mainGrp$set_borderwidth(5)

                ## Window title
                ttl <- glabel("Add Inference Information")
                font(ttl) <- list(weight = "bold", family = "normal", size = 11)
                add(mainGrp, ttl)

                ## Three layouts, one for parameter/method/type
                parTab <<- glayout()
                metTab <<- glayout()
                typTab <<- glayout()
                btnTab <<- glayout()

                ## Labels for each option
                parLab <- glabel("Parameter")
                font(parLab) <- list(weight = "bold", family = "normal", size = 9)

                metLab <- glabel("Type of Inference")
                font(metLab) <- list(weight = "bold", family = "normal", size = 9)

                typLab <- glabel("Type of Interval")
                font(typLab) <- list(weight = "bold", family = "normal", size = 9)
                
                parTab[2, 1, expand = TRUE, anchor = c(-1, 0)] <<- parLab
                metTab[2, 1, expand = TRUE, anchor = c(-1, 0)] <<- metLab
                typTab[2, 1, expand = TRUE, anchor = c(-1, 0)] <<- typLab

                ## Show interval values button
                intBtn <<- gbutton("Get values", expand = FALSE,
                                  handler = function(h, ...) {
                                      displayValues()
                                  })
                btnTab[2, 1, expand = TRUE] <<- intBtn
                visible(intBtn) <<- FALSE
                inflabl <- glabel("* iNZight may appear upresponsive while the bootstraps are performed.\nPlease be patient.")
                font(inflabl) <- list(size = 8)
                btnTab[3, 1, expand = TRUE] <<- inflabl

                add(mainGrp, parTab)
                add(mainGrp, metTab)
                add(mainGrp, typTab)
                add(mainGrp, btnTab)

                addSpring(mainGrp)

                btnGrp <- ggroup(horizontal = TRUE,
                                 expand = FALSE)

                helpButton <- gbutton("Help", expand = TRUE, fill = TRUE,
                                      cont = btnGrp,
                                      handler = function(h, ...) {
                                         browseURL("https://www.stat.auckland.ac.nz/~wild/iNZight/user_guides/plot_options/?topic=plot_inference")
                                      })
                            
                okButton <- gbutton("Close", expand = TRUE, fill = TRUE,
                                    cont = btnGrp,
                                    handler = function(h, ...) {
                                        ## delete the module window
                                        delete(GUI$leftMain, GUI$leftMain$children[[2]])
                                        ## display the default view (data, variable, etc.)
                                        visible(GUI$gp1) <<- TRUE
                                    })
                
                add(mainGrp, btnGrp, expand = FALSE, fill = "x", anchor = c(0, -1))
                visible(GUI$moduleWindow) <<- TRUE
            }
        },
        ## up the curSet class variable
        updateSettings = function() {
            curSet <<- GUI$getActiveDoc()$getSettings()
        },
        displayValues = function() {
            return(NULL)
        })
    )

iNZBarchartInf <- setRefClass(
    "iNZBarchartInf",
    contains = "iNZPlotInfWin",
    methods = list(
        initialize = function(GUI) {
            callSuper(GUI)

            is.survey <- !is.null(GUI$getActiveDoc()$getModel()$getDesign())

            ## Parameters
            parm <- glabel("Proportions")
            
            parTab[3, 1, expand = TRUE, anchor = c(-1, 0)] <<- parm

            
            ## Methods
            if (is.survey)
                mthd <- gradio(c("Normal"), selected = 1)
            else
                mthd <- gradio(c("Normal", "Bootstrap *"), selected = 1)

            metTab[3, 1] <<- mthd
            
            
            ## Interval types
            compInt <- gcheckbox("Comparison Intervals",
                                 checked = "comp" %in% curSet$inference.type)
            confInt <- gcheckbox("Confidence Intervals",
                                 checked = "conf" %in% curSet$inference.type)

            typTab[3, 1] <<- confInt
            typTab[4, 1] <<- compInt            

            
            ## Add function
            addIntervals <- function() {
                ## Inference type depends on method (normal = both; bootstrap = only confidence [for now]..)
                if (svalue(compInt) | svalue(confInt))
                    inf.type <- c("comp", "conf")[c(svalue(compInt) & svalue(mthd, index = TRUE) == 1, svalue(confInt))]
                else
                    inf.type <- NULL
                
                
                bs.inf <- svalue(mthd, index = TRUE) == 2
                GUI$getActiveDoc()$setSettings(
                    list(
                        inference.type = inf.type,
                        bs.inference = bs.inf
                        )
                    )
                updateSettings()
            }

            enabler <- function() {
                if (is.survey) {
                    ## While not available:
                    visible(compInt) <- FALSE
                } else {
                    visible(compInt) <- svalue(mthd, index = TRUE) == 1
                }
                #if (svalue(mthd, index = TRUE) == 2) svalue(compInt) <- FALSE

                addIntervals()
            }

            addHandlerChanged(mthd, handler = function(h, ...) enabler())
            addHandlerChanged(compInt, handler = function(h, ...) enabler())
            addHandlerChanged(confInt, handler = function(h, ...) enabler())

            enabler()
        })
    )

iNZDotchartInf <- setRefClass(
    "iNZDotchartInf",
    contains = "iNZPlotInfWin",
    methods = list(
        initialize = function(GUI) {
            callSuper(GUI)

            is.survey <- !is.null(GUI$getActiveDoc()$getModel()$getDesign())

            ## Parameters
            if (is.survey)
                parm <- gradio(c("Mean"), selected = 1)
            else
                parm <- gradio(c("Mean", "Median"), selected = 1)
            
            parTab[3, 1, expand = TRUE, anchor = c(-1, 0)] <<- parm

            
            ## Methods
            if (is.survey)
                mthd <- gradio(c("Normal"), selected = 1)
            else
                mthd <- gradio(c("Normal", "Bootstrap *"), selected = 1)

            metTab[3, 1] <<- mthd
            
            
            ## Interval types
            compInt <- gcheckbox("Comparison Intervals",
                                 checked = "comp" %in% curSet$inference.type)
            confInt <- gcheckbox("Confidence Intervals",
                                 checked = "conf" %in% curSet$inference.type)

            typTab[3, 1] <<- confInt
            typTab[4, 1] <<- compInt            

            
            ## Add function
            addIntervals <- function() {
                if (svalue(parm, index = TRUE) == 2 & svalue(mthd, index = TRUE) == 1) {
                    ## If median + normal, display year12 interval:
                    inf.type <- "conf"
                    inf.par <- "median"
                } else if (svalue(compInt) | svalue(confInt)) {
                    inf.type <- c("comp", "conf")[c(svalue(compInt) & !is.null(curSet$y), svalue(confInt))]
                    inf.par <- c("mean", "median")[svalue(parm, index = TRUE)]
                } else {
                    inf.type <- inf.par <- NULL
                }
                
                bs.inf <- svalue(mthd, index = TRUE) == 2
                GUI$getActiveDoc()$setSettings(
                    list(
                        inference.type = inf.type,
                        inference.par = inf.par,
                        bs.inference = bs.inf
                        )
                    )
                updateSettings()
            }

            enabler <- function(p = FALSE) {
                ## Hide comparison intervals if only one group:
                visible(compInt) <- !is.null(curSet$y)

                ## For MEAN, use NORMAL+BOOTSTRAP
                ## For MEDIAN, use YEAR12+BOOTSTRAP
                ##    YEAR12 intervals are neither CONFIDENCE nor COMPARISON, so hide that option too
                ## But only do this if user changes the parameter:
                if (p) {
                    if (svalue(parm, index = TRUE) == 2) {
                        mthd$set_items(c("Year 12", "Bootstrap *"))
                    } else {
                        mthd$set_items(c("Normal", "Bootstrap *"))
                    }
                }

                visible(typTab) <<- svalue(parm, index = TRUE) == 1 | svalue(mthd, index = TRUE) == 2
                
                addIntervals()
            }

            addHandlerChanged(parm, handler = function(h, ...) enabler(TRUE))
            addHandlerChanged(mthd, handler = function(h, ...) enabler())
            addHandlerChanged(compInt, handler = function(h, ...) enabler())
            addHandlerChanged(confInt, handler = function(h, ...) enabler())

            enabler()

            visible(intBtn) <<- TRUE
        },
        displayValues = function() {
            out <- c()
            pl <- GUI$curPlot

            ## First grab G2 stuff:
            vn <- attr(pl, "varnames")
            g1 <- vn$g1
            g2 <- vn$g2
            
            if (is.null(g2)) {
                pl <- pl["all"]
            } else {
                  pl <- pl[1:(which(names(pl) == "gen") - 1)]
            }

            for (n1 in names(pl)) {
                ## Grab the level of g2:
                p1 <- pl[[n1]]
                
                if (!is.null(g2))
                    out <- c(out, paste0("## ", g2, " = ", n1))

                for (n2 in names(p1)) {
                    p2 <- p1[[n2]]

                    if (!is.null(g1))
                        out <- c(out, paste0("# ", g1, " = ", n2))

                    ## If MEDIAN and NOT BOOTSTRAP, then we show Year 12 intervals (neither COMP nor
                    ## CONF)
                    if (!is.list(p2$inference)) {
                        out <- c(out, "No inference", "")
                        next
                    }                        
                        
                    y12 <- names(p2$inference)[1] == "median" & !attr(p2$inference, "bootstrap")
                    inf <- p2$inference[[1]]  ## only take the first (mean or median)

                    if (y12)
                        inf <- inf["conf"]

                    inf <- inf[!sapply(inf, is.null)]
                    
                    if (length(inf) == 0) {
                        out <- c(out, "No values", "")
                    } else {                    
                        do.call(cbind, lapply(names(inf), function(i) {
                                                       m <- inf[[i]][, 1:2, drop = FALSE]
                                                       if (!y12)
                                                           colnames(m) <- paste(i, colnames(m), sep = ".")
                                                       m
                                                   })
                                ) -> oo
                        
                        mat <- matrix(apply(oo, 2, function(col) {
                                                    format(col, digits = 4)
                                                }), nrow = nrow(oo))
                        mat[grep("NA", mat)] <- ""
                        
                        mat <- rbind(colnames(oo), mat)
                        if (nrow(oo) > 1)
                            mat <- cbind(c("", rownames(oo)), mat)
                        
                        mat <- matrix(apply(mat, 2, function(col) {
                                                     format(col, justify = "right")
                                                 }), nrow = nrow(mat))
                        
                        mat <- apply(mat, 1, function(x) paste0("   ", paste(x, collapse = "   ")))
                        
                        out <- c(out, mat, "")
                    }
                }
                

                out <- c(out, "", "")
            }

            ww <- gwindow(title = "Inference values", parent = GUI$win,
                          width = 700, height = 400, visible = FALSE)
            g <- gtext(text = paste(out, collapse = "\n"),
                       expand = TRUE, cont = ww, wrap = FALSE,
                       font.attr = list(family = "monospace"))
            visible(ww) <- TRUE
        })
    )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZPlotModWin.R"
## --------------------------------------------
## The super class for the plot modification window
## The different windows that are opened through the
## 'Add to Plot' button are subclasses of this superclass
## The window that is opened depends on the variables
## currently selected in the control widget (or in the iNZDocument,
## which is the same since the two are linked together)
## --------------------------------------------

iNZPlotModWin <- setRefClass(
    "iNZPlotModWin",
    fields = list(
        GUI = "ANY",
        modWin = "ANY",
        okButton = "ANY",
        ## grp that will hold the multiple choices for plot mods
        radioGrp = "ANY",
        pageMethods = "list",
        ## depending on selection in radioGrp, options for mod
        ## will be displayed here
        optGrp = "ANY",
        curSet = "list", ## the current plot settings
        auto = "logical",   ## if TRUE, then changes occur automatically
        locSet = "ANY",
        palettes = "list",
        bgColours = "list",
        pointColours = "list",
        colourPalettes = "list",
        EMPH.LEVEL = "numeric"
        ),
    methods = list(
        initialize = function(gui = NULL, which = 1) {
            initFields(GUI = gui,
                       bgColours =
                           list(default = "#eeeeee",
                                darkgrey = "grey20",
                                white = "white",
                                black = "black",
                                wheat = "wheat",
                                bisque = "bisque",
                                cornsilk = "cornsilk"),
                       pointColours =
                           list(default = "grey50",
                                darkgrey = "grey20",
                                lightgrey = "grey80",
                                blue = "#004b85",
                                red = "red",
                                green = "green4"),
                       colourPalettes =
                           list(cat  =
                                    list(default = inzpar()$col.default$cat,
                                         light = function(n) rainbow_hcl(n, c = 50, l = 80, start = 10, end = 320),
                                         dark = function(n) rainbow_hcl(n, c = 50, l = 60, start = 0, end = 288),
                                         vibrant = function(n) rainbow_hcl(n, c = 80, l = 60, start = 0, end = 300)),
                                cont =
                                    list(default = inzpar()$col.default$cont,
                                         blue = function(n)
                                             sequential_hcl(n, h = 260, c. = c(80, 10), l = c(30, 95), power = 0.7),
                                         green = function(n)
                                             sequential_hcl(n, h = 135, c. = c(50, 10), l = c(40, 95), power = 0.4),
                                         red = function(n)
                                             sequential_hcl(n, h = 10, c. = c(80, 10), l = c(30, 95), power = 0.7),
                                         "green-yellow" = function(n)
                                             terrain_hcl(n, h = c(130, 30), c. = c(65, 0), l = c(45, 90),
                                                            power = c(0.5, 1.5)),
                                         "red-blue" = function(n)
                                             terrain_hcl(n, h = c(0, -100), c. = c(80, 40), l = c(40, 75),
                                                            power = c(1, 1)),
                                         terrain = terrain_hcl,
                                         heat = heat_hcl,
                                         "blue/white/pink" = function(n)
                                             diverge_hcl(n, h = c(180, 330), c = 59, l = c(75, 95), power = 1.5),
                                         "blue/white/red" = function(n)
                                             diverge_hcl(n, h = c(260, 0), c = 100, l = c(50, 90), power = 1)),
                                emphasize = function(n, k, cat = TRUE, ncat = 5,
                                                     fn = if (cat) inzpar()$col.default$cat else inzpar()$col.default$cont) {
                                    cols <- fn(n)
                                    if (!cat) {
                                        ks <- floor(seq(1, n, length = ncat + 1))
                                        k <- ks[k]:ks[k+1]
                                    }
                                    cols[k] <- iNZightPlots:::darken(cols[k], 0.6)
                                    cols[-k] <- iNZightPlots:::shade(cols[-k], 0.7)
                                    cols
                                }),
                       EMPH.LEVEL = 0)
            if (!is.null(GUI)) {
                updateSettings()

                if (length(GUI$leftMain$children) > 1) {
                    delete(GUI$leftMain, GUI$leftMain$children[[2]])
                }
                GUI$initializeModuleWindow()
                
                mainGrp <- gvbox(container = GUI$moduleWindow, expand = TRUE, fill = TRUE)
                mainGrp$set_borderwidth(5)
                topGrp <- ggroup(horizontal = TRUE,
                                 container = mainGrp)
                lbl <- glabel("Add to Plot :")
                font(lbl) <- list(weight="bold",
                                  family = "normal",
                                  size = 11)
                radioGrp <<- ggroup(horizontal = FALSE,
                                    expand = TRUE)
                
                optGrp <<- ggroup(horizontal = FALSE, expand = TRUE, use.scrollwindow = TRUE)
                add(topGrp, lbl)
                add(topGrp, radioGrp, expand = TRUE, fill = TRUE)

                add(mainGrp, optGrp, expand = TRUE)

                btnGrp <- ggroup(horizontal = TRUE,
                                 expand = FALSE)

                helpButton <- gbutton("Help", expand = TRUE, fill = TRUE,
                                      cont = btnGrp,
                                      handler = function(h, ...) {
                                          browseURL("https://www.stat.auckland.ac.nz/~wild/iNZight/user_guides/plot_options/?topic=add_to_plot")
                                      })
                            
                okButton <<- gbutton("Close", expand = TRUE, fill = TRUE,
                                     cont = btnGrp,
                                     handler = function(h, ...) {
                                         ## delete the module window
                                         delete(GUI$leftMain, GUI$leftMain$children[[2]])
                                         ## display the default view (data, variable, etc.)
                                         visible(GUI$gp1) <<- TRUE
                                     })
                
                
                add(mainGrp, btnGrp, expand = FALSE, fill = "x", anchor = c(0, -1))

                ## If sample size is too big, use a button instead of automatically apply changes
                auto <<- nrow(GUI$getActiveData()) < 100000

                visible(GUI$moduleWindow) <<- TRUE
            }
        },
        ## up the curSet class variable
        updateSettings = function() {
            curSet <<- GUI$getActiveDoc()$getSettings()
        },
        iNZLocatePoints = function(dot = FALSE) {
            ## Do checking first
            ## If g1 or g2 = _MULTI, then we can't identify points (yet ...)
            cantDo <- function(msg = "using subsetting variables.") {
                gmessage(paste("Cannot identify points when", msg),
                         icon = "error", title = "Unable to identify",
                         parent = modWin)
                return()
            }
            ## remove random ordering of points ...
            GUI$getActiveDoc()$setSettings(list(plot.features = list(order.first = -1)))
            updateSettings()
            
            locSet <<- curSet$locate.settings
            
            updateEverything <- function(locate = GUI$getActiveDoc()$getSettings()$locate,
                                         id = GUI$getActiveDoc()$getSettings()$locate.id,
                                         col = GUI$getActiveDoc()$getSettings()$locate.col,
                                         ext = GUI$getActiveDoc()$getSettings()$locate.extreme) {
                if (is.null(id) & is.null(ext)) {
                    locate = NULL
                    id = NULL
                    col = NULL
                    ext = NULL
                }
                
                if (!is.null(id)) {
                    ext <- NULL
                } else {
                    locSet$ID <<- NULL
                }
                
                highlight <-
                    if (svalue(matchChk)) locSet$ID
                    else NULL
                
                ## update the locate settings:
                locSet$txtLabs <<- svalue(txtLabs)
                locSet$txtVar <<- svalue(varmenu)
                
                locSet$colLabs <<- svalue(colLabs)
                locSet$colVar <<- svalue(colmenu)
                
                locSet$matchChk <<- svalue(matchChk)
                locSet$matchVar <<- svalue(matchVar)
                
                locSet$selectMthd <<- svalue(selectMthd)
                
                curSet$locate.settings <<- locSet
                
                if (locSet$matchChk) {
                    levs <- unique(GUI$getActiveData()[highlight, locSet$matchVar])
                    
                    if (length(levs) > 1)
                        levs <- paste0("{", paste(levs, collapse = ", "), "}")
                    
                    if (length(levs) == 1)
                        subt <- paste0("(Locating points with ",
                                       locSet$matchVar, " = ", levs, ")")
                    else
                        subt <- NULL
                } else {
                    subt <- NULL
                }
                
                GUI$getActiveDoc()$setSettings(
                                      list(locate = locate,
                                           locate.id = unique(id),
                                           locate.col = col,
                                           locate.extreme = ext,
                                           locate.settings = locSet,
                                           highlight = highlight,
                                           subtitle = subt,
                                           plot.features = list(order.first = -1))
                                  )
                updateSettings()
            }
            
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("How do you want to label points?")
            font(lbl) <- list(weight = "bold", family = "normal")
            tbl[ii, 1:2, expand = TRUE, anchor = c(-1, 0)] <- lbl
            ii <- ii + 1
            
            txtLabs <- gcheckbox("Text Labels", checked = TRUE)
            varmenu <- gcombobox(c("id", names(GUI$getActiveData())), selected = 1, expand = TRUE)
            tbl[ii, 1] <- txtLabs
            tbl[ii, 2, expand = TRUE] <- varmenu
            ii <- ii + 1
            
            if (!is.null(locSet$txtLabs)) svalue(txtLabs) <- locSet$txtLabs
            if (!is.null(locSet$txtVar))
                if (locSet$txtVar %in% c("id", names(GUI$getActiveData())))
                    svalue(varmenu) <- locSet$txtVar
            
            colLabs <- gcheckbox("Colour Points", checked = FALSE)
            colmenu <- gcombobox(c("red", "blue", "green4"), selected = 1, editable = TRUE, expand = TRUE)
            tbl[ii, 1] <- colLabs
            tbl[ii, 2, expand = TRUE] <- colmenu
            ii <- ii + 1
            
            if (!is.null(locSet$colLabs)) svalue(colLabs) <- locSet$colLab
            if (!is.null(locSet$colVar))
                svalue(colmenu) <- locSet$colVar
            
            enabled(varmenu) <- svalue(txtLabs)  #labMthd, TRUE) == 1
            enabled(colmenu) <- svalue(colLabs)  #labMthd, TRUE) == 2
            
            addHandlerChanged(txtLabs, function(h, ...) {
                enabled(varmenu) <- svalue(txtLabs)  #labMthd, TRUE) == 1
                v <- svalue(varmenu)
                locVar <- if (v == "id") 1:nrow(GUI$getActiveData()) else GUI$getActiveData()[, v]
                updateEverything(
                    locate = if (svalue(txtLabs)) locVar else NULL
                )
            })
            addHandlerChanged(varmenu, function(h, ...) {
                v <- svalue(varmenu)
                locVar <- if (v == "id") 1:nrow(GUI$getActiveData()) else GUI$getActiveData()[, v]
                updateEverything(
                    locate = if (svalue(txtLabs)) locVar else NULL
                )
            })
            addHandlerChanged(colLabs, function(h, ...) {
                enabled(colmenu) <- svalue(colLabs)  #labMthd, TRUE) == 2
                updateEverything(
                    col = if (svalue(colLabs)) svalue(colmenu) else NULL
                )
            })
            addHandlerChanged(colmenu, function(h, ...) {
                if (svalue(colmenu) %in% colours()) {
                    updateEverything(
                        col = if (svalue(colLabs)) svalue(colmenu) else NULL
                    )
                }
            })
            
            
            matchChk <- gcheckbox("With the same level of")
            tbl[ii, 1] <- matchChk
            
            if (!is.null(locSet$matchChk)) svalue(matchChk) <- locSet$matchChk
            
            matchVar <- gcombobox(names(GUI$getActiveData()), selected = 1)
            enabled(matchVar) <- svalue(matchChk)
            tbl[ii, 2, expand = TRUE] <- matchVar
            ii <- ii + 1
            
            if (!is.null(locSet$matchVar))
                if (locSet$matchVar %in% names(GUI$getActiveData()))
                    svalue(matchVar) <- locSet$matchVar
            
            addHandlerChanged(matchChk, function(h, ...) {
                enabled(matchVar) <- svalue(matchChk)
                enabled(clearMulti) <- svalue(matchChk)
                svalue(clearMulti) <- svalue(matchChk)
                
                if (svalue(matchChk)) {
                    ## Add all the points:
                    
                    matchVar <- as.character(GUI$getActiveData()[, svalue(matchVar)])
                    matchVar[is.na(matchVar)] <- "missing"
                    
                    matchLvls <- unique(matchVar[locSet$ID])
                    newIDS <- which(matchVar %in% matchLvls)
                    
                    updateEverything(id = newIDS)
                } else {
                    ## Remove all the points:
                    
                    updateEverything(id = locSet$ID)
                }
            })
            
            addHandlerChanged(matchVar, function(h, ...) {
                matchVar <- as.character(GUI$getActiveData()[, svalue(matchVar)])
                matchVar[is.na(matchVar)] <- "missing"
                
                matchLvls <- unique(matchVar[locSet$ID])
                newIDS <- which(matchVar %in% matchLvls)
                
                updateEverything(id = newIDS)
            })
            
            
            
            ii <- ii + 1
            
            
            lbl <- glabel("How do you want to select points?")
            font(lbl) <- list(weight = "bold", family = "normal")
            tbl[ii, 1:2, expand = TRUE, anchor = c(-1, 0)] <- lbl
            ii <- ii + 1
            
            
            selectMthd <- gradio(c("Click points",
                                   "Select by value of ...",
                                   "Extreme values"), selected = 1)
            tbl[ii, 1:2, expand = TRUE] <- selectMthd
            ii <- ii + 1
            
            selectGrp <- ggroup(horiz = FALSE, expand = TRUE)
            
            
            
            locator <- function(h, remove = FALSE, btn, dot = FALSE, ...) {
                x <- curSet$x  # used for removing missing values ...
                if (!dot)
                    y <- curSet$y
                v <- svalue(varmenu)
                
                w <- rep(TRUE, length(x))
                if (!is.null(curSet$g1)) {
                    if (is.null(curSet$g1.level)) {
                        cantDo()
                    } else if (curSet$g1.level == "_MULTI") {
                        cantDo()
                    }
                    w[curSet$g1 != curSet$g1.level] <- FALSE
                }
                if (!is.null(curSet$g2)) {
                    if (curSet$g2.level == "_MULTI") {
                        cantDo()
                    } else {
                        if (curSet$g2.level != "_ALL")
                            w[curSet$g2 != curSet$g2.level] <- FALSE
                    }
                }
                
                match.all <- svalue(matchChk)
                
                locVar <-
                    if (v == "id") 1:nrow(GUI$getActiveData())
                    else GUI$getActiveData()[, v]
                
                matchVar <- as.character(GUI$getActiveData()[, svalue(matchVar)])
                matchVar[is.na(matchVar)] <- "missing"
                
                ## Entire data set - ignore missing values etc etc
                d <- data.frame(x = curSet$x,
                                locate = locVar, id = 1:nrow(GUI$getActiveData()),
                                match = matchVar)
                if (!dot)
                    d$y <- curSet$y
                
                if (!is.null(curSet$g1)) {
                    w[curSet$g1 != curSet$g1.level] <- FALSE
                }
                if (!is.null(curSet$g2)) {
                    if (curSet$g2.level != "_ALL") {
                        w[curSet$g2 != curSet$g2.level] <- FALSE
                    }
                }
                
                if (dot)
                    isNA <- is.na(x)
                else
                    isNA <- is.na(x) | is.na(y)
                
                if (!is.null(curSet$g1))
                    isNA <- isNA | is.na(curSet$g1)
                if (!is.null(curSet$g2))
                    isNA <- isNA | is.na(curSet$g2)
                
                dp <- grid.get(ifelse(dot, "DOTPOINTS", "SCATTERPOINTS"))
                d <- d[w & !isNA, ]
                d$x <- as.numeric(dp$x)
                d$y <- as.numeric(dp$y)
                
                if (dot) {
                    order <- attr(GUI$curPlot[[1]][[1]]$toplot[[1]], "order")
                    d[, !colnames(d) %in% c("x", "y")] <- d[order, !colnames(d) %in% c("x", "y")]
                }        
                
                seekViewport(ifelse(dot, "VP:plotregion", "VP:locate.these.points"))
                
                blockHandlers(btn)
                oldVal <- svalue(btn)
                svalue(btn) <- "Click a point"                
                xy <- as.numeric(grid.locator())
                svalue(btn) <- oldVal
                unblockHandlers(btn)
                
                ## We only want to check X and Y for missing
                na <- apply(d[, 1:2], 1, function(x) any(is.na(x)))
                d <- d[!na, ]
                
                ## So now, d = data.frame with x, y, and the label
                ## Standardise it:
                x.s <- (d$x - min(d$x)) / (max(d$x) - min(d$x))
                y.s <- (d$y - min(d$y)) / (max(d$y) - min(d$y))
                
                xy.s <- numeric(2)
                xy.s[1] <- (xy[1] - min(d$x)) / (max(d$x) - min(d$x))
                xy.s[2] <- (xy[2] - min(d$y)) / (max(d$y) - min(d$y))
                
                o <- d[which.min((x.s - xy.s[1])^2 + (y.s - xy.s[2])^2), ]
                
                if (remove) {
                    ## Remove it
                    if (svalue(clearMulti)) {
                        rid <- which(matchVar == o[, 'match'])
                    } else {
                        rid <- o$id
                    }
                    
                    locSet$ID <<- locSet$ID[!locSet$ID %in% rid]
                    newID <- curSet$locate.id[!curSet$locate.id %in% rid]
                } else {
                    ## Store the reference ID - add it
                    
                    if (!svalue(txtLabs) & match.all) 
                        locSet$ID <<- o$id
                    else 
                        locSet$ID <<- unique(c(locSet$ID, o$id))
                    
                    ## Grab the label:
                    if (match.all) {
                        ## Match all instances of the same label:
                        pid <- which(matchVar == o[, 'match'])
                    } else {
                        pid <- o$id
                    }
                    
                    newID <- if (svalue(txtLabs) | !match.all) c(curSet$locate.id, pid) else pid
                }
                
                updateEverything(
                    locate = if (svalue(txtLabs)) locVar else NULL,
                    id = newID,
                    col = if (svalue(colLabs)) svalue(colmenu) else NULL
                )
            }
            
            if (attr(GUI$curPlot, "nplots") > 1) {
                locateButton <- glabel("Cannot locate using mouse for multiple graphs.", cont =
                                                                                             selectGrp)
                svalue(selectMthd, TRUE) <- 2
            } else if (dot & is.factor(curSet$y)) {
                locateButton <- glabel("Cannot locate when Variable 2 is a factor.", cont = selectGrp)
                svalue(selectMthd, TRUE) <- 2
            } else {
                locateButton <- gbutton("Click to Locate ...", cont = selectGrp)
                addHandlerClicked(locateButton, function(h, ...) {
                    locator(h, btn = locateButton, dot = dot)
                })
            }
            
            selectListGrp <- ggroup(FALSE, cont = selectGrp, expand = TRUE, fill = TRUE)
            
            selectList <- ggroup(TRUE, cont = selectListGrp, expand = TRUE, fill = TRUE)
            selectLab <- glabel("Variable: ", cont = selectList)
            selectVar <- gcombobox(colnames(GUI$getActiveData()), selected = 0, cont = selectList,
                                   expand = TRUE)
            
            selectSlideGrp <- ggroup(TRUE, cont = selectListGrp, expand = FALSE, fill = TRUE)
            selectGo <- gbutton("Select values ...", cont = selectList)
            
            enabled(selectGo) <- svalue(selectVar, TRUE) > 0
            addHandlerChanged(selectVar, function(h, ...) {
                enabled(selectGo) <- svalue(selectVar, TRUE) > 0
                
                selVar <- GUI$getActiveData()[, svalue(selectVar)]
                
                if (length(selectSlideGrp$children) > 0)
                    selectSlideGrp$remove_child(selectSlideGrp$children[[1]])
                
                if (is.factor(selVar) | (length(unique(selVar)) <= 20)) {
                    nn <- if (is.factor(selVar)) length(levels(selVar)) else length(unique(selVar))
                    selectSlide <- gslider(if (is.factor(selVar)) levels(selVar) else unique(selVar),
                                           cont = selectSlideGrp, expand = TRUE, fill = TRUE)
                    
                    addHandlerChanged(selectSlide, function(h, ...) {
                        ids <- which(GUI$getActiveData()[, svalue(selectVar)] == svalue(selectSlide))
                        locSet$ID <<- ids
                        
                        if (svalue(matchChk)) {
                            levs <- unique(as.character(GUI$getActiveData()[ids, svalue(matchVar)]))
                            ids <- which(GUI$getActiveData()[, svalue(matchVar)] %in% levs)
                        }
                        
                        v <- svalue(varmenu)
                        locVar <-
                            if (v == "id") 1:nrow(GUI$getActiveData())
                            else GUI$getActiveData()[, v]
                        
                        updateEverything(
                            locate = if (svalue(txtLabs)) locVar else NULL,
                            id = ids,
                            col = if (svalue(colLabs)) svalue(colmenu) else NULL
                        )
                    })
                    selectSlide$invoke_change_handler()
                }
            })
            
            
            extremeGrp <- ggroup(FALSE, cont = selectGrp, expand = TRUE, fill = TRUE)
            if (dot) {
                extremePts <- ggroup(FALSE, cont = extremeGrp, expand = TRUE, fill = TRUE)
                
                lowerG <- ggroup(cont = extremePts, expand = TRUE, fill = TRUE)
                lowerLab <- glabel("N Lower: ", cont = lowerG)
                nlowerSld <- gslider(0, 20, expand = TRUE, fill = TRUE, cont = lowerG)
                
                upperG <- ggroup(cont = extremePts, expand = TRUE, fill = TRUE)
                upperLab <- glabel("N Upper: ", cont = upperG)
                nupperSld <- gslider(0, 20, expand = TRUE, fill = TRUE, cont = upperG)
                
                updateMe <- function(h, ...) {
                    v <- svalue(varmenu)
                    locVar <- if (v == "id") 1:nrow(GUI$getActiveData()) else GUI$getActiveData()[, v]
                    updateEverything(
                        locate = if (svalue(txtLabs)) locVar else NULL,
                        id = NULL,
                        col = if (svalue(colLabs)) svalue(colmenu) else NULL,
                        ext = c(svalue(nlowerSld), svalue(nupperSld))
                    )
                    
                    enabled(addPts) <- svalue(nlowerSld) > 0 | svalue(nupperSld) > 0
                }
                addHandlerChanged(nlowerSld, updateMe)
                addHandlerChanged(nupperSld, updateMe)
            } else {
                extremePts <- ggroup(cont = extremeGrp, expand = TRUE, fill = TRUE)
                extLab <- glabel("Number of points: ", cont = extremePts)
                extN <- gslider(0, 20, cont = extremePts, expand = TRUE)
                if (!is.null(curSet$locate.extreme)) svalue(extN) <- curSet$locate.extreme
                addHandlerChanged(extN, handler = function(h, ...) {
                    v <- svalue(varmenu)
                    locVar <- if (v == "id") 1:nrow(GUI$getActiveData()) else GUI$getActiveData()[, v]
                    
                    updateEverything(
                        locate = if (svalue(txtLabs)) locVar else NULL,
                        id = NULL,
                        col = if (svalue(colLabs)) svalue(colmenu) else NULL,
                        ext = if (svalue(extN) > 0) svalue(extN) else NULL
                    )
                    enabled(addPts) <- svalue(extN) > 0
                })
            }
            addPts <- gbutton("Save these points ...", cont = extremeGrp, expand = FALSE, anchor = c(0, 1))
            enabled(addPts) <- if (dot) svalue(nlowerSld) > 0 | svalue(nupperSld) > 0 else svalue(extN) > 0
            
            extLabel <- glabel("NOTE: related points wont be located until\nyou click the above button.")
            font(extLabel) <- list(family = "normal", size = 7)
            add(extremeGrp, extLabel, anchor = c(-1, -1))
            
            addHandlerClicked(addPts, function(h, ...) {
                cp <- GUI$curPlot
                ## drop the last 3 pieces (gen, xlim, ylim)
                cp <- cp[1:(length(cp) - 3)]
                if (dot) {
                    ids <- sapply(cp, function(p) sapply(p, function(q) sapply(q$toplot, function(r) r$extreme.ids)))
                } else {
                    ids <- sapply(cp, function(p) sapply(p, function(q) q$extreme.ids))
                }
                ids <- sapply(ids[!sapply(ids, is.null)], function(x) x)
                
                locSet$ID <<- ids
                v <- svalue(varmenu)
                locVar <- if (v == "id") 1:nrow(GUI$getActiveData()) else GUI$getActiveData()[, v]
                
                if (svalue(matchChk)) {
                    mVar <- as.character(GUI$getActiveData()[, svalue(matchVar)])
                    mVar[is.na(mVar)] <- "missing"
                    mLevs <- unique(mVar[ids])
                    ids <- which(mVar %in% mLevs)
                }
                
                updateEverything(
                    locate = if (svalue(txtLabs)) locVar else NULL,
                    id = ids,
                    col = if (svalue(colLabs)) svalue(colmenu) else NULL,
                    ext = NULL
                )
                
                enabled(addPts) <- length(locSet$ID) == 0
            })
            
            if (!is.null(locSet$selectMthd))
                svalue(selectMthd) <- locSet$selectMthd
            
            
            ## Bring up a new window to allow user to select levels to label:
            addHandlerClicked(selectGo, function(h, ...) {
                ww <- gwindow("Select levels to label ...", visible = FALSE, width = 200, height = 400,
                              parent = GUI$win)
                wg <- ggroup(FALSE, cont = ww)
                wlbl <- glabel("Select levels to label\n(ctrl for multiple)", cont = wg)
                
                selectLevels <- gtable(levels(as.factor(GUI$getActiveData()[, svalue(selectVar)])),
                                       multiple = TRUE, cont = wg, expand = TRUE)
                
                wb <- gbutton("Done", cont = wg)
                addHandlerClicked(wb, function(h, ...) {
                    ids <-  which(GUI$getActiveData()[, svalue(selectVar)] %in% svalue(selectLevels))
                    locSet$ID <<- ids
                    
                    if (svalue(matchChk)) {
                        levs <- unique(as.character(GUI$getActiveData()[ids, svalue(matchVar)]))
                        ids <- which(GUI$getActiveData()[, svalue(matchVar)] %in% levs)
                    }
                    
                    v <- svalue(varmenu)
                    locVar <-
                        if (v == "id") 1:nrow(GUI$getActiveData())
                        else GUI$getActiveData()[, v]
                    
                    updateEverything(
                        locate = if (svalue(txtLabs)) locVar else NULL,
                        id = ids,
                        col = if (svalue(colLabs)) svalue(colmenu) else NULL
                    )
                    
                    dispose(ww)
                })
                visible(ww) <- TRUE
            })
            
            tbl[ii, 1:2, expand = TRUE, anchor = c(1, 0)] <- selectGrp
            ii <- ii + 1
            
            
            ii <- ii + 1
            
            clearBtn <- gbutton("Clear all labels")
            addHandlerClicked(clearBtn, function(h, ...) {
                updateEverything(NULL, NULL, NULL, NULL)
            })
            tbl[ii, 1, expand = TRUE] <- clearBtn
            
            
            clearBtn2 <- gbutton("Clear label ...")
            addHandlerClicked(clearBtn2, function(h, ...) {
                locator(h, remove = TRUE, btn = clearBtn2, dot = dot)
            })
            tbl[ii, 2, expand = TRUE] <- clearBtn2
            ii <- ii + 1
            
            clearMulti <- gcheckbox("Remove group", checked = svalue(matchChk))
            tbl[ii, 2, expand = TRUE] <- clearMulti
            ii <- ii + 1
            
            addHandlerChanged(selectMthd, function(h, ...) {
                visible(locateButton) <- svalue(selectMthd, TRUE) == 1
                visible(selectListGrp) <- svalue(selectMthd, TRUE) == 2
                visible(extremeGrp) <- svalue(selectMthd, TRUE) == 3
                
                ## enabled(matchChk) <- svalue(selectMthd, TRUE) != 3
                visible(clearBtn2) <- svalue(selectMthd, TRUE) == 1
                visible(clearMulti) <- svalue(selectMthd, TRUE) == 1
                enabled(clearMulti) <- svalue(matchChk)
            })
            selectMthd$invoke_change_handler()
            
            add(optGrp, tbl, expand = TRUE, fill = TRUE)
        },
        specifyColours = function(var) {
            if (is.numeric(var)) {
                return(NULL)
            } else {
                lvls <- levels(var)
                colWin <- gwindow("Select Colours", visible = FALSE, parent = GUI$win)
                cgrp <- gvbox(spacing = 5, container = colWin)
                cgrp$set_borderwidth(5)
                tbl <- glayout()
                jj <- 1
                
                lbl <- glabel("Select colours")
                font(lbl) <- list(weight = "bold", family = "normal", size = 9)
                tbl[jj, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
                jj <- jj + 1
                
                ## this really needs changing!!
                default.cols <- c("darkblue", "darkgreen",
                                  "darkmagenta", "darkslateblue", "hotpink4",
                                  "lightsalmon2", "palegreen3", "steelblue3")
                current.cols <- GUI$curPlot$gen$col.args$f.cols
                
                for (k in 1:length(lvls)) {
                    tbl[jj, 1, expand = TRUE, anchor = c(1, 0)] <- glabel(lvls[k])
                    tbl[jj, 2] <- gcombobox(items = c(current.cols[k], default.cols), editable = TRUE)
                    jj <- jj + 1
                }
                
                okBtn <- gbutton("OK", function(h, ...) {
                    ri <- (1:length(lvls)) + 1
                    newCols <- sapply(tbl[ri, 2], svalue)
                    
                    ## check values are valid colours:
                    OK <- sapply(newCols, function(x) {
                        sapply(x, function(X) {
                            tryCatch(is.matrix(col2rgb(X)), 
                                     error = function(e) FALSE)
                        })
                    })
                    
                    if (all(OK)) {
                        GUI$getActiveDoc()$setSettings(
                                              list(col.pt = newCols)
                                          )
                        updateSettings()
                        dispose(colWin)
                    } else {
                        gmessage(paste0("Not valid colours:\n\n",
                                        paste(newCols[!OK], collapse = ", ")),
                                 title = "Invalid Colours", icon = "error")
                    }
                })
                
                cnclBtn <- gbutton("Cancel", function(h, ...) {
                    dispose(colWin)
                })
                resetBtn <- gbutton("Reset", function(h, ...) {
                    GUI$getActiveDoc()$setSettings(
                                          list(col.pt = NULL)
                                      )
                    updateSettings()
                    dispose(colWin)
                })
                
                add(cgrp, tbl)
                addSpring(cgrp)
                
                cbtnGrp <- ggroup(cont = cgrp)
                add(cbtnGrp, resetBtn)
                
                addSpring(cbtnGrp)
                
                add(cbtnGrp, okBtn)
                addSpace(cbtnGrp, 10)
                add(cbtnGrp, cnclBtn)
                
                visible(colWin) <- TRUE
            }
        },
        sectionTitle = function(title, size = 10) {
            lbl <- glabel(title)
            font(lbl) <- list(weight = "bold", family = "normal", size = size)
            lbl
        }
    )
)


### ---------------------------------------------------------------------------------------------------
### DOT PLOT MOD WINDOW

iNZDotchartMod <- setRefClass(
    "iNZDotchartMod",
    contains = "iNZPlotModWin",
    methods = list(
        initialize = function(GUI, which = 1) {
            callSuper(GUI)
            ## need to specify the methods that we want to use in
            ## do.call later on (see changeOpts())
            usingMethods(opt1, opt2, opt3, opt4, opt5, iNZLocatePoints)
            opts <- gcombobox(c("Code more variables",
                                "Change plot appearance",
                                "Identify points",
                                "Customize Labels",
                                "Adjust axis limits"),
                              selected = which)
            add(radioGrp, opts, fill = TRUE, expand = TRUE)
            eval(parse(text = paste0("opt", which, "()")))
            addHandlerChanged(opts,
                              handler = function(h, ...) {
                                  changeOpts(svalue(h$obj,
                                                    index = TRUE))
                              })
        },
        changeOpts = function(index) {
            ## delete current displayed options
            invisible(sapply(optGrp$children, function(x) delete(optGrp, x)))
            do.call(paste("opt", index, sep=""),
                    args = list())
        },
        ## Following are the different views for the indices of the
        ## gradio
        opt1 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl1 <- glabel("Code More Variables")
            font(lbl1) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl1
            ii <- ii + 1
            
            lbl2 <- glabel("Colour by :")
            grpVarList <- gcombobox(c("", names(GUI$getActiveData())),
                                    selected = ifelse(
                                        is.null(curSet$colby),
                                        1, which(names(GUI$getActiveData()) ==
                                                     curSet$varnames$colby)[1] + 1
                                        )
                                    )
            
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl2
            tbl[ii, 2, expand = TRUE] <- grpVarList
            ii <- ii + 1

            lvlCols <- gbutton("Specify colours")
            tbl[ii, 2, expand = TRUE] <- lvlCols
            visible(lvlCols) <- svalue(grpVarList, index = TRUE) != 1
            ii <- ii + 1

            addHandlerClicked(lvlCols, function(h, ...) {
                variable <- GUI$getActiveData()[, svalue(grpVarList, index = FALSE)]
                if (is.numeric(variable)) {
                    gmessage("Set colour of numeric ... not yet implemented.", "Not ready yet.", icon = "warning")
                } else {
                    specifyColours(variable)
                }                
            })


            ## Maintain a single function that is called whenever anything is updated:
            updateEverything <- function() {
                GUI$getActiveDoc()$setSettings(
                    list(colby = GUI$getActiveData()[[
                             svalue(grpVarList)]],
                         varnames = list(
                             colby = svalue(grpVarList)))
                    )
                updateSettings()
            }
            
            ## in this case, no point in having a separate "show" button
            addHandlerChanged(grpVarList,
                              handler = function(h, ...) {
                                  if (svalue(grpVarList, index = TRUE) == 1) {
                                      updateEverything()
                                      visible(lvlCols) <- FALSE
                                  } else {
                                      var <- GUI$getActiveData()[[svalue(grpVarList)]]
                                      if (length(unique(var)) <= 1) {
                                          visible(lvlCols) <- FALSE
                                          gmessage(paste("The variable", svalue(grpVarList),
                                                         "only has one unique value, so colouring by it wont work."),
                                                   icon = "warning", title = "Invalid variable")
                                      } else {
                                          updateEverything()
                                          visible(lvlCols) <- is.factor(var)
                                      }
                                  }
                              })
            
            add(optGrp, tbl)
        },
        ## Change Plot appearance
        opt2 = function() {
            tbl <- glayout()
            ii <- 3

            ## Default settings
            defts <- iNZightPlots:::inzpar()
            
            ## PLOT APPEARANCE
            lbl <- glabel("Change plot appearance")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii,  1:2, anchor = c(-1,-1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            ## PLOT TYPE
            lbl <- glabel("Plot Type :")
            
            plotTypes <- c("default", "dot plot", "histogram")
            plotTypeValues <- list("default", "dot", "hist")
            plotTypeList <- gcombobox(
                plotTypes,
                selected = which(plotTypeValues == curSet$plottype)
                )
            
            addHandlerChanged(plotTypeList, handler = function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(plottype = plotTypeValues[[svalue(plotTypeList, index = TRUE)]])
                    )
                updateSettings()

                plType <- svalue(plotTypeList, index = TRUE)
                if (plType == 3 | (plType == 1 & GUI$plotType == "hist")) {
                    iNZHistogramMod$new(GUI, which = 1)
                }
            })
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- plotTypeList
            ii <- ii + 1


            ## BACKGROUND COLOUR
            lbl <- glabel("Background colour :")
            
            backgroundCols <- c(defts$bg, "antiquewhite",
                                "azure3", "bisque", "cornsilk", "darkolivegreen2",
                                "darkslategray1", "greenyellow", "lightblue1",
                                "lightpink", "rosybrown1", "slategray1", "thistle1",
                                "wheat1")
            backgroundColList <- gcombobox(
                backgroundCols,
                selected = ifelse(
                    is.na(which(backgroundCols == curSet$bg)[1]),
                    1,
                    which(backgroundCols == curSet$bg)[1]),
                editable = TRUE)
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- backgroundColList
            ii <- ii + 1


            ## ## SYMBOL OPTIONS
            ii <- ii + 1
            lbl <- glabel("Symbol options")
            font(lbl) <- list(weight="bold", family = "normal", size = 8)
            tbl[ii, 1:2, anchor = c(-1,-1), expand = TRUE] <- lbl
            ii <- ii + 1

            ## COLOUR            
            lbl <- glabel("Colour :")
            pointCols <- c(defts$col.pt, "darkblue", "darkgreen",
                           "darkmagenta", "darkslateblue", "hotpink4",
                           "lightsalmon2", "palegreen3", "steelblue3")
            symbolColList <- gcombobox(
                pointCols,
                selected = ifelse(
                    is.na(which(pointCols == curSet$col.pt)[1]),
                    1,
                    which(pointCols == curSet$col.pt)[1]),
                editable = TRUE)

            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- symbolColList
            ii <- ii + 1

            lbl <- glabel("NOTE: You can type in a colour if it is not listed.")
            
            ## if the "colby" options is set, i.e. points are colored
            ## according to another var, disable the option to
            ## change the color
            if (!is.null(GUI$getActiveDoc()$getSettings()$colby)) {
                enabled(symbolColList) <- FALSE
                svalue(lbl) <- paste(
                    "Changing the color of symbols is disabled since\n",
                    "the symbols are colored by '",
                    GUI$getActiveDoc()$getSettings()$varnames$colby,
                    "'", sep = "")
            }
            font(lbl) <- list(family = "normal", size = 8)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl                
            ii <- ii + 1

            ## FILL
            fillColor <- gcheckbox("Colour interior",
                                   checked = (curSet$pch != 1))
            tbl[ii,  2, expand = TRUE] <- fillColor
            ii <- ii + 1
            
            ## SIZE
            lbl <- glabel("Size :")
            cexSlider <- gslider(from = 0.05, to = 3.5,
                                 by = 0.05, value = curSet$cex.dotpt)
            tbl[ii, 1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- cexSlider
            ii <- ii + 1
            
            ## Transparency
            lbl <- glabel("Transparency :")
            transpSlider <- gslider(from = 0, to = 100,
                                    by = 1, value = 100 * (1 - curSet$alpha))
            tbl[ii, 1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- transpSlider
            ii <- ii + 1

            updateEverything <- function(update = auto) {
                ## To easily diable automatic updating of plot, add this argument,
                ## otherwise would have to block/unblock handlers
                if (!update)
                    return()
                
                pch.sel <- ifelse(svalue(fillColor) | svalue(transpSlider) > 0,
                                  19, 1)
                GUI$getActiveDoc()$setSettings(
                    list(col.pt = svalue(symbolColList),
                         bg = svalue(backgroundColList),
                         cex.dotpt = svalue(cexSlider),
                         pch = pch.sel,
                         alpha = 1 - svalue(transpSlider) / 100,
                         fill.pt =
                             ifelse(svalue(transpSlider) == 0,
                                    svalue(fillColor),
                                    svalue(symbolColList))
                         ))
                updateSettings()
            }

            ii <- ii + 1
            showButton <- gbutton("Show Changes",
                                  handler = function(h, ...) updateEverything(TRUE))
            if (auto) {
                bcoltimer <- NULL
                addHandlerChanged(backgroundColList,
                                  handler = function(h, ...) {
                                      if (!is.null(bcoltimer))
                                          bcoltimer$stop_timer()
                                      bcoltimer <- gtimer(500, function(...) {
                                                               if (nchar(svalue(backgroundColList)) >= 3)
                                                                   updateEverything()
                                                           }, one.shot = TRUE)
                                  })

                ## This one needs to be deactivated if user is typing:
                pcoltimer <- NULL
                addHandlerChanged(symbolColList,
                                  handler = function(h, ...) {
                                      if (!is.null(pcoltimer))
                                          pcoltimer$stop_timer()
                                      pcoltimer <- gtimer(500, function(...) {
                                                               if (nchar(svalue(symbolColList)) >= 3)
                                                                   updateEverything()
                                                           }, one.shot = TRUE)
                                  })
 
                addHandlerChanged(fillColor,
                                  handler = function(h, ...) updateEverything())
                
                cextimer <- NULL
                addHandlerChanged(cexSlider,
                                  handler = function(h, ...) {
                                      if (!is.null(cextimer))
                                          cextimer$stop_timer()
                                      cextimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })

                transptimer <- NULL
                addHandlerChanged(transpSlider,
                                  handler = function(h, ...) {
                                      if (!is.null(transptimer))
                                          transptimer$stop_timer()
                                      transptimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })

                autoCheck <- gcheckbox("Update automatically", checked = auto)
                tbl[ii, 1:2, expand = TRUE] <- autoCheck
                ii <- ii + 1

                addHandlerChanged(autoCheck, handler = function(h, ...) {
                                                 enabled(showButton) <- !svalue(autoCheck)
                                                 auto <<- svalue(autoCheck)
                                             })
            }
            
            
            tbl[ii, 1:2, expand = TRUE] <- showButton
            enabled(showButton) <- !auto
            
            add(optGrp, tbl)
        },
        opt3 = function() {
            iNZLocatePoints(TRUE)
            return()
            
            if (attr(GUI$curPlot, "nplots") > 1 | !is.null(curSet$y)) {
                tbl1 <- glayout()
                tbl1[1, 1] <- glabel("Cannot identify points for this type of plot.")
                add(optGrp, tbl1)
                return()
            }
                
            ## Do checking first
            ## If g1 or g2 = _MULTI, then we can't identify points (yet ...)
            cantDo <- function(msg = "using subsetting variables.") {
                gmessage(paste("Cannot identify points when", msg),
                         icon = "error", title = "Unable to identify",
                         parent = modWin)
                return()
            }
            

            lbl1 <- "Select variable to identify:"
            font(lbl1) <- list(weight="bold", family = "normal")
            varmenu <- gcombobox(c("id", names(GUI$getActiveData())), selected = 1)

            
            lbl2 <- "Select points by: "
            selOpts <- gradio(c("mouse click", "min/max N points"),
                              selected = 1, horizontal = FALSE)
            minPts <- gcheckbox("Minimum", checked = TRUE, )
            enabled(minPts) <- FALSE
            maxPts <- gcheckbox("Maximum", checked = TRUE)
            enabled(maxPts) <- FALSE
            nlbl <- "N ="
            nPts <- gedit("5", width = 3)
            enabled(nPts) <- FALSE

            
            locateButton <- gbutton("Locate",
                                    handler = function(h, ...) {
                                        
                                        x <- curSet$x  # used for removing missing values ...
                                        y <- curSet$y
                                        v <- svalue(varmenu)
                                    
                                        w <- rep(TRUE, length(x))
                                        if (!is.null(curSet$g1)) {
                                            if (is.null(curSet$g1.level)) {
                                                cantDo()
                                            } else if (curSet$g1.level == "_MULTI") {
                                                cantDo()
                                            }
                                            w[curSet$g1 != curSet$g1.level] <- FALSE
                                        }
                                        if (!is.null(curSet$g2)) {
                                            if (curSet$g2.level == "_MULTI") {
                                                cantDo()
                                            } else {
                                                if (curSet$g2.level != "_ALL")
                                                    w[curSet$g2 != curSet$g2.level] <- FALSE
                                            }
                                        }
                                        if (is.factor(y))
                                            cantDo("when Variable 2 is a factor.")
                                        
                                        if (is.null(v))
                                            v <- as.character(1:length(x))
                                        else {
                                            if (v == "id")
                                                v <- as.character(1:length(x))
                                            else {
                                                v <- as.character(GUI$getActiveData()[, v])
                                                v[is.na(v)] <- "missing"
                                            }
                                        }

                                       
                                        
                                        seekViewport("VP:locate.these.points")

                                        isNA <- is.na(x)
                                        if (!is.null(curSet$g1))
                                            isNA <- isNA | is.na(curSet$g1)
                                        if (!is.null(curSet$g2))
                                            isNA <- isNA | is.na(curSet$g2)

                                            
                                        dp <- grid.get("DOTPOINTS")

                                        # these are the points, but not in the correct order ...
                                        d <- data.frame(x = as.numeric(dp$x),
                                                        y = as.numeric(dp$y),
                                                        v = v[w & !isNA])

                                        order <- attr(GUI$curPlot[[1]][[1]]$toplot[[1]], "order")
                                        d$v <- d$v[order]
                                        
                                        seekViewport("VP:plotregion")  # need correct coordinate system
                                                                               
                                        # FOR TESTING:
                                        mmPoints <- svalue(selOpts, index = TRUE) == 2
                                        if (mmPoints) {
                                            Npts <- as.numeric(svalue(nPts))
                                            if (is.na(Npts)) {
                                                gmessage("Please specify a numeric value for Number of Points.")
                                                return()
                                            }
                                            
                                            Wpts <- sum(svalue(minPts), 2 * svalue(maxPts))
                                            if (Wpts == 0) {
                                                gmessage("Please select either Minimum of Maximum points to identify.")
                                                return()
                                            }
                                            if (Wpts == 3) Wpts <- c(1, 2)
                                            
                                            if (any(Wpts == 1)) {
                                                o <- d[order(d$x, decreasing = FALSE), ][1:Npts, ]
                                                apply(o, 1, function(r) {
                                                    tt <- r[3]
                                                    or <- as.numeric(r[1:2])
                                                    grid.text(tt,
                                                              or[1] + convertWidth(unit(0.5, "char"), "native", TRUE),
                                                              or[2] + convertWidth(unit(0.5, "char"), "native", TRUE),
                                                              just = "left", rot = 45,
                                                              default.units = "native", gp = gpar(cex = 0.7))
                                                })
                                            }
                                            if (any(Wpts == 2)) {
                                                o <- d[order(d$x, decreasing = TRUE), ][1:Npts, ]
                                                apply(o, 1, function(r) {
                                                    tt <- r[3]
                                                    or <- as.numeric(r[1:2])
                                                    grid.text(tt,
                                                              or[1] + convertWidth(unit(0.5, "char"), "native", TRUE),
                                                              or[2] + convertWidth(unit(0.5, "char"), "native", TRUE),
                                                              just = "left", rot = 45,
                                                              default.units = "native", gp = gpar(cex = 0.7))
                                                })
                                            }
                                            
                                            
                                        } else {
                                            xy <- as.numeric(grid.locator())
                                            
                                            
                                            ## We only want to check X and Y for missing
                                            na <- apply(d[, 1:2], 1, function(x) any(is.na(x)))
                                            d <- d[!na, ]
                                            
                                            ## So now, d = data.frame with x, y, and the label
                                            ## Standardise it:
                                            ## However, need to be careful if only one unique X or Y value:
                                            
                                            if (diff(range(d$x)) == 0)
                                                x.s <- rep(0, length(d$x))
                                            else
                                                x.s <- (d$x - min(d$x)) / (max(d$x) - min(d$x))
                                            
                                            if (diff(range(d$y)) == 0)
                                                y.s <- rep(0, length(d$y))
                                            else
                                                y.s <- (d$y - min(d$y)) / (max(d$y) - min(d$y))
                                            
                                            xy.s <- numeric(2)
                                            if (diff(range(d$x)) == 0)
                                                xy.s[1] <- xy[1]
                                            else
                                                xy.s[1] <- (xy[1] - min(d$x)) / (max(d$x) - min(d$x))
                                            
                                            if (diff(range(d$y)) == 0)
                                                xy.s[2] <- xy[2]
                                            else
                                                xy.s[2] <- (xy[2] - min(d$y)) / (max(d$y) - min(d$y))

                                            o <- d[which.min((x.s - xy.s[1])^2 + (y.s - xy.s[2])^2), ]
                                            
                                            grid.text(o$v,
                                                      o$x + convertWidth(unit(0.5, "char"), "native", TRUE),
                                                      o$y + convertWidth(unit(0.5, "char"), "native", TRUE),
                                                      just = "left", rot = 45,
                                                      default.units = "native", gp = gpar(cex = 0.7))
                                        }
                                        
                                    })

            tbl1 <- glayout()
            tbl2 <- glayout()
            tbl3 <- glayout()

            lbl <- glabel("Identify Points")
            font(lbl) <- list(weight = "bold", family = "normal", size = 9)
            tbl1[3, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            
            tbl1[4, 1, expand = TRUE, anchor = c(-1, 0)] <- lbl1
            tbl1[4, 2, expand = TRUE, anchor = c(1, 0)] <- varmenu
            tbl1[5, 1, expand = FALSE, anchor = c(1, 1)] <- lbl2
            tbl1[5, 2] <- selOpts

            tbl2[2, 1] <- minPts
            tbl2[2, 2] <- maxPts
            tbl2[2, 3] <- nlbl
            tbl2[2, 4] <- nPts
            
            tbl3[2, 1, expand = TRUE] <- locateButton

            add(optGrp, tbl1)
            add(optGrp, tbl2)
            add(optGrp, tbl3)

            ## Some things to change values ...
            addHandlerChanged(selOpts, handler = function(h, ...) {
                if (svalue(selOpts, index = TRUE) == 1) {
                    enabled(minPts) <- FALSE
                    enabled(maxPts) <- FALSE
                    enabled(nPts) <- FALSE
                } else {
                    enabled(minPts) <- TRUE
                    enabled(maxPts) <- TRUE
                    enabled(nPts) <- TRUE
                }
            })
        },
        opt4 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Customize Labels")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            

            curPlSet <- GUI$getActiveDoc()$getSettings()
            oldMain <- curPlSet$main
            oldX <- curPlSet$xlab
            if (is.null(oldMain)) oldMain <- ''
            if (is.null(oldX)) oldX <- ''

            lbl    <- glabel("Main title :")
            labMain <- gedit(oldMain)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labMain
            ii <- ii + 1
            
            lbl    <- glabel("x-axis label :")
            labX    <- gedit(oldX)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labX
            ii <- ii + 1
            

            lbl <- glabel("Enter a single space to print no label\nLeave blank to print default label")
            font(lbl) <- list(family = "normal",
                               size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            lbl <- glabel("Press ENTER/RETURN to apply changes")
            font(lbl) <- list(family = "normal", size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 2

            
            lbl <- glabel("Group labels (\"y-axis\")")
            font(lbl) <- list(weight = "bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            intLabs <- gcheckbox("Display inside graph (if labels aren't showing, check this box)",
                                 checked = !curSet$internal.labels)
            tbl[ii, 1:2, anchor = c(-1, -1), expand= TRUE] <- intLabs
            ii <- ii + 1

            
            updateEverything <- function() {
                mlab <- svalue(labMain)
                xlab <- svalue(labX)
                GUI$getActiveDoc()$setSettings(
                    list(main = if (mlab != '') mlab else NULL,
                         xlab = if (xlab != '') xlab else NULL,
                         internal.labels = !svalue(intLabs))
                    )
                updateSettings()
            }
            
            addHandlerChanged(labMain, handler = function(h, ...) updateEverything())
            addHandlerChanged(labX, handler = function(h, ...) updateEverything())
            addHandlerClicked(intLabs, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Adjust axis limits
        opt5 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Adjust Axis Limits")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            pl <- GUI$curPlot
            xlim <- if (is.null(curSet$xlim))
                pl$xlim
            else
                curSet$xlim
           
            lbl <- glabel("x-axis: ")
            xlower <- gedit(xlim[1])
            xupper <- gedit(xlim[2])
            tbl[ii, 1, expand = TRUE, fill = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- xlower
            tbl[ii, 3, expand = TRUE] <- xupper
            ii <- ii + 1


            errlbl <- glabel("Limits must be numbers.")
            tbl[ii, 1:3] <- errlbl
            visible(errlbl) <- FALSE

            updateEverything <- function() {
                err <- FALSE
                xl <- suppressWarnings(as.numeric(svalue(xlower)))
                if (is.na(xl)) {
                    xl <- xlim[1]
                    err <- TRUE
                }
                xu <- suppressWarnings(as.numeric(svalue(xupper)))
                if (is.na(xu)) {
                    xu <- xlim[2]
                    err <- TRUE
                }

                visible(errlbl) <- err
                    
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(xlim = c(xl, xu))
                    )
                updateSettings()
            }

            timer <- NULL
            updT <- function(h, ...) {
                if (!is.null(timer))
                    timer$stop_timer()
                timer <- gtimer(800, function(...) updateEverything(), one.shot = TRUE)
            }
            addHandlerKeystroke(xlower, updT)
            addHandlerKeystroke(xupper, updT)
            
            add(optGrp, tbl)

            resetGrp <- ggroup(cont = optGrp)
            addSpring(resetGrp)
            resetbtn <- gbutton("Reset", cont = resetGrp)
            addHandlerClicked(resetbtn, function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(xlim = NULL)
                    )
                updateSettings()

                ## reset the values in the boxes:
                pl <- GUI$curPlot
                xlim <-pl$xlim

                svalue(xlower) <- xlim[1]
                svalue(xupper) <- xlim[2]
            })
        })
    )



### ---------------------------------------------------------------------------------------------------
### HISOGRAM MOD WINDOW

iNZHistogramMod <- setRefClass(
    "iNZHistogramMod",
    contains = "iNZPlotModWin",
    methods = list(
        initialize = function(GUI, which = 1) {
            callSuper(GUI)
            ## need to specify the methods that we want to use in
            ## do.call later on (see changeOpts())
            usingMethods(opt1, opt2, opt3)
            opts <- gcombobox(c("Change plot appearance",
                                "Customize Labels",
                                "Adjust axis limits"),
                              selected = which)
            add(radioGrp, opts, expand = TRUE, fill = TRUE)
            eval(parse(text = paste0("opt", which, "()")))
            addHandlerChanged(opts,
                              handler = function(h, ...) {
                                  changeOpts(svalue(h$obj,
                                                    index = TRUE))
                              })
        },
        changeOpts = function(index) {
            ## delete current displayed options
            invisible(sapply(optGrp$children, function(x) delete(optGrp, x)))
            do.call(paste("opt", index, sep=""),
                    args = list())
        },
        ## Following are the different views for the indices of the
        ## gradio

        ## Change Plot appearance
        opt1 = function() {
            tbl <- glayout()
            ii <- 3

            ## Default settings
            defts <- iNZightPlots:::inzpar()
            
            ## PLOT APPEARANCE
            lbl <- glabel("Change plot appearance")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii,  1:2, anchor = c(-1,-1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            ## PLOT TYPE
            lbl <- glabel("Plot Type :")
            
            plotTypes <- c("default", "dot plot", "histogram")
            plotTypeValues <- list("default", "dot", "hist")
            plotTypeList <- gcombobox(
                plotTypes,
                selected = which(plotTypeValues == curSet$plottype)
                )
            
            addHandlerChanged(plotTypeList, handler = function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(plottype = plotTypeValues[[svalue(plotTypeList, index = TRUE)]])
                    )
                updateSettings()

                plType <- svalue(plotTypeList, index = TRUE)
                if (plType == 2 | (plType == 1 & GUI$plotType == "dot")) {
                    iNZDotchartMod$new(GUI, which = 2)
                }
            })
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- plotTypeList
            ii <- ii + 1


            ## BACKGROUND COLOUR
            lbl <- glabel("Background colour :")
            
            backgroundCols <- c(defts$bg, "antiquewhite",
                                "azure3", "bisque", "cornsilk", "darkolivegreen2",
                                "darkslategray1", "greenyellow", "lightblue1",
                                "lightpink", "rosybrown1", "slategray1", "thistle1",
                                "wheat1")
            backgroundColList <- gcombobox(
                backgroundCols,
                selected = ifelse(
                    is.na(which(backgroundCols == curSet$bg)[1]),
                    1,
                    which(backgroundCols == curSet$bg)[1]),
                editable = TRUE)
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- backgroundColList
            ii <- ii + 1
            

            ## COLOUR            
            lbl <- glabel("Bar colour :")
            barCols <- c(defts$bar.fill, "darkblue", "darkgreen",
                           "darkmagenta", "darkslateblue", "hotpink4",
                           "lightsalmon2", "palegreen3", "steelblue3")
            barColList <- gcombobox(
                barCols,
                selected = ifelse(
                    is.na(which(barCols == curSet$bar.fill)[1]),
                    1,
                    which(barCols == curSet$bar.fill)[1]),
                editable = TRUE)

            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- barColList
            ii <- ii + 1

            lbl <- glabel("NOTE: You can type in a colour if it is not listed.")
            
            font(lbl) <- list(family = "normal", size = 8)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl                
            ii <- ii + 1

            
            ## Number of bars
            ii <- ii + 1
            lbl <- glabel("Number of bars :")

            adjBins <- gcheckbox("Manually adjust the number of bars",
                                 checked = !is.null(curSet$hist.bins))
            binSlider <- gslider(from = 5, to = 200,
                                 by = 1, value = curSet$hist.bins)
            enabled(binSlider) <- svalue(adjBins)

            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- adjBins
            ii <- ii + 1
            
            tbl[ii, 1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- binSlider
            ii <- ii + 1
            

            updateEverything <- function(update = auto) {
                ## To easily diable automatic updating of plot, add this argument,
                ## otherwise would have to block/unblock handlers
                if (!update)
                    return()
                
                GUI$getActiveDoc()$setSettings(
                    list(bar.fill = svalue(barColList),
                         bg = svalue(backgroundColList),
                         hist.bins = if (svalue(adjBins)) svalue(binSlider) else NULL
                         ))
                updateSettings()
            }

            ii <- ii + 1
            showButton <- gbutton("Show Changes",
                                  handler = function(h, ...) updateEverything(TRUE))
            if (auto) {
                bcoltimer <- NULL
                addHandlerChanged(backgroundColList,
                                  handler = function(h, ...) {
                                      if (!is.null(bcoltimer))
                                          bcoltimer$stop_timer()
                                      bcoltimer <- gtimer(500, function(...) {
                                                               if (nchar(svalue(backgroundColList)) >= 3)
                                                                   updateEverything()
                                                           }, one.shot = TRUE)
                                  })

                ## This one needs to be deactivated if user is typing:
                pcoltimer <- NULL
                addHandlerChanged(barColList,
                                  handler = function(h, ...) {
                                      if (!is.null(pcoltimer))
                                          pcoltimer$stop_timer()
                                      pcoltimer <- gtimer(500, function(...) {
                                                               if (nchar(svalue(barColList)) >= 3)
                                                                   updateEverything()
                                                           }, one.shot = TRUE)
                                  })

                addHandlerChanged(adjBins,
                                  handler = function(h, ...) {
                                      enabled(binSlider) <- svalue(adjBins)
                                      updateEverything()
                                  })
                
                cextimer <- NULL
                addHandlerChanged(binSlider,
                                  handler = function(h, ...) {
                                      if (!is.null(cextimer))
                                          cextimer$stop_timer()
                                      cextimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })

                autoCheck <- gcheckbox("Update automatically", checked = auto)
                tbl[ii, 1:2, expand = TRUE] <- autoCheck
                ii <- ii + 1

                addHandlerChanged(autoCheck, handler = function(h, ...) {
                                                 enabled(showButton) <- !svalue(autoCheck)
                                                 auto <<- svalue(autoCheck)
                                             })
            }
            
            
            tbl[ii, 1:2, expand = TRUE] <- showButton
            enabled(showButton) <- !auto
            
            add(optGrp, tbl)
        },
        opt2 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Customize Labels")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            

            curPlSet <- GUI$getActiveDoc()$getSettings()
            oldMain <- curPlSet$main
            oldX <- curPlSet$xlab
            if (is.null(oldMain)) oldMain <- ''
            if (is.null(oldX)) oldX <- ''

            lbl    <- glabel("Main title :")
            labMain <- gedit(oldMain)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labMain
            ii <- ii + 1
            
            lbl    <- glabel("x-axis label :")
            labX    <- gedit(oldX)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labX
            ii <- ii + 1
            

            lbl <- glabel("Enter a single space to print no label\nLeave blank to print default label")
            font(lbl) <- list(family = "normal",
                               size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            lbl <- glabel("Press ENTER/RETURN to apply changes")
            font(lbl) <- list(family = "normal", size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl

            
            lbl <- glabel("Group labels (\"y-axis\")")
            font(lbl) <- list(weight = "bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            intLabs <- gcheckbox("Display inside graph (if labels aren't showing, check this box)",
                                 checked = !curSet$internal.labels)
            tbl[ii, 1:2, anchor = c(-1, -1), expand= TRUE] <- intLabs
            ii <- ii + 1

            
            updateEverything <- function() {
                mlab <- svalue(labMain)
                xlab <- svalue(labX)
                GUI$getActiveDoc()$setSettings(
                    list(main = if (mlab != '') mlab else NULL,
                         xlab = if (xlab != '') xlab else NULL,
                         internal.labels = !svalue(intLabs))
                    )
                updateSettings()
            }
            
            addHandlerChanged(labMain, handler = function(h, ...) updateEverything())
            addHandlerChanged(labX, handler = function(h, ...) updateEverything())
            addHandlerClicked(intLabs, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Adjust axis limits
        opt3 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Adjust Axis Limits")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            pl <- GUI$curPlot
            xlim <- if (is.null(curSet$xlim))
                        pl$xlim
                    else
                        curSet$xlim
           
            lbl <- glabel("x-axis: ")
            xlower <- gedit(xlim[1])
            xupper <- gedit(xlim[2])
            tbl[ii, 1, expand = TRUE, fill = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- xlower
            tbl[ii, 3, expand = TRUE] <- xupper
            ii <- ii + 1


            errlbl <- glabel("Limits must be numbers.")
            tbl[ii, 1:3] <- errlbl
            visible(errlbl) <- FALSE

            updateEverything <- function() {
                err <- FALSE
                xl <- suppressWarnings(as.numeric(svalue(xlower)))
                if (is.na(xl)) {
                    xl <- xlim[1]
                    err <- TRUE
                }
                xu <- suppressWarnings(as.numeric(svalue(xupper)))
                if (is.na(xu)) {
                    xu <- xlim[2]
                    err <- TRUE
                }

                visible(errlbl) <- err
                    
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(xlim = c(xl, xu))
                    )
                updateSettings()
            }

            timer <- NULL
            updT <- function(h, ...) {
                if (!is.null(timer))
                    timer$stop_timer()
                timer <- gtimer(800, function(...) updateEverything(), one.shot = TRUE)
            }
            addHandlerKeystroke(xlower, updT)
            addHandlerKeystroke(xupper, updT)
            
            add(optGrp, tbl)

            resetGrp <- ggroup(cont = optGrp)
            addSpring(resetGrp)
            resetbtn <- gbutton("Reset", cont = resetGrp)
            addHandlerClicked(resetbtn, function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(xlim = NULL)
                    )
                updateSettings()

                ## reset the values in the boxes:
                pl <- GUI$curPlot
                xlim <-pl$xlim

                svalue(xlower) <- xlim[1]
                svalue(xupper) <- xlim[2]
            })
        })
    )





### ---------------------------------------------------------------------------------------------------
### BAR PLOT MOD WINDOW

iNZBarchartMod <- setRefClass(
    "iNZBarchartMod",
    contains = "iNZPlotModWin",
    methods = list(
        initialize = function(GUI, which = 1) {
            callSuper(GUI)
            ## need to specify the methods that we want to use in
            ## do.call later on (see changeOpts())

            if (is.null(curSet$y)) {
                usingMethods(opt1, opt2, opt3, opt4)
                opts <- gcombobox(c("Code more variables",
                                    "Change plot appearance",
                                    "Customize Labels",
                                    "Adjust number of Bars"),
                                  selected = which)
            } else {
                usingMethods(opt2, opt3, opt4)
                which <- ifelse(which == 1, 2, which)
                opts <- gcombobox(c("Change plot appearance",
                                    "Customize Labels",
                                    "Adjust number of Bars"),
                                  selected = which - 1)
            }
            add(radioGrp, opts, fill = TRUE, expand = TRUE)
            eval(parse(text = paste0("opt", which, "()")))
            addHandlerChanged(opts,
                              handler = function(h, ...) {
                                  changeOpts(svalue(h$obj, index = TRUE) + !is.null(curSet$y))
                              })
        },
        changeOpts = function(index) {
            ## delete current displayed options
            invisible(sapply(optGrp$children, function(x) delete(optGrp, x)))
            do.call(paste("opt", index, sep=""),
                    args = list())
        },
        ## Following are the different views for the indices of the
        ## gradio
        opt1 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl1 <- glabel("Code More Variables")
            font(lbl1) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl1
            ii <- ii + 1
            
            lbl2 <- glabel("Colour by :")
            grpVarList <- gcombobox(c("",
                                      names(GUI$getActiveData())[sapply(GUI$getActiveData(),
                                                                        is.factor)]),
                                    selected = ifelse(
                                        is.null(curSet$colby),
                                        1, which(names(GUI$getActiveData())[sapply(GUI$getActiveData(),
                                                                                   is.factor)] ==
                                                     curSet$varnames$colby)[1] + 1
                                        )
                                    )
            
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl2
            tbl[ii, 2, expand = TRUE] <- grpVarList
            ii <- ii + 1


            ## Maintain a single function that is called whenever anything is updated:
            updateEverything <- function() {
                GUI$getActiveDoc()$setSettings(
                    list(colby = GUI$getActiveData()[[
                             svalue(grpVarList)]],
                         varnames = list(
                             colby = svalue(grpVarList)))
                    )
                updateSettings()
            }
            
            ## in this case, no point in having a separate "show" button
            addHandlerChanged(grpVarList,
                              handler = function(h, ...) {
                                  updateEverything()
                              })
            
            add(optGrp, tbl)
        },
        ## Change Plot appearance
        opt2 = function() {
            tbl <- glayout()
            ii <- 3

            ## Default settings
            defts <- iNZightPlots:::inzpar()
            
            ## PLOT APPEARANCE
            lbl <- glabel("Change plot appearance")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii,  1:2, anchor = c(-1,-1), expand = TRUE] <- lbl
            ii <- ii + 1


            ## BACKGROUND COLOUR
            lbl <- glabel("Background colour :")
            
            backgroundCols <- c(defts$bg, "antiquewhite",
                                "azure3", "bisque", "cornsilk", "darkolivegreen2",
                                "darkslategray1", "greenyellow", "lightblue1",
                                "lightpink", "rosybrown1", "slategray1", "thistle1",
                                "wheat1")
            backgroundColList <- gcombobox(
                backgroundCols,
                selected = ifelse(
                    is.na(which(backgroundCols == curSet$bg)[1]),
                    1,
                    which(backgroundCols == curSet$bg)[1]),
                editable = TRUE)
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- backgroundColList
            ii <- ii + 1


            ## COLOUR
            lbl <- glabel("Bar colour :")
            barCols <- c(defts$bar.fill, "darkblue", "darkgreen",
                         "darkmagenta", "darkslateblue", "hotpink4",
                         "lightsalmon2", "palegreen3", "steelblue3")
            barColList <- gcombobox(
                barCols,
                selected = ifelse(
                    is.na(which(barCols == curSet$bar.fill)[1]),
                    1,
                    which(barCols == curSet$bar.fill)[1]),
                editable = TRUE)

            if (is.null(curSet$y)) {
                tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
                tbl[ii,  2, expand = TRUE] <- barColList
                ii <- ii + 1
            }

            lbl <- glabel("NOTE: You can type in a colour if it is not listed.")

            if (is.null(curSet$y)) {
                ## if the "colby" options is set, i.e. points are colored
                ## according to another var, disable the option to
                ## change the color
                if (!is.null(GUI$getActiveDoc()$getSettings()$colby)) {
                    enabled(barColList) <- FALSE
                    svalue(lbl) <- paste(
                        "Changing the bar color is disabled since\n",
                        "the bars are colored by '",
                        GUI$getActiveDoc()$getSettings()$varnames$colby,
                        "'", sep = "")
                }
                font(lbl) <- list(family = "normal", size = 8)
                tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl                
                ii <- ii + 1
            }
            
            updateEverything <- function(update = auto) {
                ## To easily diable automatic updating of plot, add this argument,
                ## otherwise would have to block/unblock handlers
                if (!update)
                    return()
                
                GUI$getActiveDoc()$setSettings(
                    list(bar.fill = svalue(barColList),
                         bg = svalue(backgroundColList)
                         ))
                updateSettings()
            }

            ii <- ii + 1

            bcoltimer <- NULL
            addHandlerChanged(backgroundColList,
                              handler = function(h, ...) {
                                  if (!is.null(bcoltimer))
                                      bcoltimer$stop_timer()
                                  bcoltimer <- gtimer(500, function(...) {
                                                          if (nchar(svalue(backgroundColList)) >= 3)
                                                              updateEverything()
                                                      }, one.shot = TRUE)
                              })

            if (is.null(curSet$y)) {
                pcoltimer <- NULL
                addHandlerChanged(barColList,
                                  handler = function(h, ...) {
                                      if (!is.null(pcoltimer))
                                          pcoltimer$stop_timer()
                                      pcoltimer <- gtimer(500, function(...) {
                                                              if (nchar(svalue(barColList)) >= 3)
                                                                  updateEverything()
                                                          }, one.shot = TRUE)
                                  })
            }
            
            add(optGrp, tbl)
        },
        opt3 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Customize Labels")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            

            curPlSet <- GUI$getActiveDoc()$getSettings()
            oldMain <- curPlSet$main
            oldX <- curPlSet$xlab
            if (is.null(oldMain)) oldMain <- ''
            if (is.null(oldX)) oldX <- ''

            lbl    <- glabel("Main title :")
            labMain <- gedit(oldMain)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labMain
            ii <- ii + 1
            
            lbl    <- glabel("x-axis label :")
            labX    <- gedit(oldX)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labX
            ii <- ii + 1
            

            lbl <- glabel("Enter a single space to print no label\nLeave blank to print default label")
            font(lbl) <- list(family = "normal",
                               size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            lbl <- glabel("Press ENTER/RETURN to apply changes")
            font(lbl) <- list(family = "normal", size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl

            
            updateEverything <- function() {
                mlab <- svalue(labMain)
                xlab <- svalue(labX)
                GUI$getActiveDoc()$setSettings(
                    list(main = if (mlab != '') mlab else NULL,
                         xlab = if (xlab != '') xlab else NULL)
                    )
                updateSettings()
            }
            
            addHandlerChanged(labMain, handler = function(h, ...) updateEverything())
            addHandlerChanged(labX, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Adjust number of bars visible
        opt4 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Adjust Number of Bars")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            zoom <- if (!is.null(curSet$zoombars))
                        curSet$zoombars
                    else
                        NULL
            
            lbl <- glabel("Number of bars: ")
            NBARS <- gslider(2, min(30, length(levels(curSet$x))), by = 1, value = min(30, length(levels(curSet$x))))
            tbl[ii, 1, expand = TRUE, fill = TRUE, anchor = c(-1, 0)] <- lbl
            tbl[ii, 2, expand = TRUE] <- NBARS
            ii <- ii + 1

            lbl <- glabel("Starting point: ")
            START <- gslider(levels(curSet$x)[1:(length(levels(curSet$x)) - 1)])
            tbl[ii, 1, expand = TRUE, fill = TRUE, anchor = c(-1, 0)] <- lbl
            tbl[ii, 2, expand = TRUE] <- START
            ii <- ii + 1         
            
            updateEverything <- function() {
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(zoombars = c(svalue(START, index = TRUE), svalue(NBARS)))
                    )
                updateSettings()
            }

            addHandlerChanged(NBARS, function(h, ...) updateEverything())
            addHandlerChanged(START, function(h, ...) updateEverything())

            if (!is.null(zoom)) {
                svalue(NBARS) <- zoom[2]
                svalue(START, index = TRUE) <- zoom[1]
            }

            ## timer <- NULL
            ## updT <- function(h, ...) {
            ##     if (!is.null(timer))
            ##         timer$stop_timer()
            ##     timer <- gtimer(800, function(...) updateEverything(), one.shot = TRUE)
            ## }
            ## addHandlerKeystroke(xlower, updT)z
            ## addHandlerKeystroke(xupper, updT)
            
            add(optGrp, tbl)

            resetGrp <- ggroup(cont = optGrp)
            addSpring(resetGrp)
            resetbtn <- gbutton("Reset", cont = resetGrp)
            addHandlerClicked(resetbtn, function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(zoombars = NULL)
                    )
                updateSettings()

                ## reset the values in the boxes:
                ## pl <- GUI$curPlot
                ## xlim <-pl$xlim

                ## svalue(xlower) <- xlim[1]
                ## svalue(xupper) <- xlim[2]
            })

            ## We want to instantly display the results ...
            updateEverything()
        })
    )



### ---------------------------------------------------------------------------------------------------
### SCATTER PLOT MOD WINDOW

iNZScatterMod.old<- setRefClass(
    "iNZScatterMod.old",
    contains = "iNZPlotModWin",
    methods = list(
        initialize = function(GUI, which = 1) {
            callSuper(GUI)
            ## need to specify the methods that we want to use in
            ## do.call later on (see changeOpts())
            usingMethods(opt1, opt2, opt3, opt4, opt5, opt6, opt7, opt8, opt9, opt10, iNZLocatePoints)
            opts <- gcombobox(c("Code more variables",
                                "Add trend curves",
                                "Add x=y line",
                                "Add a jitter",
                                "Add rugs",
                                "Join points by lines",
                                "Change plot appearance",
                                "Identify points",
                                "Customize Labels",
                                "Adjust axis limits"),
                              selected = which)
            add(radioGrp, opts, expand = TRUE, fill = TRUE)
            eval(parse(text = paste0("opt", which, "()")))
            addHandlerChanged(opts,
                              handler = function(h, ...) {
                                  changeOpts(svalue(h$obj,
                                                    index = TRUE))
                              })
        },
        changeOpts = function(index) {
            ## delete current displayed options
            invisible(sapply(optGrp$children, function(x) delete(optGrp, x)))
            do.call(paste("opt", index, sep=""),
                    args = list())
        },
        ## Following are the different views for the indices of the
        ## gradio
        ## Code more variables
        opt1 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl1 <- glabel("Code More Variables")
            font(lbl1) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl1
            ii <- ii + 1
            
            lbl <- glabel("Colour by :")
            grpVarList <- gcombobox(c("", names(GUI$getActiveData())),
                                    selected = ifelse(
                                        is.null(curSet$colby),
                                        1, which(names(GUI$getActiveData()) ==
                                                     curSet$varnames$colby)[1] + 1
                                        )
                                    )
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- grpVarList
            ii <- ii + 1

            lvlCols <- gbutton("Specify colours")
            tbl[ii, 2, expand = TRUE] <- lvlCols
            visible(lvlCols) <- svalue(grpVarList, index = TRUE) != 1
            ii <- ii + 1

            addHandlerClicked(lvlCols, function(h, ...) {
                variable <- GUI$getActiveData()[, svalue(grpVarList, index = FALSE)]
                if (is.numeric(variable)) {
                    gmessage("Set colour of numeric ... not yet implemented.", "Not ready yet.", icon = "warning")
                } else {
                    specifyColours(variable)
                }                
            })


            lbl <- glabel("Resize points by :")
            rszVarList <- gcombobox(
                c("", rszNames <- names(GUI$getActiveData())[sapply(GUI$getActiveData(), is.numeric)]),
                selected = ifelse(
                    is.null(curSet$sizeby),
                    1, which(rszNames == curSet$varnames$sizeby)[1] + 1
                    )
                )
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- rszVarList
            ii <- ii + 1

            lbl <- "Resize method :"
            rszMethods <- c("proportional", "emphasize")
            rszMthd <- gcombobox(rszMethods,
                                 selected = which(rszMethods == curSet$resize.method))
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- rszMthd
            ii <- ii + 1

            rszDescOpts <- list(method1 =
                                    c("Points area proportional to value of variable."),
                                method2 =
                                    c("Point area linearly sized from 0.25 to 4.",
                                      "Good for exaggerating trends."))
            rszDesc <- glabel(paste(rszDescOpts[[svalue(rszMthd, index = TRUE)]]))
            tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- rszDesc


            ## Maintain a single function that is called whenever anything is updated:
            updateEverything <- function() {
                GUI$getActiveDoc()$setSettings(
                    list(colby = GUI$getActiveData()[[
                             svalue(grpVarList)]],
                         sizeby = GUI$getActiveData()[[
                             svalue(rszVarList)]],
                         resize.method = svalue(rszMthd),
                         varnames = list(
                             colby = svalue(grpVarList),
                             sizeby = svalue(rszVarList)))
                    )
                updateSettings()
            }
            
            ## in this case, no point in having a separate "show" button
            addHandlerChanged(grpVarList, handler = function(h, ...) updateEverything())
            addHandlerChanged(rszVarList, handler = function(h, ...) updateEverything())
            addHandlerChanged(rszMthd, handler = function(h, ...) {
                                  svalue(rszDesc) <- rszDescOpts[[svalue(h$obj, index = TRUE)]]
                                  updateEverything()
                              })

            addHandlerChanged(grpVarList,
                              handler = function(h, ...) {
                                  updateEverything()
                                  visible(lvlCols) <- svalue(grpVarList, index = TRUE) != 1 &&
                                      is.factor(GUI$getActiveData()[[svalue(grpVarList)]])
                              })
                              
            add(optGrp, tbl)
        },
        ## Add trend curves
        opt2 = function() {
            tbl <- glayout()
            ii <- 3

            #### TREND CURVES
            lbl <- glabel("Add trend curves")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            ## Types of curves possible:
            trCrvs <- c("linear", "quadratic", "cubic")
            trCols <- c("red", "black", "blue", "green4",
                        "yellow", "pink", "grey", "orange")

            ## Linear trend
            linChk <- gcheckbox(trCrvs[1],
                                checked = trCrvs[1] %in% curSet$trend)
            linCol <- gcombobox(trCols,
                                selected = which(
                                    curSet$col.trend$linear == trCols
                                    )
                                )
            tbl[ii, 1] <- linChk
            tbl[ii, 2] <- linCol
            ii <- ii + 1
            
            quaChk <- gcheckbox(trCrvs[2],
                                checked = trCrvs[2] %in% curSet$trend)
            quaCol <- gcombobox(trCols,
                                selected = which(
                                    curSet$col.trend$quadratic == trCols
                                    )
                                )
            tbl[ii, 1] <- quaChk
            tbl[ii, 2] <- quaCol
            ii <- ii + 1
            
            cubChk <- gcheckbox(trCrvs[3],
                                checked = trCrvs[3] %in% curSet$trend)
            cubCol <- gcombobox(trCols,
                                selected = which(
                                    curSet$col.trend$cubic == trCols
                                    )
                                )
            tbl[ii, 1] <- cubChk
            tbl[ii, 2] <- cubCol
            ii <- ii + 1


            ii <- ii + 1
            #### SMOOTHERS
            smthCols <- c("red", "black", "blue", "green", "yellow",
                          "magenta", "grey", "orange")

            
            smthChk <- gcheckbox("Draw a smoother",
                                 checked = curSet$smooth!=0 | !is.null(curSet$quant.smooth))
            smthCol <- gcombobox(smthCols,
                                 selected = which(
                                     curSet$col.smooth == smthCols)
                                 )
            tbl[ii, 1] <- smthChk
            tbl[ii, 2] <- smthCol
            ii <- ii + 1
            
            quantSmthChk <- gcheckbox("Use Quantiles",
                                      checked = !is.null(curSet$quant.smooth))
            tbl[ii, 1] <- quantSmthChk
            ii <- ii + 1

            smthSlid <- gslider(from = 0.1, to = 1,
                                by = 0.01,
                                value = ifelse(curSet$smooth==0,
                                    0.7, curSet$smooth))
            tbl[ii, 1:2] <- smthSlid
            ii <- ii + 1


            ii <- ii + 1
            trendByChk <- gcheckbox(paste("For each level of",
                                            curSet$varnames$colby),
                                      checked = curSet$trend.by)
            trendParChk <- gcheckbox("Parallel trend lines",
                                     checked = curSet$trend.parallel)
            if (!is.null(curSet$colby)) {
                if (is.factor(curSet$colby)) {
                    tbl[ii, 1:2] <- trendByChk
                    ii <- ii + 1
                    tbl[ii, 1:2] <- trendParChk
                    ii <- ii + 1
                }
            }

            updateEverything <- function(update = auto) {
                if (!update)
                    return()
                
                ## vector of selected trends
                trSel <- c(svalue(linChk),
                           svalue(quaChk),
                           svalue(cubChk))
                ## vector of colors chosen
                trCol <- c(svalue(linCol),
                           svalue(quaCol),
                           svalue(cubCol))
                ## smoother option
                qsmth <-
                    if (svalue(quantSmthChk))
                        if (svalue(smthChk)) "default" else NULL
                    else NULL
                smth <- ifelse(svalue(smthChk) & is.null(qsmth),
                               svalue(smthSlid),
                               0)
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(trend = trCrvs[trSel],
                         smooth = smth,
                         quant.smooth = qsmth,
                         col.trend = list(
                             linear = trCol[1],
                             quadratic = trCol[2],
                             cubic = trCol[3]),
                         col.smooth = svalue(smthCol),
                         trend.by = svalue(trendByChk),
                         trend.parallel = svalue(trendParChk)
                         )
                    )
                updateSettings()
            }

            ii <- ii + 1            
            showButton <- gbutton("Show Changes",
                                  handler = function(h, ...) updateEverything(TRUE))
            
            ## only have the smoother slider enabled if the
            ## smoother checkbox is ticked
            if (!svalue(smthChk)) {
                enabled(smthSlid) <- FALSE
                enabled(quantSmthChk) <- FALSE
            } else {
                if (svalue(quantSmthChk))
                    enabled(smthSlid) <- FALSE
            }

            addHandlerChanged(smthChk, handler = function(h, ...) {
                if (svalue(smthChk)) {
                    if (!svalue(quantSmthChk))
                        enabled(smthSlid) <- TRUE
                    else
                        enabled(smthSlid) <- FALSE

                    enabled(quantSmthChk) <- TRUE
                } else {
                    enabled(smthSlid) <- FALSE
                    enabled(quantSmthChk) <- FALSE
                }
                updateEverything()
            })
            ## if quantiles are used, disable slider
            addHandlerChanged(quantSmthChk,
                              handler = function(h, ...) {
                                  if (svalue(quantSmthChk)) {
                                      enabled(smthSlid) <- FALSE
                                  }
                                  else {
                                      enabled(smthSlid) <- TRUE
                                  }
                                  updateEverything()
                              })

            ## activate/deactive trend by check box
            ## only have the trend by level option enabled if
            ## the colored by variable option is set
            ## and if lin/quad/cub/or normal smoother is checked
            activateTrendBy <- function() {
                enabled(trendByChk) <-
                    ifelse(is.null(curSet$colby), FALSE, is.factor(curSet$colby)) &
                        (svalue(linChk) | svalue(quaChk) | svalue(cubChk) |
                         (svalue(smthChk) & !svalue(quantSmthChk)))
            }
            activateTrendBy()
            addHandlerChanged(linChk, handler = function(h, ...) {
                                          updateEverything()
                                          activateTrendBy()
                                      })
            addHandlerChanged(quaChk, handler = function(h, ...) {
                                          updateEverything()
                                          activateTrendBy()
                                      })
            addHandlerChanged(cubChk, handler = function(h, ...) {
                                          updateEverything()
                                          activateTrendBy()
                                      })
            addHandlerChanged(smthChk, handler = function(h, ...) {
                                           updateEverything()
                                           activateTrendBy()
                                       })
            addHandlerChanged(quantSmthChk, handler = function(h, ...) {
                                                updateEverything()
                                                activateTrendBy()
                                            })

            
            ## activate/deactivate trend parallel box
            ## only have the "parallel lines" enabled if "trend by" is ticked
            activateTrendPar <- function() {
                enabled(trendParChk) <- svalue(trendByChk) &
                    (svalue(linChk) | svalue(quaChk) | svalue(cubChk))
            }
            activateTrendPar()
            addHandlerChanged(trendByChk, handler = function(h, ...) {
                                              updateEverything()
                                              activateTrendPar()
                                          })
            addHandlerChanged(linChk, handler = function(h, ...) {
                                          updateEverything()
                                          activateTrendPar()
                                      })
            addHandlerChanged(quaChk, handler = function(h, ...) {
                                          updateEverything()
                                          activateTrendPar()
                                      })
            addHandlerChanged(cubChk, handler = function(h, ...) {
                                          updateEverything()
                                          activateTrendPar()
                                      })


            ## Also update the colour things
            if (auto) {
                addHandlerChanged(linCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(quaCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(cubCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(smthCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(trendParChk, handler = function(h, ...) updateEverything())
                

                smthtimer <- NULL
                addHandlerChanged(smthSlid,
                                  handler = function(h, ...) {
                                      if (!is.null(smthtimer))
                                          smthtimer$stop_timer()
                                      smthtimer <- gtimer(800, function(...) updateEverything(), one.shot = TRUE)
                                  })

                autoCheck <- gcheckbox("Update automatically", checked = auto)
                tbl[ii, 1:2, expand = TRUE] <- autoCheck
                ii <- ii + 1

                addHandlerChanged(autoCheck, handler = function(h, ...) {
                                                 enabled(showButton) <- !svalue(autoCheck)
                                                 auto <<- svalue(autoCheck)
                                             })
            }

            tbl[ii, 1:2, expand = TRUE] <- showButton
            enabled(showButton) <- !auto

            add(optGrp, tbl)
        },
        ## Add x=y line
        opt3 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Add x=y line")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            xyline <- gcheckbox("Plot x=y line",
                                checked = curSet$LOE)
            xyCols <- c("red", "black", "blue", "green4",
                        "yellow", "pink", "grey", "orange")
            xyCol <- gcombobox(xyCols,
                               selected = which(
                                   curSet$col.LOE == xyCols
                                   )
                               )
            tbl[ii, 1, expand = TRUE] <- xyline
            tbl[ii, 2, expand = TRUE] <- xyCol
            ii <- ii + 1

            updateEverything <- function() {
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(LOE = svalue(xyline),
                         col.LOE = svalue(xyCol))
                    )
                updateSettings()
            }

            addHandlerChanged(xyline, handler = function(h, ...) updateEverything())
            addHandlerChanged(xyCol, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Add jitter
        opt4 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Add a jitter")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            xJit <- gcheckbox("Jitter x-variable",
                              checked = curSet$jitter %in% c("x", "xy"))
            yJit <- gcheckbox("Jitter y-variable",
                              checked = curSet$jitter %in% c("y", "xy"))
            tbl[ii, 1, expand = TRUE] <- xJit
            tbl[ii, 2, expand = TRUE] <- yJit
            ii <- ii + 1

            updateEverything <- function() {
                ## build string to show which jitter opt
                ## was selected
                jit <- ""
                if (svalue(xJit)) jit <- paste(jit, "x", sep = "")
                if (svalue(yJit)) jit <- paste(jit, "y", sep = "")
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(jitter = jit)
                    )
                updateSettings()
            }

            addHandlerChanged(xJit, handler = function(h, ...) updateEverything())
            addHandlerChanged(yJit, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Add rug
        opt5 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Add rugs")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            xRug <- gcheckbox("Add x-rug",
                              checked = curSet$rug %in% c("x", "xy"))
            yRug <- gcheckbox("Add y-rug",
                              checked = curSet$rug %in% c("y", "xy"))
            tbl[ii, 1, expand = TRUE] <- xRug
            tbl[ii, 2, expand = TRUE] <- yRug
            ii <- ii + 1

            updateEverything <- function() {
                ## build string to show which jitter opt
                ## was selected
                rug <- ""
                if (svalue(xRug)) rug <- paste(rug, "x", sep = "")
                if (svalue(yRug)) rug <- paste(rug, "y", sep = "")
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(rugs = rug)
                    )
                updateSettings()
            }

            addHandlerChanged(xRug, handler = function(h, ...) updateEverything())
            addHandlerChanged(yRug, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Join points by lines
        opt6 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Join points by lines")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            joinPts <- gcheckbox("Join points",
                                 checked = curSet$join)
            joinCols <- c("red", "black", "blue", "green4",
                          "yellow", "pink", "grey", "orange")
            joinCol <- gcombobox(joinCols,
                               selected = which(
                                   curSet$col.line == joinCols
                                   )
                               )
            tbl[ii, 1, expand = TRUE] <- joinPts
            tbl[ii, 2, expand = TRUE] <- joinCol
            ii <- ii + 1

            lineByChk <- gcheckbox(paste("For each level of",
                                         curSet$varnames$colby),
                                   selected = curSet$lines.by)
            if (!is.null(curSet$colby)) {
                tbl[ii, 1] <- lineByChk
                ii <- 1
            }

            updateEverything <- function() {
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(join = svalue(joinPts),
                         col.line = svalue(joinCol),
                         lines.by = svalue(lineByChk))
                    )
                updateSettings()
            }
            
            addHandlerChanged(joinPts, handler = function(h, ...) updateEverything())
            addHandlerChanged(joinCol, handler = function(h, ...) updateEverything())
            addHandlerChanged(lineByChk, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## change plot appearance
        opt7 = function() {
            tbl <- glayout()
            ii <- 3

            ## Default settings
            defts <- iNZightPlots:::inzpar()
            
            ## PLOT APPEARANCE
            lbl <- glabel("Change plot appearance")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii,  1:2, anchor = c(-1,-1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            ## PLOT TYPE
            lbl <- glabel("Plot Type :")
            
            plotTypes <- c("default", "scatter plot", "grid-density plot", "hexbin plot")
            plotTypeValues <- list("default", "scatter", "grid", "hex")
            plotTypeList <- gcombobox(
                plotTypes,
                selected = which(plotTypeValues == curSet$plottype)
                )
            
            addHandlerChanged(plotTypeList, handler = function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(plottype = plotTypeValues[[svalue(plotTypeList, index = TRUE)]])
                    )
                updateSettings()

                plType <- svalue(plotTypeList, index = TRUE)
                if (plType == 3 | plType == 4 | (plType == 1 & GUI$plotType != "scatter")) {
                    switch(GUI$plotType,
                           "grid" = iNZGriddenMod$new(GUI, which = 3),
                           "hex" = iNZHexbinMod$new(GUI, which = 3))
                }
            })
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- plotTypeList
            ii <- ii + 1


            ## BACKGROUND COLOUR
            lbl <- glabel("Background colour :")
            
            backgroundCols <- c(defts$bg, "antiquewhite",
                                "azure3", "bisque", "cornsilk", "darkolivegreen2",
                                "darkslategray1", "greenyellow", "lightblue1",
                                "lightpink", "rosybrown1", "slategray1", "thistle1",
                                "wheat1")
            backgroundColList <- gcombobox(
                backgroundCols,
                selected = ifelse(
                    is.na(which(backgroundCols == curSet$bg)[1]),
                    1,
                    which(backgroundCols == curSet$bg)[1]),
                editable = TRUE)
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- backgroundColList
            ii <- ii + 1


            ## ## SYMBOL OPTIONS
            ii <- ii + 1
            lbl <- glabel("Symbol options")
            font(lbl) <- list(weight="bold", family = "normal", size = 8)
            tbl[ii, 1:2, anchor = c(-1,-1), expand = TRUE] <- lbl
            ii <- ii + 1

            isColBy <- !is.null(GUI$getActiveDoc()$getSettings()$colby)
            if (!isColBy) {
                ## COLOUR            
                lbl <- glabel("Colour :")
                pointCols <- c(defts$col.pt, "darkblue", "darkgreen",
                               "darkmagenta", "darkslateblue", "hotpink4",
                               "lightsalmon2", "palegreen3", "steelblue3")
                symbolColList <- gcombobox(
                    pointCols,
                    selected = ifelse(
                        is.na(which(pointCols == curSet$col.pt)[1]),
                        1,
                        which(pointCols == curSet$col.pt)[1]),
                    editable = TRUE)
                
                tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
                tbl[ii,  2, expand = TRUE] <- symbolColList
                ii <- ii + 1
                
                lbl <- glabel("NOTE: You can type in a colour if it is not listed.")
                
                font(lbl) <- list(family = "normal", size = 8)
                tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl                
                ii <- ii + 1
            } else {
                ## COLOUR PALETTE
                lbl <- glabel("Colour palette :")
                palettes <<- list("default" = NULL,
                                  "rainbow" = function(n) rainbow(n, start = 1/6),
                                  "heat" = heat.colors,
                                  "terrain" = terrain.colors)
                if (requireNamespace("colorspace", quietly = TRUE)) {
                    palettes <<- c(palettes, list("advanced" = NULL))
                }
                paletteList <- gcombobox(
                    names(palettes),
                    selected = ifelse(
                        is.na(which(names(palettes) == attr(curSet$col.fun, "name"))[1]),
                        1,
                        which(names(palettes) == attr(curSet$col.fun, "name"))[1]),
                    editable = FALSE)

                tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
                tbl[ii, 2, expand = TRUE] <- paletteList
            }

            ## FILL
            fillColor <- gcheckbox("Colour interior",
                                   checked = (curSet$pch != 1))
            tbl[ii,  2, expand = TRUE] <- fillColor
            ii <- ii + 1
            
            ## SIZE
            lbl <- glabel("Size :")
            cexSlider <- gslider(from = 0.05, to = 3.5,
                                 by = 0.05, value = curSet$cex.pt)
            tbl[ii, 1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- cexSlider
            ii <- ii + 1
            
            ## Transparency
            lbl <- glabel("Transparency :")
            transpSlider <- gslider(from = 0, to = 100,
                                    by = 1, value = 100 * (1 - curSet$alpha))
            tbl[ii, 1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- transpSlider
            ii <- ii + 1

            updateEverything <- function(update = auto) {
                ## To easily diable automatic updating of plot, add this argument,
                ## otherwise would have to block/unblock handlers
                if (!update)
                    return()
                
                pch.sel <- ifelse(svalue(fillColor) | svalue(transpSlider) > 0,
                                  19, 1)
                if (isColBy) {
                    colFn <- palettes[[svalue(paletteList, index = TRUE)]]
                    if (svalue(paletteList, index = TRUE) > 1) {
                        attr(colFn, "name") <- svalue(paletteList)
                    }
                }
                GUI$getActiveDoc()$setSettings(
                    list(col.pt = if (isColBy) curSet$col.pt else svalue(symbolColList),
                         col.fun = if (isColBy) colFn else NULL,
                         bg = svalue(backgroundColList),
                         cex.pt = svalue(cexSlider),
                         pch = pch.sel,
                         alpha = 1 - svalue(transpSlider) / 100
                         ))
                updateSettings()
            }

            ii <- ii + 1
            showButton <- gbutton("Show Changes",
                                  handler = function(h, ...) updateEverything(TRUE))
            if (auto) {
                bcoltimer <- NULL
                addHandlerChanged(backgroundColList,
                                  handler = function(h, ...) {
                                      if (!is.null(bcoltimer))
                                          bcoltimer$stop_timer()
                                      bcoltimer <- gtimer(500, function(...) {
                                                               if (nchar(svalue(backgroundColList)) >= 3)
                                                                   updateEverything()
                                                           }, one.shot = TRUE)
                                  })

                ## This one needs to be deactivated if user is typing:
                if (isColBy) {
                    addHandlerChanged(paletteList,
                                      handler = function(h, ...) {
                                          if (svalue(paletteList) == "advanced") {
                                              palettes$advanced <<- colorspace::choose_palette()
                                          }
                                          updateEverything()
                                      })
                } else {
                    pcoltimer <- NULL
                    addHandlerChanged(symbolColList,
                                      handler = function(h, ...) {
                                          if (!is.null(pcoltimer))
                                              pcoltimer$stop_timer()
                                          pcoltimer <- gtimer(500, function(...) {
                                                                  if (nchar(svalue(symbolColList)) >= 3)
                                                                      updateEverything()
                                                              }, one.shot = TRUE)
                                      })
                }

                addHandlerChanged(fillColor,
                                  handler = function(h, ...) updateEverything())
                                
                cextimer <- NULL
                addHandlerChanged(cexSlider,
                                  handler = function(h, ...) {
                                      if (!is.null(cextimer))
                                          cextimer$stop_timer()
                                      cextimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })

                transptimer <- NULL
                addHandlerChanged(transpSlider,
                                  handler = function(h, ...) {
                                      if (!is.null(transptimer))
                                          transptimer$stop_timer()
                                      transptimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })

                autoCheck <- gcheckbox("Update automatically", checked = auto)
                tbl[ii, 1:2, expand = TRUE] <- autoCheck
                ii <- ii + 1

                addHandlerChanged(autoCheck, handler = function(h, ...) {
                                                 enabled(showButton) <- !svalue(autoCheck)
                                                 auto <<- svalue(autoCheck)
                                             })
            }
            
            
            tbl[ii, 1:2, expand = TRUE] <- showButton
            enabled(showButton) <- !auto
            
            add(optGrp, tbl)
        },
        opt8 = function() iNZLocatePoints(),
        opt9 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Customize Labels")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            

            curPlSet <- GUI$getActiveDoc()$getSettings()
            oldMain <- curPlSet$main
            oldX <- curPlSet$xlab
            oldY <- curPlSet$ylab
            if (is.null(oldMain)) oldMain <- ''
            if (is.null(oldX)) oldX <- ''
            if (is.null(oldY)) oldY <- ''

            lbl    <- glabel("Main title :")
            labMain <- gedit(oldMain)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labMain
            ii <- ii + 1
            
            lbl    <- glabel("x-axis label :")
            labX    <- gedit(oldX)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labX
            ii <- ii + 1

            lbl    <- glabel("y-axis label :")
            labY    <- gedit(oldY)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labY
            ii <- ii + 1
            

            lbl <- glabel("Enter a single space to print no label\nLeave blank to print default label")
            font(lbl) <- list(family = "normal",
                               size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            lbl <- glabel("Press ENTER/RETURN to apply changes")
            font(lbl) <- list(family = "normal", size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl

            
            updateEverything <- function() {
                mlab <- svalue(labMain)
                xlab <- svalue(labX)
                ylab <- svalue(labY)
                GUI$getActiveDoc()$setSettings(
                    list(main = if (mlab != '') mlab else NULL,
                         xlab = if (xlab != '') xlab else NULL,
                         ylab = if (ylab != '') ylab else NULL)
                    )
                updateSettings()
            }
            
            addHandlerChanged(labMain, handler = function(h, ...) updateEverything())
            addHandlerChanged(labX, handler = function(h, ...) updateEverything())
            addHandlerChanged(labY, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Adjust axis limits
        opt10 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Adjust Axis Limits")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            pl <- GUI$curPlot
            xlim <- if (is.null(curSet$xlim))
                pl$xlim
            else
                curSet$xlim
            ylim <- if (is.null(curSet$ylim))
                pl$ylim
            else
                curSet$ylim

            
            lbl <- glabel("x-axis: ")
            xlower <- gedit(xlim[1])
            xupper <- gedit(xlim[2])
            tbl[ii, 1, expand = TRUE, fill = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- xlower
            tbl[ii, 3, expand = TRUE] <- xupper
            ii <- ii + 1

            lbl <- glabel("y-axis: ")
            ylower <- gedit(ylim[1])
            yupper <- gedit(ylim[2])
            tbl[ii, 1, expand = TRUE, fill = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- ylower
            tbl[ii, 3, expand = TRUE] <- yupper
            ii <- ii + 1

            errlbl <- glabel("Limits must be numbers.")
            tbl[ii, 1:3] <- errlbl
            visible(errlbl) <- FALSE
            ii <- ii + 1

            updateEverything <- function() {
                err <- FALSE
                xl <- suppressWarnings(as.numeric(svalue(xlower)))
                if (is.na(xl)) {
                    xl <- xlim[1]
                    err <- TRUE4
                }
                xu <- suppressWarnings(as.numeric(svalue(xupper)))
                if (is.na(xu)) {
                    xu <- xlim[2]
                    err <- TRUE
                }

                yl <- suppressWarnings(as.numeric(svalue(ylower)))
                if (is.na(yl)) {
                    yl <- ylim[1]
                    err <- TRUE
                }
                yu <- suppressWarnings(as.numeric(svalue(yupper)))
                if (is.na(yu)) {
                    yu <- ylim[2]
                    err <- TRUE
                }

                visible(errlbl) <- err
                    
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(xlim = c(xl, xu),
                         ylim = c(yl, yu))
                    )
                updateSettings()
            }

            timer <- NULL
            updT <- function(h, ...) {
                if (!is.null(timer))
                    timer$stop_timer()
                timer <- gtimer(800, function(...) updateEverything(), one.shot = TRUE)
            }
            addHandlerKeystroke(xlower, updT)
            addHandlerKeystroke(xupper, updT)
            addHandlerKeystroke(ylower, updT)
            addHandlerKeystroke(yupper, updT)
            
            add(optGrp, tbl)

            resetGrp <- ggroup(cont = optGrp)
            addSpring(resetGrp)
            resetbtn <- gbutton("Reset", cont = resetGrp)
            addHandlerClicked(resetbtn, function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(xlim = NULL, ylim = NULL)
                    )
                updateSettings()

                ## reset the values in the boxes:
                pl <- GUI$curPlot
                xlim <-pl$xlim
                ylim <- pl$ylim

                svalue(xlower) <- xlim[1]
                svalue(xupper) <- xlim[2]
                svalue(ylower) <- ylim[1]
                svalue(yupper) <- ylim[2]
            })
        })
    )


### ---------------------------------------------------------------------------------------------------
### GRID DENSITY PLOT MOD WINDOW
iNZGriddenMod <- setRefClass(
    "iNZGriddenMod",
    contains = "iNZPlotModWin",
    methods = list(
        initialize = function(GUI, which = 1) {
            callSuper(GUI)
            ## need to specify the methods that we want to use in
            ## do.call later on (see changeOpts())
            usingMethods(opt1, opt2, opt3, opt4, opt5)
            opts <- gcombobox(c("Add trend curves",
                                "Add x=y line",
                                "Change plot appearance",
                                "Customize Labels",
                                "Adjust axis limits"),
                              selected = which)
            add(radioGrp, opts, expand = TRUE, fill = TRUE)
            eval(parse(text = paste0("opt", which, "()")))
            addHandlerChanged(opts,
                              handler = function(h, ...) {
                                  changeOpts(svalue(h$obj,
                                                    index = TRUE))
                              })
        },
        changeOpts = function(index) {
            ## delete current displayed options
            invisible(sapply(optGrp$children, function(x) delete(optGrp, x)))
            do.call(paste("opt", index, sep=""),
                    args = list())
        },
        ## Following are the different views for the indices of the
        ## gradio
        ## Add trend curves
        opt1 = function() {
            tbl <- glayout()
            ii <- 3

            #### TREND CURVES
            lbl <- glabel("Add trend curves")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            ## Types of curves possible:
            trCrvs <- c("linear", "quadratic", "cubic")
            trCols <- c("red", "black", "blue", "green4",
                        "yellow", "pink", "grey", "orange")

            ## Linear trend
            linChk <- gcheckbox(trCrvs[1],
                                checked = trCrvs[1] %in% curSet$trend)
            linCol <- gcombobox(trCols,
                                selected = which(
                                    curSet$col.trend$linear == trCols
                                    )
                                )
            tbl[ii, 1] <- linChk
            tbl[ii, 2] <- linCol
            ii <- ii + 1
            
            quaChk <- gcheckbox(trCrvs[2],
                                checked = trCrvs[2] %in% curSet$trend)
            quaCol <- gcombobox(trCols,
                                selected = which(
                                    curSet$col.trend$quadratic == trCols
                                    )
                                )
            tbl[ii, 1] <- quaChk
            tbl[ii, 2] <- quaCol
            ii <- ii + 1
            
            cubChk <- gcheckbox(trCrvs[3],
                                checked = trCrvs[3] %in% curSet$trend)
            cubCol <- gcombobox(trCols,
                                selected = which(
                                    curSet$col.trend$cubic == trCols
                                    )
                                )
            tbl[ii, 1] <- cubChk
            tbl[ii, 2] <- cubCol
            ii <- ii + 1


            ii <- ii + 1
            #### SMOOTHERS
            smthCols <- c("red", "black", "blue", "green", "yellow",
                          "magenta", "grey", "orange")

            
            smthChk <- gcheckbox("Draw a smoother",
                                 checked = curSet$smooth!=0 | !is.null(curSet$quant.smooth))
            smthCol <- gcombobox(smthCols,
                                 selected = which(
                                     curSet$col.smooth == smthCols)
                                 )
            tbl[ii, 1] <- smthChk
            tbl[ii, 2] <- smthCol
            ii <- ii + 1
            
            quantSmthChk <- gcheckbox("Use Quantiles",
                                      checked = !is.null(curSet$quant.smooth))
            tbl[ii, 1] <- quantSmthChk
            ii <- ii + 1

            smthSlid <- gslider(from = 0.1, to = 1,
                                by = 0.01,
                                value = ifelse(curSet$smooth==0,
                                    0.7, curSet$smooth))
            tbl[ii, 1:2] <- smthSlid
            ii <- ii + 1

            updateEverything <- function(update = auto) {
                if (!update)
                    return()
                
                ## vector of selected trends
                trSel <- c(svalue(linChk),
                           svalue(quaChk),
                           svalue(cubChk))
                ## vector of colors chosen
                trCol <- c(svalue(linCol),
                           svalue(quaCol),
                           svalue(cubCol))
                ## smoother option
                qsmth <-
                    if (svalue(quantSmthChk))
                        if (svalue(smthChk))"default" else NULL
                    else NULL
                smth <- ifelse(svalue(smthChk) & is.null(qsmth),
                               svalue(smthSlid),
                               0)
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(trend = trCrvs[trSel],
                         smooth = smth,
                         quant.smooth = qsmth,
                         col.trend = list(
                             linear = trCol[1],
                             quadratic = trCol[2],
                             cubic = trCol[3]),
                         col.smooth = svalue(smthCol)
                         )
                    )
                updateSettings()
            }

            ii <- ii + 1            
            showButton <- gbutton("Show Changes",
                                  handler = function(h, ...) updateEverything(TRUE))
            
            ## only have the smoother slider enabled if the
            ## smoother checkbox is ticked
            if (!svalue(smthChk)) {
                enabled(smthSlid) <- FALSE
                enabled(quantSmthChk) <- FALSE
            } else {
                if (svalue(quantSmthChk))
                    enabled(smthSlid) <- FALSE
            }

            addHandlerChanged(smthChk, handler = function(h, ...) {
                if (svalue(smthChk)) {
                    if (!svalue(quantSmthChk))
                        enabled(smthSlid) <- TRUE
                    else
                        enabled(smthSlid) <- FALSE

                    enabled(quantSmthChk) <- TRUE
                } else {
                    enabled(smthSlid) <- FALSE
                    enabled(quantSmthChk) <- FALSE
                }
                updateEverything()
            })
            ## if quantiles are used, disable slider
            addHandlerChanged(quantSmthChk,
                              handler = function(h, ...) {
                                  if (svalue(quantSmthChk)) {
                                      enabled(smthSlid) <- FALSE
                                  }
                                  else {
                                      enabled(smthSlid) <- TRUE
                                  }
                                  updateEverything()
                              })

            addHandlerChanged(linChk, handler = function(h, ...) {
                                          updateEverything()
                                      })
            addHandlerChanged(quaChk, handler = function(h, ...) {
                                          updateEverything()
                                      })
            addHandlerChanged(cubChk, handler = function(h, ...) {
                                          updateEverything()
                                      })
            addHandlerChanged(smthChk, handler = function(h, ...) {
                                           updateEverything()
                                       })
            addHandlerChanged(quantSmthChk, handler = function(h, ...) {
                                                updateEverything()
                                            })

            ## Also update the colour things
            if (auto) {
                addHandlerChanged(linCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(quaCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(cubCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(smthCol, handler = function(h, ...) updateEverything())                

                smthtimer <- NULL
                addHandlerChanged(smthSlid,
                                  handler = function(h, ...) {
                                      if (!is.null(smthtimer))
                                          smthtimer$stop_timer()
                                      smthtimer <- gtimer(800, function(...) updateEverything(), one.shot = TRUE)
                                  })

                autoCheck <- gcheckbox("Update automatically", checked = auto)
                tbl[ii, 1:2, expand = TRUE] <- autoCheck
                ii <- ii + 1

                addHandlerChanged(autoCheck, handler = function(h, ...) {
                                                 enabled(showButton) <- !svalue(autoCheck)
                                                 auto <<- svalue(autoCheck)
                                             })
            }

            tbl[ii, 1:2, expand = TRUE] <- showButton
            enabled(showButton) <- !auto

            add(optGrp, tbl)
        },
        ## Add x=y line
        opt2 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Add x=y line")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            xyline <- gcheckbox("Plot x=y line",
                                checked = curSet$LOE)
            xyCols <- c("red", "black", "blue", "green4",
                        "yellow", "pink", "grey", "orange")
            xyCol <- gcombobox(xyCols,
                               selected = which(
                                   curSet$col.LOE == xyCols
                                   )
                               )
            tbl[ii, 1, expand = TRUE] <- xyline
            tbl[ii, 2, expand = TRUE] <- xyCol
            ii <- ii + 1

            updateEverything <- function() {
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(LOE = svalue(xyline),
                         col.LOE = svalue(xyCol))
                    )
                updateSettings()
            }

            addHandlerChanged(xyline, handler = function(h, ...) updateEverything())
            addHandlerChanged(xyCol, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## change plot appearance
        opt3 = function() {
            tbl <- glayout()
            ii <- 3

            ## Default settings
            defts <- iNZightPlots:::inzpar()
            
            ## PLOT APPEARANCE
            lbl <- glabel("Change plot appearance")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii,  1:2, anchor = c(-1,-1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            ## PLOT TYPE
            lbl <- glabel("Plot Type :")
            
            plotTypes <- c("default", "scatter plot", "grid-density plot", "hexbin plot")
            plotTypeValues <- list("default", "scatter", "grid", "hex")
            plotTypeList <- gcombobox(
                plotTypes,
                selected = which(plotTypeValues == curSet$plottype)
                )
            
            addHandlerChanged(plotTypeList, handler = function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(plottype = plotTypeValues[[svalue(plotTypeList, index = TRUE)]])
                    )
                updateSettings()

                plType <- svalue(plotTypeList, index = TRUE)
                if (plType == 2 | plType == 4 | (plType == 1 & GUI$plotType != "grid")) {
                    switch(GUI$plotType,
                           "scatter" = iNZScatterMod$new(GUI, which = 7),
                           "hex" = iNZHexbinMod$new(GUI, which = 3))
                }
            })
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- plotTypeList
            ii <- ii + 1


            ## BACKGROUND COLOUR
            lbl <- glabel("Background colour :")
            
            backgroundCols <- c(defts$bg, "antiquewhite",
                                "azure3", "bisque", "cornsilk", "darkolivegreen2",
                                "darkslategray1", "greenyellow", "lightblue1",
                                "lightpink", "rosybrown1", "slategray1", "thistle1",
                                "wheat1")
            backgroundColList <- gcombobox(
                backgroundCols,
                selected = ifelse(
                    is.na(which(backgroundCols == curSet$bg)[1]),
                    1,
                    which(backgroundCols == curSet$bg)[1]),
                editable = TRUE)
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- backgroundColList
            ii <- ii + 1


            ## GRID SIZE
            lbl <- glabel("Grid size (n x n) :")
            binSlider <- gslider(from = 10, to = 250,
                                 by = 1, value = curSet$scatter.grid.bins)
            tbl[ii, 1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- binSlider
            ii <- ii + 1


            ## Min-count greyness scale
            lbl <- glabel("Min-count colour (% grey) :")
            greySlider <- gslider(from = 0, to = 50,
                                  by = 1, value = round(50 * (curSet$alpha)))
            tbl[ii, 1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- greySlider
            ii <- ii + 1


            updateEverything <- function(update = auto) {
                ## To easily diable automatic updating of plot, add this argument,
                ## otherwise would have to block/unblock handlers
                if (!update)
                    return()
                
                GUI$getActiveDoc()$setSettings(
                    list(bg = svalue(backgroundColList),
                         scatter.grid.bins = svalue(binSlider),
                         alpha = svalue(greySlider) / 50
                         )
                    )
                updateSettings()
            }

            ii <- ii + 1
            showButton <- gbutton("Show Changes",
                                  handler = function(h, ...) updateEverything(TRUE))
            if (auto) {
                bcoltimer <- NULL
                addHandlerChanged(backgroundColList,
                                  handler = function(h, ...) {
                                      if (!is.null(bcoltimer))
                                          bcoltimer$stop_timer()
                                      bcoltimer <- gtimer(500, function(...) {
                                                               if (nchar(svalue(backgroundColList)) >= 3)
                                                                   updateEverything()
                                                           }, one.shot = TRUE)
                                  })
                
                bintimer <- NULL
                addHandlerChanged(binSlider,
                                  handler = function(h, ...) {
                                      if (!is.null(bintimer))
                                          bintimer$stop_timer()
                                      bintimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })

                greytimer <- NULL
                addHandlerChanged(greySlider,
                                  handler = function(h, ...) {
                                      if (!is.null(greytimer))
                                          greytimer$stop_timer()
                                      greytimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })

                autoCheck <- gcheckbox("Update automatically", checked = auto)
                tbl[ii, 1:2, expand = TRUE] <- autoCheck
                ii <- ii + 1

                addHandlerChanged(autoCheck, handler = function(h, ...) {
                                                 enabled(showButton) <- !svalue(autoCheck)
                                                 auto <<- svalue(autoCheck)
                                             })
            }
            
            
            tbl[ii, 1:2, expand = TRUE] <- showButton
            enabled(showButton) <- !auto
            
            add(optGrp, tbl)
        },
        opt4 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Customize Labels")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            

            curPlSet <- GUI$getActiveDoc()$getSettings()
            oldMain <- curPlSet$main
            oldX <- curPlSet$xlab
            oldY <- curPlSet$ylab
            if (is.null(oldMain)) oldMain <- ''
            if (is.null(oldX)) oldX <- ''
            if (is.null(oldY)) oldY <- ''

            lbl    <- glabel("Main title :")
            labMain <- gedit(oldMain)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labMain
            ii <- ii + 1
            
            lbl    <- glabel("x-axis label :")
            labX    <- gedit(oldX)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labX
            ii <- ii + 1

            lbl    <- glabel("y-axis label :")
            labY    <- gedit(oldY)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labY
            ii <- ii + 1
            

            lbl <- glabel("Enter a single space to print no label\nLeave blank to print default label")
            font(lbl) <- list(family = "normal",
                               size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            lbl <- glabel("Press ENTER/RETURN to apply changes")
            font(lbl) <- list(family = "normal", size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl

            
            updateEverything <- function() {
                mlab <- svalue(labMain)
                xlab <- svalue(labX)
                ylab <- svalue(labY)
                GUI$getActiveDoc()$setSettings(
                    list(main = if (mlab != '') mlab else NULL,
                         xlab = if (xlab != '') xlab else NULL,
                         ylab = if (ylab != '') ylab else NULL)
                    )
                updateSettings()
            }
            
            addHandlerChanged(labMain, handler = function(h, ...) updateEverything())
            addHandlerChanged(labX, handler = function(h, ...) updateEverything())
            addHandlerChanged(labY, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Adjust axis limits
        opt5 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Adjust Axis Limits")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            pl <- GUI$curPlot
            xlim <- if (is.null(curSet$xlim))
                pl$xlim
            else
                curSet$xlim
            ylim <- if (is.null(curSet$ylim))
                pl$ylim
            else
                curSet$ylim
           
            lbl <- glabel("x-axis: ")
            xlower <- gedit(xlim[1])
            xupper <- gedit(xlim[2])
            tbl[ii, 1, expand = TRUE, fill = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- xlower
            tbl[ii, 3, expand = TRUE] <- xupper
            ii <- ii + 1

            lbl <- glabel("y-axis: ")
            ylower <- gedit(ylim[1])
            yupper <- gedit(ylim[2])
            tbl[ii, 1, expand = TRUE, fill = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- ylower
            tbl[ii, 3, expand = TRUE] <- yupper
            ii <- ii + 1

            errlbl <- glabel("Limits must be numbers.")
            tbl[ii, 1:3] <- errlbl
            visible(errlbl) <- FALSE

            updateEverything <- function() {
                err <- FALSE
                xl <- suppressWarnings(as.numeric(svalue(xlower)))
                if (is.na(xl)) {
                    xl <- xlim[1]
                    err <- TRUE
                }
                xu <- suppressWarnings(as.numeric(svalue(xupper)))
                if (is.na(xu)) {
                    xu <- xlim[2]
                    err <- TRUE
                }

                yl <- suppressWarnings(as.numeric(svalue(ylower)))
                if (is.na(yl)) {
                    yl <- ylim[1]
                    err <- TRUE
                }
                yu <- suppressWarnings(as.numeric(svalue(yupper)))
                if (is.na(yu)) {
                    yu <- ylim[2]
                    err <- TRUE
                }

                visible(errlbl) <- err
                    
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(xlim = c(xl, xu),
                         ylim = c(yl, yu))
                    )
                updateSettings()
            }

            timer <- NULL
            updT <- function(h, ...) {
                if (!is.null(timer))
                    timer$stop_timer()
                timer <- gtimer(800, function(...) updateEverything(), one.shot = TRUE)
            }
            addHandlerKeystroke(xlower, updT)
            addHandlerKeystroke(xupper, updT)
            addHandlerKeystroke(ylower, updT)
            addHandlerKeystroke(yupper, updT)
            
            add(optGrp, tbl)

            resetGrp <- ggroup(cont = optGrp)
            addSpring(resetGrp)
            resetbtn <- gbutton("Reset", cont = resetGrp)
            addHandlerClicked(resetbtn, function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(xlim = NULL, ylim = NULL)
                    )
                updateSettings()

                ## reset the values in the boxes:
                pl <- GUI$curPlot
                xlim <-pl$xlim
                ylim <- pl$ylim

                svalue(xlower) <- xlim[1]
                svalue(xupper) <- xlim[2]
                svalue(ylower) <- ylim[1]
                svalue(yupper) <- ylim[2]
            })
        })
    )

### ---------------------------------------------------------------------------------------------------
### HEXBIN PLOT MOD WINDOW
iNZHexbinMod <- setRefClass(
    "iNZHexbinMod",
    contains = "iNZPlotModWin",
    methods = list(
        initialize = function(GUI, which = 1) {
            callSuper(GUI)
            ## need to specify the methods that we want to use in
            ## do.call later on (see changeOpts())
            usingMethods(opt1, opt2, opt3, opt4, opt5)
            opts <- gcombobox(c("Add trend curves",
                                "Add x=y line",
                                "Change plot appearance",
                                "Customize Labels",
                                "Adjust axis limits"),
                              selected = which)
            add(radioGrp, opts, expand = TRUE, fill = TRUE)
            eval(parse(text = paste0("opt", which, "()")))
            addHandlerChanged(opts,
                              handler = function(h, ...) {
                                  changeOpts(svalue(h$obj,
                                                    index = TRUE))
                              })
        },
        changeOpts = function(index) {
            ## delete current displayed options
            invisible(sapply(optGrp$children, function(x) delete(optGrp, x)))
            do.call(paste("opt", index, sep=""),
                    args = list())
        },
        ## Following are the different views for the indices of the
        ## gradio
        ## Add trend curves
        opt1 = function() {
            tbl <- glayout()
            ii <- 3

            #### TREND CURVES
            lbl <- glabel("Add trend curves")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            ## Types of curves possible:
            trCrvs <- c("linear", "quadratic", "cubic")
            trCols <- c("red", "black", "blue", "green4",
                        "yellow", "pink", "grey", "orange")

            ## Linear trend
            linChk <- gcheckbox(trCrvs[1],
                                checked = trCrvs[1] %in% curSet$trend)
            linCol <- gcombobox(trCols,
                                selected = which(
                                    curSet$col.trend$linear == trCols
                                    )
                                )
            tbl[ii, 1] <- linChk
            tbl[ii, 2] <- linCol
            ii <- ii + 1
            
            quaChk <- gcheckbox(trCrvs[2],
                                checked = trCrvs[2] %in% curSet$trend)
            quaCol <- gcombobox(trCols,
                                selected = which(
                                    curSet$col.trend$quadratic == trCols
                                    )
                                )
            tbl[ii, 1] <- quaChk
            tbl[ii, 2] <- quaCol
            ii <- ii + 1
            
            cubChk <- gcheckbox(trCrvs[3],
                                checked = trCrvs[3] %in% curSet$trend)
            cubCol <- gcombobox(trCols,
                                selected = which(
                                    curSet$col.trend$cubic == trCols
                                    )
                                )
            tbl[ii, 1] <- cubChk
            tbl[ii, 2] <- cubCol
            ii <- ii + 1


            ii <- ii + 1
            #### SMOOTHERS
            smthCols <- c("red", "black", "blue", "green", "yellow",
                          "magenta", "grey", "orange")

            
            smthChk <- gcheckbox("Draw a smoother",
                                 checked = curSet$smooth!=0 | !is.null(curSet$quant.smooth))
            smthCol <- gcombobox(smthCols,
                                 selected = which(
                                     curSet$col.smooth == smthCols)
                                 )
            tbl[ii, 1] <- smthChk
            tbl[ii, 2] <- smthCol
            ii <- ii + 1
            
            quantSmthChk <- gcheckbox("Use Quantiles",
                                      checked = !is.null(curSet$quant.smooth))
            tbl[ii, 1] <- quantSmthChk
            ii <- ii + 1

            smthSlid <- gslider(from = 0.1, to = 1,
                                by = 0.01,
                                value = ifelse(curSet$smooth==0,
                                    0.7, curSet$smooth))
            tbl[ii, 1:2] <- smthSlid
            ii <- ii + 1

            updateEverything <- function(update = auto) {
                if (!update)
                    return()
                
                ## vector of selected trends
                trSel <- c(svalue(linChk),
                           svalue(quaChk),
                           svalue(cubChk))
                ## vector of colors chosen
                trCol <- c(svalue(linCol),
                           svalue(quaCol),
                           svalue(cubCol))
                ## smoother option
                qsmth <-
                    if (svalue(quantSmthChk))
                        if (svalue(smthChk))"default" else NULL
                    else NULL
                smth <- ifelse(svalue(smthChk) & is.null(qsmth),
                               svalue(smthSlid),
                               0)
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(trend = trCrvs[trSel],
                         smooth = smth,
                         quant.smooth = qsmth,
                         col.trend = list(
                             linear = trCol[1],
                             quadratic = trCol[2],
                             cubic = trCol[3]),
                         col.smooth = svalue(smthCol)
                         )
                    )
                updateSettings()
            }

            ii <- ii + 1            
            showButton <- gbutton("Show Changes",
                                  handler = function(h, ...) updateEverything(TRUE))
            
            ## only have the smoother slider enabled if the
            ## smoother checkbox is ticked
            if (!svalue(smthChk)) {
                enabled(smthSlid) <- FALSE
                enabled(quantSmthChk) <- FALSE
            } else {
                if (svalue(quantSmthChk))
                    enabled(smthSlid) <- FALSE
            }

            addHandlerChanged(smthChk, handler = function(h, ...) {
                if (svalue(smthChk)) {
                    if (!svalue(quantSmthChk))
                        enabled(smthSlid) <- TRUE
                    else
                        enabled(smthSlid) <- FALSE

                    enabled(quantSmthChk) <- TRUE
                } else {
                    enabled(smthSlid) <- FALSE
                    enabled(quantSmthChk) <- FALSE
                }
                updateEverything()
            })
            ## if quantiles are used, disable slider
            addHandlerChanged(quantSmthChk,
                              handler = function(h, ...) {
                                  if (svalue(quantSmthChk)) {
                                      enabled(smthSlid) <- FALSE
                                  }
                                  else {
                                      enabled(smthSlid) <- TRUE
                                  }
                                  updateEverything()
                              })

            addHandlerChanged(linChk, handler = function(h, ...) {
                                          updateEverything()
                                      })
            addHandlerChanged(quaChk, handler = function(h, ...) {
                                          updateEverything()
                                      })
            addHandlerChanged(cubChk, handler = function(h, ...) {
                                          updateEverything()
                                      })
            addHandlerChanged(smthChk, handler = function(h, ...) {
                                           updateEverything()
                                       })
            addHandlerChanged(quantSmthChk, handler = function(h, ...) {
                                                updateEverything()
                                            })

            ## Also update the colour things
            if (auto) {
                addHandlerChanged(linCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(quaCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(cubCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(smthCol, handler = function(h, ...) updateEverything())                

                smthtimer <- NULL
                addHandlerChanged(smthSlid,
                                  handler = function(h, ...) {
                                      if (!is.null(smthtimer))
                                          smthtimer$stop_timer()
                                      smthtimer <- gtimer(800, function(...) updateEverything(), one.shot = TRUE)
                                  })

                autoCheck <- gcheckbox("Update automatically", checked = auto)
                tbl[ii, 1:2, expand = TRUE] <- autoCheck
                ii <- ii + 1

                addHandlerChanged(autoCheck, handler = function(h, ...) {
                                                 enabled(showButton) <- !svalue(autoCheck)
                                                 auto <<- svalue(autoCheck)
                                             })
            }

            tbl[ii, 1:2, expand = TRUE] <- showButton
            enabled(showButton) <- !auto

            add(optGrp, tbl)
        },
        ## Add x=y line
        opt2 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Add x=y line")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            xyline <- gcheckbox("Plot x=y line",
                                checked = curSet$LOE)
            xyCols <- c("red", "black", "blue", "green4",
                        "yellow", "pink", "grey", "orange")
            xyCol <- gcombobox(xyCols,
                               selected = which(
                                   curSet$col.LOE == xyCols
                                   )
                               )
            tbl[ii, 1, expand = TRUE] <- xyline
            tbl[ii, 2, expand = TRUE] <- xyCol
            ii <- ii + 1

            updateEverything <- function() {
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(LOE = svalue(xyline),
                         col.LOE = svalue(xyCol))
                    )
                updateSettings()
            }

            addHandlerChanged(xyline, handler = function(h, ...) updateEverything())
            addHandlerChanged(xyCol, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## change plot appearance
        opt3 = function() {
            tbl <- glayout()
            ii <- 3

            ## Default settings
            defts <- iNZightPlots:::inzpar()
            
            ## PLOT APPEARANCE
            lbl <- glabel("Change plot appearance")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii,  1:2, anchor = c(-1,-1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            ## PLOT TYPE
            lbl <- glabel("Plot Type :")
            
            plotTypes <- c("default", "scatter plot", "grid-density plot", "hexbin plot")
            plotTypeValues <- list("default", "scatter", "grid", "hex")
            plotTypeList <- gcombobox(
                plotTypes,
                selected = which(plotTypeValues == curSet$plottype)
                )
            
            addHandlerChanged(plotTypeList, handler = function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(plottype = plotTypeValues[[svalue(plotTypeList, index = TRUE)]])
                    )
                updateSettings()

                plType <- svalue(plotTypeList, index = TRUE)
                if (plType == 2 | plType == 3 | (plType == 1 & GUI$plotType != "hex")) {
                    switch(GUI$plotType,
                           "scatter" = iNZScatterMod$new(GUI, which = 7),
                           "grid" = iNZGriddenMod$new(GUI, which = 3))
                }
            })
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- plotTypeList
            ii <- ii + 1


            ## BACKGROUND COLOUR
            lbl <- glabel("Background colour :")
            
            backgroundCols <- c(defts$bg, "antiquewhite",
                                "azure3", "bisque", "cornsilk", "darkolivegreen2",
                                "darkslategray1", "greenyellow", "lightblue1",
                                "lightpink", "rosybrown1", "slategray1", "thistle1",
                                "wheat1")
            backgroundColList <- gcombobox(
                backgroundCols,
                selected = ifelse(
                    is.na(which(backgroundCols == curSet$bg)[1]),
                    1,
                    which(backgroundCols == curSet$bg)[1]),
                editable = TRUE)
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- backgroundColList
            ii <- ii + 1


            ## HEX SIZE
            lbl <- glabel("Hex grid size :")
            hexSlider <- gslider(from = 5, to = 70,
                                 by = 1, value = curSet$hex.bins)
            tbl[ii, 1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- hexSlider
            ii <- ii + 1


            updateEverything <- function(update = auto) {
                ## To easily diable automatic updating of plot, add this argument,
                ## otherwise would have to block/unblock handlers
                if (!update)
                    return()
                
                GUI$getActiveDoc()$setSettings(
                    list(bg = svalue(backgroundColList),
                         hex.bins = svalue(hexSlider)
                         )
                    )
                updateSettings()
            }

            ii <- ii + 1
            showButton <- gbutton("Show Changes",
                                  handler = function(h, ...) updateEverything(TRUE))
            if (auto) {
                bcoltimer <- NULL
                addHandlerChanged(backgroundColList,
                                  handler = function(h, ...) {
                                      if (!is.null(bcoltimer))
                                          bcoltimer$stop_timer()
                                      bcoltimer <- gtimer(500, function(...) {
                                                               if (nchar(svalue(backgroundColList)) >= 3)
                                                                   updateEverything()
                                                           }, one.shot = TRUE)
                                  })
                
                hextimer <- NULL
                addHandlerChanged(hexSlider,
                                  handler = function(h, ...) {
                                      if (!is.null(hextimer))
                                          hextimer$stop_timer()
                                      hextimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })

                autoCheck <- gcheckbox("Update automatically", checked = auto)
                tbl[ii, 1:2, expand = TRUE] <- autoCheck
                ii <- ii + 1

                addHandlerChanged(autoCheck, handler = function(h, ...) {
                                                 enabled(showButton) <- !svalue(autoCheck)
                                                 auto <<- svalue(autoCheck)
                                             })
            }
            
            
            tbl[ii, 1:2, expand = TRUE] <- showButton
            enabled(showButton) <- !auto
            
            add(optGrp, tbl)
        },
        opt4 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Customize Labels")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            

            curPlSet <- GUI$getActiveDoc()$getSettings()
            oldMain <- curPlSet$main
            oldX <- curPlSet$xlab
            oldY <- curPlSet$ylab
            if (is.null(oldMain)) oldMain <- ''
            if (is.null(oldX)) oldX <- ''
            if (is.null(oldY)) oldY <- ''

            lbl    <- glabel("Main title :")
            labMain <- gedit(oldMain)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labMain
            ii <- ii + 1
            
            lbl    <- glabel("x-axis label :")
            labX    <- gedit(oldX)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labX
            ii <- ii + 1

            lbl    <- glabel("y-axis label :")
            labY    <- gedit(oldY)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labY
            ii <- ii + 1
            

            lbl <- glabel("Enter a single space to print no label\nLeave blank to print default label")
            font(lbl) <- list(family = "normal",
                               size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            lbl <- glabel("Press ENTER/RETURN to apply changes")
            font(lbl) <- list(family = "normal", size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl

            
            updateEverything <- function() {
                mlab <- svalue(labMain)
                xlab <- svalue(labX)
                ylab <- svalue(labY)
                GUI$getActiveDoc()$setSettings(
                    list(main = if (mlab != '') mlab else NULL,
                         xlab = if (xlab != '') xlab else NULL,
                         ylab = if (ylab != '') ylab else NULL)
                    )
                updateSettings()
            }
            
            addHandlerChanged(labMain, handler = function(h, ...) updateEverything())
            addHandlerChanged(labX, handler = function(h, ...) updateEverything())
            addHandlerChanged(labY, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Adjust axis limits
        opt5 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Adjust Axis Limits")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            pl <- GUI$curPlot
            xlim <- if (is.null(curSet$xlim))
                pl$xlim
            else
                curSet$xlim
            ylim <- if (is.null(curSet$ylim))
                pl$ylim
            else
                curSet$ylim
           
            lbl <- glabel("x-axis: ")
            xlower <- gedit(xlim[1])
            xupper <- gedit(xlim[2])
            tbl[ii, 1, expand = TRUE, fill = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- xlower
            tbl[ii, 3, expand = TRUE] <- xupper
            ii <- ii + 1

            lbl <- glabel("y-axis: ")
            ylower <- gedit(ylim[1])
            yupper <- gedit(ylim[2])
            tbl[ii, 1, expand = TRUE, fill = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- ylower
            tbl[ii, 3, expand = TRUE] <- yupper
            ii <- ii + 1

            errlbl <- glabel("Limits must be numbers.")
            tbl[ii, 1:3] <- errlbl
            visible(errlbl) <- FALSE

            updateEverything <- function() {
                err <- FALSE
                xl <- suppressWarnings(as.numeric(svalue(xlower)))
                if (is.na(xl)) {
                    xl <- xlim[1]
                    err <- TRUE
                }
                xu <- suppressWarnings(as.numeric(svalue(xupper)))
                if (is.na(xu)) {
                    xu <- xlim[2]
                    err <- TRUE
                }

                yl <- suppressWarnings(as.numeric(svalue(ylower)))
                if (is.na(yl)) {
                    yl <- ylim[1]
                    err <- TRUE
                }
                yu <- suppressWarnings(as.numeric(svalue(yupper)))
                if (is.na(yu)) {
                    yu <- ylim[2]
                    err <- TRUE
                }

                visible(errlbl) <- err
                    
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(xlim = c(xl, xu),
                         ylim = c(yl, yu))
                    )
                updateSettings()
            }

            timer <- NULL
            updT <- function(h, ...) {
                if (!is.null(timer))
                    timer$stop_timer()
                timer <- gtimer(800, function(...) updateEverything(), one.shot = TRUE)
            }
            addHandlerKeystroke(xlower, updT)
            addHandlerKeystroke(xupper, updT)
            addHandlerKeystroke(ylower, updT)
            addHandlerKeystroke(yupper, updT)
            
            add(optGrp, tbl)

            resetGrp <- ggroup(cont = optGrp)
            addSpring(resetGrp)
            resetbtn <- gbutton("Reset", cont = resetGrp)
            addHandlerClicked(resetbtn, function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(xlim = NULL, ylim = NULL)
                    )
                updateSettings()

                ## reset the values in the boxes:
                pl <- GUI$curPlot
                xlim <-pl$xlim
                ylim <- pl$ylim

                svalue(xlower) <- xlim[1]
                svalue(xupper) <- xlim[2]
                svalue(ylower) <- ylim[1]
                svalue(yupper) <- ylim[2]
            })
        })
    )










iNZPlotMod <- setRefClass(
    "iNZPlotMod",
    contains = "iNZPlotModWin",
    methods = list(
        initialize = function(GUI, which = 1) {
            callSuper(GUI)
            ## need to specify the methods that we want to use in
            ## do.call later on (see changeOpts())
            pageMethods <<- list("Customise Plot Appearance" = appearance,
                                 "Trend Lines and Curves" = features,
                                 "Axes and Labels" = axes,
                                 "Identify Points" = identify,
                                iNZLocatePoints)
            ## do.call(usingMethods, pageMethods)
            usingMethods(appearance, features, identify, axes, iNZLocatePoints)
            opts <- gcombobox(names(pageMethods[names(pageMethods) != ""]),
                              selected = which)
            add(radioGrp, opts, expand = TRUE, fill = TRUE)
            pageMethods[[which]]()
            addHandlerChanged(opts,
                              handler = function(h, ...) {
                                  changeOpts(svalue(h$obj,
                                                    index = TRUE))
                              })
        },
        changeOpts = function(index) {
            ## delete current displayed options
            invisible(sapply(optGrp$children, function(x) delete(optGrp, x)))
            pageMethods[[index]]()
        },
        ## Following are the different views for the Add to Plot window:
        appearance = function() {
            tbl <- glayout(spacing = 3)
            ii <- 3

            ## Default settings
            defts <- iNZightPlots:::inzpar()
            TYPE <- #curSet$plottype  # GUI$plotType
                PLOTTYPE <- GUI$plotType
            
            ## ----- GENERAL APPEARANCE ----------------------------------------------------------
            ##
            ##        Plot type : [default, scatter, hex, grid-density]
            ## Background color : [default->"#cccccc", white, darkgrey->"grey25", ...]
            ##  Overal size cex :  0-----------------|-1
            ## 
            ## -----------------------------------------------------------------------------------
            tbl[ii,  1:6, anchor = c(-1,-1), expand = TRUE] <- sectionTitle("General Appearance")
            ii <- ii + 1

            ## PLOT TYPE
            lbl <- glabel("Plot type :")
            
            PLOTTYPES <- list(#default = "default",
                              scatter = "scatter",
                              grid    = "grid-density",
                              hex     = "hexagonal binning")
            
            plotTypes <- do.call(c, PLOTTYPES)
            plotTypeValues <- names(PLOTTYPES)
            plotTypeList <- gcombobox(
                plotTypes,
                selected = which(plotTypeValues == TYPE)
                )
            
            addHandlerChanged(plotTypeList, handler = function(h, ...) {
                newSet <- list(plottype = plotTypeValues[[svalue(plotTypeList, index = TRUE)]])
                if (!is.null(curSet$colby)) {
                    ## when switching scatter <-> hex, need to swtich numeric colby <-> factor colby
                    newSet$colby <-
                        if (newSet$plottype == "hex")
                            iNZightPlots::convert.to.factor(curSet$colby)
                        else
                            GUI$getActiveData()[[curSet$varnames$colby]]
                }
                GUI$getActiveDoc()$setSettings(newSet)
                updateSettings()

                plType <- svalue(plotTypeList, index = TRUE)
                if (curSet$plottype != TYPE) {
                    iNZPlotMod$new(GUI, which = 1)
                }
            })
            
            tbl[ii,  1:2, anchor = c(1, 0), expand = TRUE] <- lbl
            tbl[ii,  3:6, expand = TRUE] <- plotTypeList
            ii <- ii + 1


            ## BACKGROUND COLOUR
            lbl <- "Background colour :"
            bgCols <- do.call(c, bgColours)
            bgCol <- gcombobox(names(bgColours), selected = 1, editable = TRUE)
            if (curSet$bg %in% bgCols)
                if (which(bgCols == curSet$bg)[1] > 1)
                    svalue(bgCol) <- curSet$bg
            tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
            tbl[ii, 3:6, expand = TRUE] <- bgCol
            ii <- ii + 1


            ## OVERALL CEX
            lbl <- "Overall size scale :"
            cexMain <- gslider(0.5, 2, by = 0.05, value = curSet$cex)
            tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
            tbl[ii, 3:6, expand = TRUE] <- cexMain
            
            ii <- ii + 1
            ## ----- POINT SIZE ------------------------------------------------------------------
            ##
            ##          Size by : [ { select variable (numerical) } ]                       [s]
            ##    Sizing method : [proportional, emphasize]                                 [s]
            ##                    (info text)
            ##     Overall size : 0------|-------------3                                    [s,h,g]
            ##            Style : [size, alpha]                                             [h]
            ##
            ## -----------------------------------------------------------------------------------
            if (PLOTTYPE == "scatter") {
                tbl[ii,  1:6, anchor = c(-1, 0), expand = TRUE] <- sectionTitle("Point Size")
                ii <- ii + 1

                ## OVERALL SIZE
                lbl <- glabel("Overall :")
                cexPt <- gslider(from = 0.05, to = 3.5,
                                 by = 0.05, value = curSet$cex.pt)
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
                tbl[ii, 3:6, expand = TRUE] <- cexPt
                ii <- ii + 1

                ## SIZE BY
                lbl <- glabel("Resize points by :")
                sizeVarNames <- names(GUI$getActiveData())[sapply(GUI$getActiveData(), is.numeric)]
                sizeVar <-
                    gcombobox(c("", sizeVarNames),
                              selected = ifelse(
                                  is.null(curSet$sizeby),
                                  1, which(sizeVarNames == curSet$varnames$sizeby)[1] + 1
                                  ))
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
                tbl[ii, 3:6, expand = TRUE] <- sizeVar
                ii <- ii + 1

                ## RESIZE METHOD
                resizeLbl <- glabel("Resize method :")
                sizeMethods <- c("proportional", "emphasize")
                sizeMethod <- gcombobox(sizeMethods,
                                        selected = which(sizeMethods == curSet$resize.method))
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- resizeLbl
                tbl[ii, 3:6, expand = TRUE] <- sizeMethod
                visible(resizeLbl) <- visible(sizeMethod) <- svalue(sizeVar, index = TRUE) > 1
                ii <- ii + 1

                sizeDescs <- list(method1 =
                                      c("Points area proportional to value of variable."),
                                  method2 =
                                      c("Point area linearly sized from 0.25 to 4.",
                                        "Good for exaggerating trends."))
                sizeDesc <- glabel(paste(sizeDescs[[svalue(sizeMethod, index = TRUE)]]))
                tbl[ii, 1:6, anchor = c(1, 0), expand = TRUE] <- sizeDesc
                visible(sizeDesc) <- visible(resizeLbl)
                ii <- ii + 1
                
            } else {
                tbl[ii,  1:6, anchor = c(-1, 0), expand = TRUE] <- sectionTitle("Size")
                ii <- ii + 1
                
                lbl <- glabel(switch(PLOTTYPE,
                                     "hex"  = "Number of hexagons :",
                                     "grid" = "Number of grid bins :"))
                cexPt <- switch(PLOTTYPE,
                                "hex" = {
                                    gslider(from = 10, to = 80, by = 1,
                                            value = curSet$hex.bins)
                                },
                                "grid" = {
                                    gslider(from = 10, to = 250, by = 1,
                                            value = curSet$scatter.grid.bins)
                                })
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
                tbl[ii, 3:6, expand = TRUE] <- cexPt
                ii <- ii + 1
            }

            if (PLOTTYPE == "hex") {
                lbl <- glabel("Style :")
                hexStyles <- c("size", "alpha")
                hexStyle <- gcombobox(hexStyles, selected = which(hexStyles == curSet$hex.style))
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
                tbl[ii, 3:6, expand = TRUE] <- hexStyle
                ii <- ii + 1
            }

            ii <- ii + 1
            ## ----- POINT COLOUR ----------------------------------------------------------------
            ##
            ##        Colour by : [ { select variable } ]                                  [s,h]
            ##           Colour : [default->"grey50", black, white, ...]                   [s,h]
            ##         OR 
            ##   Colour palette : [default->{num->divergent_hcl, cat->rainbow_hcl}, ...]   [s,h{cat_only}]
            ##         Advanced : [ { Manual colour button for cat }, { Adjust palette }]  [s]
            ##     Transparency : 0|-------------------1                                   [s,h,g]
            ##  [o] Fill symbol interior                                                   [s]
            ## 
            ## -----------------------------------------------------------------------------------
            if (PLOTTYPE != "grid") {
                tbl[ii,  1:6, anchor = c(-1, 0), expand = TRUE] <-
                    sectionTitle(switch(PLOTTYPE, "scatter" = "Point Colour", "hex" = "Colour"))
                ii <- ii + 1
                
                ptCols <- do.call(c, pointColours)
                ptCol <- gcombobox(names(pointColours), selected = 1, editable = TRUE)
                if (curSet$col.pt %in% ptCols)
                    svalue(ptCol) <- names(pointColours)[which(ptCols %in% curSet$col.pt)[1]]
                
                colLabel <- glabel(switch(PLOTTYPE,
                                     "scatter" = "Point colour :",
                                     "hex"     = "Hexagon colour :"))
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE, fill = TRUE] <- colLabel
                tbl[ii, 3:6, expand = TRUE] <- ptCol
                ptColROW <- ii  ## save for switching later
                ii <- ii + 1

                ## Colour by
                lbl <- glabel("Colour by :")
                colVarNames <- names(GUI$getActiveData())
                #if (PLOTTYPE == "hex") {
                #    colVarNames <- colVarNames[sapply(GUI$getActiveData(), is.factor)]
                #}
                colVar <-
                    gcombobox(c("", colVarNames),
                              selected = ifelse(
                                  is.null(curSet$colby),
                                  1, which(colVarNames == curSet$varnames$colby)[1] + 1
                                  ))
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
                tbl[ii, 3:6, expand = TRUE] <- colVar
                ii <- ii + 1
                
                ## dropdown for colour palette
                palCont <- gcombobox(names(colourPalettes$cont))
                palCat <- gcombobox(names(colourPalettes$cat))
                palAdvanced <- gimagebutton(filename = system.file("images/gear.png",
                                                                   package = "iNZight"),
                                            size = "button",
                                            handler = function(h, ...) {
                                                gmessage("Advanced colour palette options ...")
                                            })
                tbl[ptColROW, 3:5, expand = TRUE] <- palCont
                tbl[ptColROW, 3:5, expand = TRUE] <- palCat
                tbl[ptColROW, 6, anchor = c(0, 0)] <- palAdvanced

                if (!is.null(curSet$colby)) {
                    ## already set - need to match
                    cval <- curSet$varnames$colby
                    svalue(colVar) <- cval
                    visible(ptCol) <- FALSE
                    if (is.numeric(GUI$getActiveData()[[cval]]) & PLOTTYPE != "hex") {
                        visible(palCat) <- FALSE
                    } else {
                        visible(palCont) <- FALSE
                    }
                } else {
                    visible(palAdvanced) <- visible(palCont) <- visible(palCat) <- FALSE
                }

                ## Cycle through levels:
                cycleLbl <- glabel("Cycle levels :")
                cyclePanel <- ggroup()
                addSpace(cyclePanel, 10)
                cyclePrev <- gimagebutton(stock.id = "1leftarrow", container = cyclePanel,
                                          handler = function(h, ...) {
                                              nl <-
                                                  if (is.factor(curSet$colby)) length(levels(curSet$colby))
                                                  else svalue(cycleN)
                                              EMPH.LEVEL <<- ifelse(EMPH.LEVEL == 0, nl, EMPH.LEVEL - 1)
                                              updateEverything()
                                          })
                cycleNext <- gimagebutton(stock.id = "1rightarrow", container = cyclePanel,
                                          handler = function(h, ...) {
                                              nl <-
                                                  if (is.factor(curSet$colby)) length(levels(curSet$colby))
                                                  else svalue(cycleN)
                                              EMPH.LEVEL <<- ifelse(EMPH.LEVEL == nl, 0, EMPH.LEVEL + 1)
                                              updateEverything()
                                          })
                addSpace(cyclePanel, 20)
                cycleStop <- gimagebutton(filename = system.file("images/icon-undo.png", package = "iNZight"),
                                          container = cyclePanel,
                                          handler = function(h, ...) {
                                              EMPH.LEVEL <<- 0
                                              updateEverything()
                                          })
                addSpace(cyclePanel, 20)
                cycleNlab <- glabel("# quantiles :", container = cyclePanel)
                font(cycleNlab) <- list(size = 9)
                cycleN <- gspinbutton(4, 10, by = 1, container = cyclePanel)

                visible(cycleLbl) <- visible(cyclePanel) <- !is.null(curSet$colby)
                if (is.numeric(curSet$colby)) {
                    svalue(cycleLbl) <- "Cycle quantiles :"
                } else {
                    visible(cycleNlab) <- visible(cycleN) <- FALSE
                }
                
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- cycleLbl
                tbl[ii, 3:6, expand = TRUE] <- cyclePanel
                ii <- ii + 1
            }

            if (PLOTTYPE == "scatter") {
                lbl <- glabel("Transparency :")
                transpSlider <- gslider(from = 0, to = 100,
                                        by = 1, value = 100 * (1 - curSet$alpha))
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
                tbl[ii, 3:6, expand = TRUE] <- transpSlider
                ii <- ii + 1

                transpWarning <- glabel(paste("Warning: transparency may freeze iNZight.  ",
                                              "Use circle symbols to avoid this.",
                                              sep = "\n"))
                font(transpWarning) <- list(size = 9)
                tbl[ii, 1:6, anchor = c(1, 0), expand = TRUE] <- transpWarning
                visible(transpWarning) <- FALSE
                ii <- ii + 1
            }

            ii <- ii + 1
            ## ----- POINT SYMBOL ----------------------------------------------------------------
            ##
            ##  [ ] Match symbol to colour-by variable (if categorical, otherwise disabled)  [s]
            ##  {if unchecked:}
            ##          Code by : [ { select variable (categorical) } ]
            ##                    [ { Specify Symbols} ]
            ## 
            ## -----------------------------------------------------------------------------------
            if (PLOTTYPE == "scatter") {
                tbl[ii,  1:6, anchor = c(-1, 0), expand = TRUE] <- sectionTitle("Point Symbol")
                ii <- ii + 1

                ## MATCH SYMBOL and COLOUR BY
                pchMatch <- gcheckbox("Match with colour variable",
                                      selected = FALSE)#curSet$match.pch)
                tbl[ii, 1:6, anchor = c(-1, 0)] <- pchMatch
                ii <- ii + 1
                
                pchMsg <- glabel("(requires categorical variable with 5 or fewer levels)")
                font(pchMsg) <- list(size = 8)
                tbl[ii, 1:6, anchor = c(-1, 0), expand = TRUE] <- pchMsg
                ii <- ii + 1

                symbolMatch <- function() {
                    visible(pchMsg) <- visible(pchMatch) <- svalue(colVar, TRUE) > 1
                    if (visible(pchMatch)) {
                        enabled(pchMatch) <- length(levels(GUI$getActiveData()[[svalue(colVar)]])) %in% 1:5
                        visible(pchMsg) <- !enabled(pchMatch)
                    }
                }
                symbolMatch()
                

                lbl <- glabel("Symbol :")
                symbolList <- list(circle = 21,
                                   square = 22,
                                   diamond = 23,
                                   triangle = 24,
                                   'inverted triangle' = 25)
                symVals <- do.call(c, symbolList) 
                symPch <- gcombobox(names(symbolList), selected = 1)
                if (curSet$pch %in% symVals) svalue(symPch, TRUE) <- which(symVals == curSet$pch)
                visible(transpWarning) <- svalue(symPch, index = TRUE) %in% c(3:5)
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
                tbl[ii, 3:6] <- symPch
                ii <- ii + 1

                symVars <- colnames(GUI$getActiveData())[sapply(GUI$getActiveData(), function(x) length(levels(x)) %in% 1:5)]
                lbl <- glabel("Symbol by :")
                symVar <- gcombobox(c("", symVars), selected = 1)
                if (length(symVars) >= 1) {
                    tbl[ii, 1, anchor = c(1, 0), expand = TRUE] <- lbl
                    tbl[ii, 2:6] <- symVar
                    ii <- ii + 1
                }
                
                enabled(symVar) <- enabled(symPch) <- !svalue(pchMatch)

                ## Fill Symbols + line width
                lbl <- glabel("Symbol line width :")
                symLwd <- gspinbutton(1, 4, by = 1, value = curSet$lwd.pt)
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
                tbl[ii, 3:4] <- symLwd
                
                fillSym <- gcheckbox("Fill symbols", checked = curSet$fill.pt == "fill")
                enabled(fillSym) <- svalue(transpSlider) == 0
                tbl[ii, 5:6, anchor = c(-1, 0)] <- fillSym
                ii <- ii + 1
            }
            
            updateEverything <- function(update = auto) {
                ## To easily diable automatic updating of plot, add this argument,
                ## otherwise would have to block/unblock handlers
            ##     if (!update)
            ##         return()

                ## Things that don't need checking:
                newSet <- list(cex = svalue(cexMain))
                
                ## General appearance:
                newSet$bg <-
                    if (svalue(bgCol) %in% names(bgColours))
                        bgColours[[svalue(bgCol, index = TRUE)]]
                    else if (!inherits(try(col2rgb(svalue(bgCol)), silent = TRUE), "try-error"))
                        svalue(bgCol)
                    else
                        curSet$bg
                
                ## Size
                newSet[[switch(PLOTTYPE,
                               "scatter" = "cex.pt",
                               "grid" = "scatter.grid.bins",
                               "hex" = "hex.bins")]] <- svalue(cexPt)
                if (PLOTTYPE == "scatter") {
                    newSet <- c(newSet, list(sizeby = GUI$getActiveData()[[svalue(sizeVar)]]))
                    newSet$varnames <- c(newSet$varnames,
                                         list(sizeby = svalue(sizeVar)))
                    newSet$resize.method <- svalue(sizeMethod)
                }
                if (PLOTTYPE == "hex")
                    newSet <- c(newSet, list(hex.style = svalue(hexStyle)))

                ## Colour
                if (PLOTTYPE != "grid") {
                    if (svalue(colVar, TRUE) > 1) {
                        ## colouring by a variable - and a palette
                        newSet$colby <-
                            if (PLOTTYPE == "hex")
                                iNZightPlots::convert.to.factor(
                                    GUI$getActiveData()[[svalue(colVar)]])
                            else GUI$getActiveData()[[svalue(colVar)]]
                        newSet$varnames <- c(newSet$varnames,
                                             list(colby = svalue(colVar)))
                        newSet$col.fun <-
                            if (EMPH.LEVEL > 0)
                                function(n)
                                    colourPalettes$emphasize(
                                        n, k = EMPH.LEVEL, cat = is.factor(newSet$colby),
                                        ncat = svalue(cycleN),
                                        fn = if (is.numeric(newSet$colby))
                                                 colourPalettes$cont[[svalue(palCont)]]
                                             else colourPalettes$cat[[svalue(palCat)]]
                                    )
                            else if (is.numeric(newSet$colby))
                                colourPalettes$cont[[svalue(palCont)]]
                            else colourPalettes$cat[[svalue(palCat)]]

                        newSet$plot.features <- list(order.first = NULL)
                        if (EMPH.LEVEL > 0) {
                            ## need to add "order.first" to plot features:
                            if (is.factor(newSet$colby)) {
                                newSet$plot.features <-
                                    list(order.first = which(newSet$colby ==
                                                             levels(newSet$colby)[EMPH.LEVEL]))
                            } else if (is.numeric(newSet$colby)) {
                                Qs <- seq(min(newSet$colby, na.rm = TRUE),
                                          max(newSet$colby, na.rm = TRUE),
                                          length = svalue(cycleN) + 1)
                                newSet$plot.features <-
                                    list(order.first = which(newSet$colby >= Qs[EMPH.LEVEL] &
                                                             newSet$colby < Qs[EMPH.LEVEL + 1]))
                            }
                        }
                        
                        visible(cycleLbl) <- visible(cyclePanel) <- TRUE
                        visible(cycleNlab) <- visible(cycleN) <- is.numeric(newSet$colby)
                        svalue(cycleLbl) <- ifelse(visible(cycleN),
                                                   "Cycle quantiles :", "Cycle levels :")
                    } else {
                        newSet <- c(newSet, list(colby = NULL))
                        newSet$varnames <- c(newSet$varnames, list(colby = NULL))
                        newSet$col.pt <- 
                            if (svalue(ptCol) %in% names(pointColours))
                                pointColours[[svalue(ptCol, index = TRUE)]]
                            else if (!inherits(try(col2rgb(svalue(ptCol)), silent = TRUE),
                                               "try-error"))
                                svalue(ptCol)
                            else
                                curSet$col.pt

                        visible(cycleLbl) <- visible(cyclePanel) <- FALSE
                    }
                }
                if (PLOTTYPE == "scatter") {
                    newSet$alpha <- 1 - svalue(transpSlider) / 100
                }

                ## Plotting Symbol
                if (PLOTTYPE == "scatter") {
                    newSet <- c(newSet, list(symbolby = NULL))
                    newSet$varnames <- c(newSet$varnames, list(symbolby = NULL))
                    if (svalue(pchMatch) & !is.null(newSet$colby)) {
                        if (length(levels(newSet$colby)) %in% 1:5) {
                            newSet$symbolby <- newSet$colby
                            newSet$varnames$symbolby = newSet$varnames$colby
                        }
                    } else if (svalue(symVar, TRUE) > 1) {
                        newSet$symbolby <- GUI$getActiveData()[[svalue(symVar)]]
                        newSet$varnames$symbolby <- svalue(symVar)
                    }
                    newSet$pch <- symVals[svalue(symPch, index = TRUE)]
                    newSet$fill.pt <- ifelse(svalue(fillSym), "fill", "transparent")
                    newSet$lwd.pt <- svalue(symLwd)
                }
                
                GUI$getActiveDoc()$setSettings(newSet)
                updateSettings()
            }

            if (TRUE) { ## if (auto) {
                bgtimer <- NULL
                addHandlerChanged(bgCol,
                                  handler = function(h, ...) {
                                      if (!is.null(bgtimer))
                                          bgtimer$stop_timer()
                                      bgtimer <- gtimer(500, function(...) {
                                                            if (nchar(svalue(bgCol)) >= 3)
                                                                updateEverything()
                                                        }, one.shot = TRUE)
                                  })
                mcextimer <- NULL
                addHandlerChanged(cexMain,
                                  handler = function(h, ...) {
                                      if (!is.null(mcextimer))
                                          mcextimer$stop_timer()
                                      mcextimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })

                ptcextimer <- NULL
                addHandlerChanged(cexPt,
                                  handler = function(h, ...) {
                                      if (!is.null(ptcextimer))
                                          ptcextimer$stop_timer()
                                      ptcextimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })

                if (PLOTTYPE == "scatter") {
                    addHandlerChanged(sizeVar, handler = function(h, ...) {
                        visible(sizeDesc) <- visible(resizeLbl) <- visible(sizeMethod) <-
                            svalue(sizeVar, index = TRUE) > 1
                        
                        updateEverything()
                    })
                    addHandlerChanged(sizeMethod, handler = function(h, ...) {
                        svalue(sizeDesc) <- paste(sizeDescs[[svalue(sizeMethod, index = TRUE)]])
                        updateEverything()
                    })
                }
                if (PLOTTYPE == "hex") {
                    addHandlerChanged(hexStyle, handler = function(h, ...) updateEverything())
                }

                if (PLOTTYPE != "grid") {
                    pcoltimer <- NULL
                    addHandlerChanged(ptCol,
                                      handler = function(h, ...) {
                                          if (!is.null(pcoltimer))
                                              pcoltimer$stop_timer()
                                          pcoltimer <- gtimer(500, function(...) {
                                                                  if (nchar(svalue(ptCol)) >= 3)
                                                                      updateEverything()
                                                              }, one.shot = TRUE)
                                      })
                    addHandlerChanged(colVar, handler = function(h, ...) {
                                          EMPH.LEVEL <<- 0
                                          if (PLOTTYPE == "scatter") symbolMatch()
                                          if (svalue(h$obj, index = TRUE) == 1) {
                                              svalue(colLabel) <- "Point colour :"
                                              visible(palAdvanced) <- visible(palCont) <-
                                                  visible(palCat) <- FALSE
                                              visible(ptCol) <- TRUE
                                          } else {
                                              svalue(colLabel) <- "Palette :"
                                              visible(ptCol) <- FALSE
                                              if (is.numeric(GUI$getActiveData()[[svalue(h$obj)]]) &
                                                  PLOTTYPE != "hex") {
                                                  visible(palCat) <- FALSE
                                                  visible(palCont) <- TRUE
                                              } else {
                                                  visible(palCont) <- FALSE
                                                  visible(palCat) <- TRUE
                                              }
                                              visible(palAdvanced) <- TRUE
                                          }
                                          updateEverything()
                                      })
                    addHandlerChanged(palCat, handler = function(h, ...) updateEverything())
                    addHandlerChanged(palCont, handler = function(h, ...) updateEverything())
                }
                if (PLOTTYPE == "scatter") {
                    transptimer <- NULL
                    addHandlerChanged(transpSlider,
                                      handler = function(h, ...) {
                                          enabled(fillSym) <- svalue(transpSlider) == 0
                                          if (!is.null(transptimer))
                                              transptimer$stop_timer()
                                          transptimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                      })
                }

                if (PLOTTYPE == "scatter") {
                    addHandlerChanged(pchMatch, handler = function(h, ...) {
                                          enabled(symVar) <- enabled(symPch) <- !svalue(pchMatch)
                                          updateEverything()
                                      })
                    addHandlerChanged(symPch, handler = function(h, ...) {
                        if (svalue(symPch, index = TRUE) %in% c(3:5) && nrow(GUI$getActiveData()) > 2000) {
                            ## TRANSPARENCY VERY SLOW!
                            if (svalue(transpSlider) > 0) {
                                gmessage("Transparency reset to zero.\n\nWARNING: drawing can be VERY slow if using transparent symbols that are NOT circles or squares.")
                                blockHandlers(transpSlider)
                                svalue(transpSlider) <- 0
                                unblockHandlers(transpSlider)
                            }
                            visible(transpWarning) <- TRUE
                        } else {
                            visible(transpWarning) <- FALSE
                        }
                        updateEverything()
                    })
                    addHandlerChanged(symVar, handler = function(h, ...) updateEverything())
                    addHandlerChanged(symLwd, handler = function(h, ...) updateEverything())
                    addHandlerChanged(fillSym, handler = function(h, ...) updateEverything())
                }
            }

            add(optGrp, tbl)

            
        },
        features = function() {
            tbl <- glayout()
            ii <- 3

            PLOTTYPE <- GUI$plotType
            
            ## PLOT APPEARANCE
            tbl[ii,  1:6, anchor = c(-1,-1), expand = TRUE] <- sectionTitle("Trend Curves")
            ii <- ii + 1

            lineColours <- c("red", "black", "blue", "green4", "magenta",
                             "yellow", "pink", "grey", "orange")

            trendCurves <- c("linear", "quadratic", "cubic")
            trendLin <- gcheckbox("linear", selected = "linear" %in% curSet$trend)
            trendLinCol <- gcombobox(lineColours, editable = TRUE,
                                     selected =
                                         if (curSet$col.trend$linear %in% lineColours)
                                             which(lineColours == curSet$col.trend$linear)
                                         else 1)
            tbl[ii, 1:3, anchor = c(-1, 0), expand = TRUE] <- trendLin
            tbl[ii, 4:6] <- trendLinCol
            ii <- ii + 1

            trendQuad <- gcheckbox("quadratic", selected = "quadratic" %in% curSet$trend)
            trendQuadCol <- gcombobox(lineColours, editable = TRUE,
                                      selected =
                                          if (curSet$col.trend$quadratic %in% lineColours)
                                              which(lineColours == curSet$col.trend$quadratic)
                                          else 1)
            tbl[ii, 1:3, anchor = c(-1, 0), expand = TRUE] <- trendQuad
            tbl[ii, 4:6] <- trendQuadCol
            ii <- ii + 1

            trendCub <- gcheckbox("cubic", selected = "cubic" %in% curSet$trend)
            trendCubCol <- gcombobox(lineColours, editable = TRUE,
                                      selected =
                                          if (curSet$col.trend$cubic %in% lineColours)
                                              which(lineColours == curSet$col.trend$cubic)
                                          else 1)
            tbl[ii, 1:3, anchor = c(-1, 0), expand = TRUE] <- trendCub
            tbl[ii, 4:6] <- trendCubCol
            ii <- ii + 1


            ii <- ii + 1
            tbl[ii,  1:6, anchor = c(-1,-1), expand = TRUE] <- sectionTitle("Smoother")
            ii <- ii + 1

            smooth <- gcheckbox("Add smoother",
                                checked = curSet$smooth != 0 | !is.null(curSet$quant.smooth))
            smoothCol <- gcombobox(lineColours, editable = TRUE,
                                   selected =
                                       if (curSet$col.smooth %in% lineColours)
                                           which(lineColours == curSet$col.smooth)
                                       else 1)
            tbl[ii, 1:3, anchor = c(-1, 0), expand = TRUE] <- smooth
            tbl[ii, 4:6] <- smoothCol
            ii <- ii + 1

            qsmooth <- gcheckbox("Use Quantiles",
                                 checked = !is.null(curSet$quant.smooth))
            tbl[ii, 1:3, anchor = c(-1, 0), expand = TRUE] <- qsmooth

            smoothF <- gslider(from = 0.1, to = 1, by = 0.01,
                               value = ifelse(curSet$smooth == 0, 0.7, curSet$smooth))
            tbl[ii, 4:6] <- smoothF
            ii <- ii + 1

            visible(qsmooth) <- visible(smoothF) <- svalue(smooth)
            enabled(smoothF) <- !svalue(qsmooth)

            if (PLOTTYPE == "scatter") {
                ## join points
                tbl[ii,  1:6, anchor = c(-1,-1), expand = TRUE] <- sectionTitle("Join Points")
                ii <- ii + 1
                
                joinPoints <- gcheckbox("Join points by lines", checked = curSet$join)
                joinPointsCol <- gcombobox(lineColours, editable = TRUE,
                                           selected =
                                               if (curSet$col.line %in% lineColours)
                                                   which(lineColours == curSet$col.line)
                                               else 1)
                tbl[ii, 1:3, anchor = c(-1, 0), expand = TRUE] <- joinPoints
                tbl[ii, 4:6] <- joinPointsCol
                ii <- ii + 1
                
                if (is.factor(curSet$colby)) {
                    joinPointsBy <- gcheckbox(paste("For each level of", curSet$varnames$colby),
                                              selected = curSet$lines.by)
                    tbl[ii, 1:6, anchor = c(-1, 0), expand = TRUE] <- joinPointsBy
                    ii <- ii + 1
                }
            }
            
            ## extra settings ...
            tbl[ii,  1:6, anchor = c(-1,-1), expand = TRUE] <- sectionTitle("Trend Line Options")
            ii <- ii + 1

            ## For each level of COLBY
            if (is.factor(curSet$colby)) {
                trendBy <- gcheckbox(paste("For each level of", curSet$varnames$colby),
                                     checked = curSet$trend.by)
                trendParallel <- gcheckbox("Parallel trend lines (common slope)",
                                           checked = curSet$trend.parallel)
                tbl[ii, 1:6] <- trendBy
                ii <- ii + 1
                tbl[ii, 1:6] <- trendParallel
                ii <- ii + 1
            }
            activateOptions <- function() {
                if (is.factor(curSet$colby)) {
                    if (PLOTTYPE == "scatter") {
                        enabled(joinPointsBy) <- svalue(joinPoints)
                        enabled(joinPointsCol) <- !svalue(joinPointsBy)
                    }
                    enabled(trendBy) <- svalue(trendLin) | svalue(trendQuad) | svalue(trendCub) |
                        (svalue(smooth) & !svalue(qsmooth))
                    enabled(trendParallel) <- svalue(trendBy) &
                        (svalue(trendLin) | svalue(trendQuad) | svalue(trendCub))
                    
                    enabled(trendLinCol) <- enabled(trendQuadCol) <- enabled(trendCubCol) <-
                        enabled(smoothCol) <- !(enabled(trendBy) & svalue(trendBy))
                }
            }
            activateOptions()

            lbl <- glabel("Line Width Multiplier :")
            lwdSpin <- gspinbutton(1, 4, by = 1, value = curSet$lwd)
            tbl[ii, 1:3, anchor = c(1, 0), expand = TRUE] <- lbl
            tbl[ii, 4, anchor = c(-1, 0), expand = FALSE] <- lwdSpin
            ii <- ii + 1

            loe <- gcheckbox("Add line of equality (x = y)", checked = curSet$LOE)
            tbl[ii, 1:6, anchor = c(-1, 0), expand = TRUE] <- loe
            ii <- ii + 1
            

            updateEverything <- function(update = auto) {
                ## To easily diable automatic updating of plot, add this argument,
                ## otherwise would have to block/unblock handlers
                ##     if (!update)
                ##         return()
                activateOptions()

                ## Things that don't need checking:
                newSet <- list(trend = trendCurves[c(svalue(trendLin),
                                                     svalue(trendQuad),
                                                     svalue(trendCub))],
                               LOE = svalue(loe))
                
                ## Trend line colours - editable:
                tCols <- curSet$col.trend
                if (!inherits(try(col2rgb(svalue(trendLinCol)), silent = TRUE), "try-error"))
                    tCols$linear <- svalue(trendLinCol)
                if (!inherits(try(col2rgb(svalue(trendQuadCol)), silent = TRUE), "try-error"))
                    tCols$quadratic <- svalue(trendQuadCol)
                if (!inherits(try(col2rgb(svalue(trendCubCol)), silent = TRUE), "try-error"))
                    tCols$cubic <- svalue(trendCubCol)
                newSet$col.trend <- tCols

                qsmth <- if (svalue(qsmooth) & svalue(smooth)) "default" else NULL
                newSet <- c(newSet, list(quant.smooth = qsmth))
                newSet$smooth <- ifelse(svalue(smooth) & is.null(qsmth),
                                        svalue(smoothF), 0)

                newSet$col.smooth <-
                    if (!inherits(try(col2rgb(svalue(smoothCol)), silent = TRUE), "try-error"))
                        svalue(smoothCol)
                    else curSet$col.smooth

                if (PLOTTYPE == "scatter") {
                    newSet$join <- svalue(joinPoints)
                    if (!inherits(try(col2rgb(svalue(joinPointsCol)), silent = TRUE), "try-error"))
                        newSet$col.line <- svalue(joinPointsCol)
                }

                newSet$lines.by <- FALSE
                if (is.factor(curSet$colby)) {
                    newSet$trend.by <- svalue(trendBy)
                    newSet$trend.parallel <- svalue(trendParallel)
                    if (PLOTTYPE == "scatter")
                        newSet$lines.by <- svalue(joinPointsBy)
                }

                newSet$lwd <- svalue(lwdSpin)
                
                GUI$getActiveDoc()$setSettings(newSet)
                updateSettings()
            }

            if (TRUE) { ## if (auto) {
                addHandlerChanged(trendLin, handler = function(h, ...) updateEverything())
                addHandlerChanged(trendQuad, handler = function(h, ...) updateEverything())
                addHandlerChanged(trendCub, handler = function(h, ...) updateEverything())

                linColtimer <- NULL
                addHandlerChanged(trendLinCol,
                                  handler = function(h, ...) {
                                      if (!is.null(linColtimer))
                                          linColtimer$stop_timer()
                                      linColtimer <- gtimer(500, function(...) {
                                          if (nchar(svalue(trendLinCol)) >= 3)
                                              updateEverything()
                                      }, one.shot = TRUE)
                                  })
                quadColtimer <- NULL
                addHandlerChanged(trendQuadCol,
                                  handler = function(h, ...) {
                                      if (!is.null(quadColtimer))
                                          quadColtimer$stop_timer()
                                      quadColtimer <- gtimer(500, function(...) {
                                          if (nchar(svalue(trendQuadCol)) >= 3)
                                              updateEverything()
                                      }, one.shot = TRUE)
                                  })
                cubColtimer <- NULL
                addHandlerChanged(trendCubCol,
                                  handler = function(h, ...) {
                                      if (!is.null(cubColtimer))
                                          cubColtimer$stop_timer()
                                      cubColtimer <- gtimer(500, function(...) {
                                          if (nchar(svalue(trendCubCol)) >= 3)
                                              updateEverything()
                                      }, one.shot = TRUE)
                                  })

                addHandlerChanged(smooth, function(h, ...) {
                    visible(qsmooth) <- visible(smoothF) <- svalue(smooth)
                    enabled(smoothF) <- !svalue(qsmooth)
                    updateEverything()
                })
                addHandlerChanged(qsmooth, function(h, ...) {
                    enabled(smoothF) <- !svalue(qsmooth)
                    updateEverything()
                })
                smoothtimer <- NULL
                addHandlerChanged(smoothF,
                                  handler = function(h, ...) {
                                      if (!is.null(smoothtimer))
                                          smoothtimer$stop_timer()
                                      smoothtimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })
                smoothColtimer <- NULL
                addHandlerChanged(smoothCol,
                                  handler = function(h, ...) {
                                      if (!is.null(smoothColtimer))
                                          smoothColtimer$stop_timer()
                                      smoothColtimer <- gtimer(500, function(...) {
                                          if (nchar(svalue(smoothCol)) >= 3)
                                              updateEverything()
                                      }, one.shot = TRUE)
                                  })

                if (PLOTTYPE == "scatter") {
                    addHandlerChanged(joinPoints, function(h, ...) updateEverything())
                    joinColtimer <- NULL
                    addHandlerChanged(joinPointsCol,
                                      handler = function(h, ...) {
                                          if (!is.null(joinColtimer))
                                              joinColtimer$stop_timer()
                                          joinColtimer <- gtimer(500, function(...) {
                                              if (nchar(svalue(joinPointsCol)) >= 3)
                                                  updateEverything()
                                          }, one.shot = TRUE)
                                      })
                }
                if (is.factor(curSet$colby)) {
                    addHandlerChanged(trendBy, function(h, ...) updateEverything())
                    addHandlerChanged(trendParallel, function(h, ...) updateEverything())
                    if (PLOTTYPE == "scatter")
                        addHandlerChanged(joinPointsBy, function(h, ...) updateEverything())
                }
                

                addHandlerChanged(lwdSpin, function(h, ...) updateEverything())
                addHandlerChanged(loe, function(h, ...) updateEverything())
            }            
            
            add(optGrp, tbl)
        },
        axes = function() {
            tbl <- glayout()
            ii <- 3

            PLOTTYPE <- GUI$plotType
            
            ## AXIS LABELS
            tbl[ii,  1:2, anchor = c(-1,-1), expand = TRUE] <- sectionTitle("Axis Labels")
            ii <- ii + 1

            lbl <- glabel("Title :")
            labMain <- gedit(ifelse(is.null(curSet$main), "", curSet$main))
            tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
            tbl[ii, 3:6, expand = TRUE] <- labMain
            ii <- ii + 1
            
            lbl <- glabel("x-axis :")
            labXlab <- gedit(ifelse(is.null(curSet$xlab), "", curSet$xlab))
            tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
            tbl[ii, 3:6, expand = TRUE] <- labXlab
            ii <- ii + 1

            lbl <- glabel("y-axis :")
            labYlab <- gedit(ifelse(is.null(curSet$ylab), "", curSet$ylab))
            tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
            tbl[ii, 3:6, expand = TRUE] <- labYlab
            ii <- ii + 1

            lbl <- glabel("TAB or ENTER/RETURN to apply changes")
            font(lbl) <- list(family = "normal", size = 8)
            tbl[ii, 3:6, anchor = c(-1, 0), expand = TRUE] <- lbl
            ii <- ii + 2

            lbl <- glabel("Enter a single space to print no label\nLeave blank to print default label")
            font(lbl) <- list(family = "normal", size = 8)
            tbl[ii, 3:6, anchor = c(-1, 0), expand = TRUE] <- lbl
            ii <- ii + 1


            if (PLOTTYPE == "scatter") {
                ## JITTER and RUGS
                tbl[ii,  1:2, anchor = c(-1,-1), expand = TRUE] <- sectionTitle("Axis Features")
                ii <- ii + 1
                
                lbl <- glabel("Jitter :")
                if (any(sapply(curSet$varnames[c("x", "y")], nchar) > 15)) {
                    xJit <- gcheckbox("x-variable", checked = curSet$jitter %in% c("x", "xy"))
                    yJit <- gcheckbox("y-variable", checked = curSet$jitter %in% c("y", "xy"))
                } else {
                    xJit <- gcheckbox(curSet$varnames$y, checked = curSet$jitter %in% c("x", "xy"))
                    yJit <- gcheckbox(curSet$varnames$x, checked = curSet$jitter %in% c("y", "xy"))
                }
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
                tbl[ii, 3:4, anchor = c(-1, 0), expand = TRUE] <- xJit
                tbl[ii, 5:6, anchor = c(-1, 0), expand = TRUE] <- yJit
                ii <- ii + 1
                
                lbl <- glabel("Rugs :")
                if (any(sapply(curSet$varnames[c("x", "y")], nchar) > 15)) {
                    xRug <- gcheckbox("x-variable", checked = curSet$rug %in% c("x", "xy"))
                    yRug <- gcheckbox("y-variable", checked = curSet$rug %in% c("y", "xy"))
                } else {
                    xRug <- gcheckbox(curSet$varnames$y, checked = curSet$rug %in% c("x", "xy"))
                    yRug <- gcheckbox(curSet$varnames$x, checked = curSet$rug %in% c("y", "xy"))
                }
                tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- lbl
                tbl[ii, 3:4, anchor = c(-1, 0), expand = TRUE] <- xRug
                tbl[ii, 5:6, anchor = c(-1, 0), expand = TRUE] <- yRug
                ii <- ii + 1
            }
            

            updateEverything <- function(update = auto) {
                ## To easily diable automatic updating of plot, add this argument,
                ## otherwise would have to block/unblock handlers
                ##     if (!update)
                ##         return()
                
                ## Things that don't need checking:
                newSet <- list(main = if (svalue(labMain) == "") NULL else svalue(labMain),
                               xlab = if (svalue(labXlab) == "") NULL else svalue(labXlab),
                               ylab = if (svalue(labYlab) == "") NULL else svalue(labYlab))
                
                if (PLOTTYPE == "scatter") {
                    newSet$jitter <- paste0(ifelse(svalue(xJit), "x", ""),
                                            ifelse(svalue(yJit), "y", ""))
                    newSet$rugs <- paste0(ifelse(svalue(xRug), "x", ""),
                                            ifelse(svalue(yRug), "y", ""))
                }

                GUI$getActiveDoc()$setSettings(newSet)
                updateSettings()
            }
            
            addHandlerChanged(labMain, function(h, ...) updateEverything())
            addHandlerBlur(labMain, function(h, ...) updateEverything())
            addHandlerChanged(labXlab, function(h, ...) updateEverything())
            addHandlerBlur(labXlab, function(h, ...) updateEverything())
            addHandlerChanged(labYlab, function(h, ...) updateEverything())
            addHandlerBlur(labYlab, function(h, ...) updateEverything())

            if (PLOTTYPE == "scatter") {
                addHandlerChanged(xJit, function(h, ...) updateEverything())
                addHandlerChanged(yJit, function(h, ...) updateEverything())
                addHandlerChanged(xRug, function(h, ...) updateEverything())
                addHandlerChanged(yRug, function(h, ...) updateEverything())
            }

            add(optGrp, tbl)
        },
        identify = function() {
            iNZLocatePoints()
        },
        ## Code more variables
        opt1 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl1 <- glabel("Code More Variables")
            font(lbl1) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl1
            ii <- ii + 1
            
            lbl <- glabel("Colour by :")
            grpVarList <- gcombobox(c("", names(GUI$getActiveData())),
                                    selected = ifelse(
                                        is.null(curSet$colby),
                                        1, which(names(GUI$getActiveData()) ==
                                                     curSet$varnames$colby)[1] + 1
                                        )
                                    )
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- grpVarList
            ii <- ii + 1

            lvlCols <- gbutton("Specify colours")
            tbl[ii, 2, expand = TRUE] <- lvlCols
            visible(lvlCols) <- svalue(grpVarList, index = TRUE) != 1
            ii <- ii + 1

            addHandlerClicked(lvlCols, function(h, ...) {
                variable <- GUI$getActiveData()[, svalue(grpVarList, index = FALSE)]
                if (is.numeric(variable)) {
                    gmessage("Set colour of numeric ... not yet implemented.", "Not ready yet.", icon = "warning")
                } else {
                    specifyColours(variable)
                }
            })


            lbl <- glabel("Resize points by :")
            rszVarList <- gcombobox(
                c("", rszNames <- names(GUI$getActiveData())[sapply(GUI$getActiveData(), is.numeric)]),
                selected = ifelse(
                    is.null(curSet$sizeby),
                    1, which(rszNames == curSet$varnames$sizeby)[1] + 1
                    )
                )
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- rszVarList
            ii <- ii + 1

            lbl <- "Resize method :"
            rszMethods <- c("proportional", "emphasize")
            rszMthd <- gcombobox(rszMethods,
                                 selected = which(rszMethods == curSet$resize.method))
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- rszMthd
            ii <- ii + 1

            rszDescOpts <- list(method1 =
                                    c("Points area proportional to value of variable."),
                                method2 =
                                    c("Point area linearly sized from 0.25 to 4.",
                                      "Good for exaggerating trends."))
            rszDesc <- glabel(paste(rszDescOpts[[svalue(rszMthd, index = TRUE)]]))
            tbl[ii, 1:2, anchor = c(1, 0), expand = TRUE] <- rszDesc


            ## Maintain a single function that is called whenever anything is updated:
            updateEverything <- function() {
                GUI$getActiveDoc()$setSettings(
                    list(colby = GUI$getActiveData()[[
                             svalue(grpVarList)]],
                         sizeby = GUI$getActiveData()[[
                             svalue(rszVarList)]],
                         resize.method = svalue(rszMthd),
                         varnames = list(
                             colby = svalue(grpVarList),
                             sizeby = svalue(rszVarList)))
                    )
                updateSettings()
            }
            
            ## in this case, no point in having a separate "show" button
            addHandlerChanged(grpVarList, handler = function(h, ...) updateEverything())
            addHandlerChanged(rszVarList, handler = function(h, ...) updateEverything())
            addHandlerChanged(rszMthd, handler = function(h, ...) {
                                  svalue(rszDesc) <- rszDescOpts[[svalue(h$obj, index = TRUE)]]
                                  updateEverything()
                              })

            addHandlerChanged(grpVarList,
                              handler = function(h, ...) {
                                  updateEverything()
                                  visible(lvlCols) <- svalue(grpVarList, index = TRUE) != 1 &&
                                      is.factor(GUI$getActiveData()[[svalue(grpVarList)]])
                              })
                              
            add(optGrp, tbl)
        },
        ## Add trend curves
        opt2 = function() {
            tbl <- glayout()
            ii <- 3

            #### TREND CURVES
            lbl <- glabel("Add trend curves")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            ## Types of curves possible:
            trCrvs <- c("linear", "quadratic", "cubic")
            trCols <- c("red", "black", "blue", "green4",
                        "yellow", "pink", "grey", "orange")

            ## Linear trend
            linChk <- gcheckbox(trCrvs[1],
                                checked = trCrvs[1] %in% curSet$trend)
            linCol <- gcombobox(trCols,
                                selected = which(
                                    curSet$col.trend$linear == trCols
                                    )
                                )
            tbl[ii, 1] <- linChk
            tbl[ii, 2] <- linCol
            ii <- ii + 1
            
            quaChk <- gcheckbox(trCrvs[2],
                                checked = trCrvs[2] %in% curSet$trend)
            quaCol <- gcombobox(trCols,
                                selected = which(
                                    curSet$col.trend$quadratic == trCols
                                    )
                                )
            tbl[ii, 1] <- quaChk
            tbl[ii, 2] <- quaCol
            ii <- ii + 1
            
            cubChk <- gcheckbox(trCrvs[3],
                                checked = trCrvs[3] %in% curSet$trend)
            cubCol <- gcombobox(trCols,
                                selected = which(
                                    curSet$col.trend$cubic == trCols
                                    )
                                )
            tbl[ii, 1] <- cubChk
            tbl[ii, 2] <- cubCol
            ii <- ii + 1


            ii <- ii + 1
            #### SMOOTHERS
            smthCols <- c("red", "black", "blue", "green", "yellow",
                          "magenta", "grey", "orange")

            
            smthChk <- gcheckbox("Draw a smoother",
                                 checked = curSet$smooth!=0 | !is.null(curSet$quant.smooth))
            smthCol <- gcombobox(smthCols,
                                 selected = which(
                                     curSet$col.smooth == smthCols)
                                 )
            tbl[ii, 1] <- smthChk
            tbl[ii, 2] <- smthCol
            ii <- ii + 1
            
            quantSmthChk <- gcheckbox("Use Quantiles",
                                      checked = !is.null(curSet$quant.smooth))
            tbl[ii, 1] <- quantSmthChk
            ii <- ii + 1

            smthSlid <- gslider(from = 0.1, to = 1,
                                by = 0.01,
                                value = ifelse(curSet$smooth==0,
                                    0.7, curSet$smooth))
            tbl[ii, 1:2] <- smthSlid
            ii <- ii + 1


            ii <- ii + 1
            trendByChk <- gcheckbox(paste("For each level of",
                                            curSet$varnames$colby),
                                      checked = curSet$trend.by)
            trendParChk <- gcheckbox("Parallel trend lines",
                                     checked = curSet$trend.parallel)
            if (!is.null(curSet$colby)) {
                if (is.factor(curSet$colby)) {
                    tbl[ii, 1:2] <- trendByChk
                    ii <- ii + 1
                    tbl[ii, 1:2] <- trendParChk
                    ii <- ii + 1
                }
            }

            updateEverything <- function(update = auto) {
                if (!update)
                    return()
                
                ## vector of selected trends
                trSel <- c(svalue(linChk),
                           svalue(quaChk),
                           svalue(cubChk))
                ## vector of colors chosen
                trCol <- c(svalue(linCol),
                           svalue(quaCol),
                           svalue(cubCol))
                ## smoother option
                qsmth <-
                    if (svalue(quantSmthChk))
                        if (svalue(smthChk))"default" else NULL
                    else NULL
                smth <- ifelse(svalue(smthChk) & is.null(qsmth),
                               svalue(smthSlid),
                               0)
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(trend = trCrvs[trSel],
                         smooth = smth,
                         quant.smooth = qsmth,
                         col.trend = list(
                             linear = trCol[1],
                             quadratic = trCol[2],
                             cubic = trCol[3]),
                         col.smooth = svalue(smthCol),
                         trend.by = svalue(trendByChk),
                         trend.parallel = svalue(trendParChk)
                         )
                    )
                updateSettings()
            }

            ii <- ii + 1            
            showButton <- gbutton("Show Changes",
                                  handler = function(h, ...) updateEverything(TRUE))
            
            ## only have the smoother slider enabled if the
            ## smoother checkbox is ticked
            if (!svalue(smthChk)) {
                enabled(smthSlid) <- FALSE
                enabled(quantSmthChk) <- FALSE
            } else {
                if (svalue(quantSmthChk))
                    enabled(smthSlid) <- FALSE
            }

            addHandlerChanged(smthChk, handler = function(h, ...) {
                if (svalue(smthChk)) {
                    if (!svalue(quantSmthChk))
                        enabled(smthSlid) <- TRUE
                    else
                        enabled(smthSlid) <- FALSE

                    enabled(quantSmthChk) <- TRUE
                } else {
                    enabled(smthSlid) <- FALSE
                    enabled(quantSmthChk) <- FALSE
                }
                updateEverything()
            })
            ## if quantiles are used, disable slider
            addHandlerChanged(quantSmthChk,
                              handler = function(h, ...) {
                                  if (svalue(quantSmthChk)) {
                                      enabled(smthSlid) <- FALSE
                                  }
                                  else {
                                      enabled(smthSlid) <- TRUE
                                  }
                                  updateEverything()
                              })

            ## activate/deactive trend by check box
            ## only have the trend by level option enabled if
            ## the colored by variable option is set
            ## and if lin/quad/cub/or normal smoother is checked
            activateTrendBy <- function() {
                enabled(trendByChk) <-
                    ifelse(is.null(curSet$colby), FALSE, is.factor(curSet$colby)) &
                        (svalue(linChk) | svalue(quaChk) | svalue(cubChk) |
                         (svalue(smthChk) & !svalue(quantSmthChk)))
            }
            activateTrendBy()
            addHandlerChanged(linChk, handler = function(h, ...) {
                                          updateEverything()
                                          activateTrendBy()
                                      })
            addHandlerChanged(quaChk, handler = function(h, ...) {
                                          updateEverything()
                                          activateTrendBy()
                                      })
            addHandlerChanged(cubChk, handler = function(h, ...) {
                                          updateEverything()
                                          activateTrendBy()
                                      })
            addHandlerChanged(smthChk, handler = function(h, ...) {
                                           updateEverything()
                                           activateTrendBy()
                                       })
            addHandlerChanged(quantSmthChk, handler = function(h, ...) {
                                                updateEverything()
                                                activateTrendBy()
                                            })

            
            ## activate/deactivate trend parallel box
            ## only have the "parallel lines" enabled if "trend by" is ticked
            activateTrendPar <- function() {
                enabled(trendParChk) <- svalue(trendByChk) &
                    (svalue(linChk) | svalue(quaChk) | svalue(cubChk))
            }
            activateTrendPar()
            addHandlerChanged(trendByChk, handler = function(h, ...) {
                                              updateEverything()
                                              activateTrendPar()
                                          })
            addHandlerChanged(linChk, handler = function(h, ...) {
                                          updateEverything()
                                          activateTrendPar()
                                      })
            addHandlerChanged(quaChk, handler = function(h, ...) {
                                          updateEverything()
                                          activateTrendPar()
                                      })
            addHandlerChanged(cubChk, handler = function(h, ...) {
                                          updateEverything()
                                          activateTrendPar()
                                      })


            ## Also update the colour things
            if (auto) {
                addHandlerChanged(linCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(quaCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(cubCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(smthCol, handler = function(h, ...) updateEverything())
                addHandlerChanged(trendParChk, handler = function(h, ...) updateEverything())
                

                smthtimer <- NULL
                addHandlerChanged(smthSlid,
                                  handler = function(h, ...) {
                                      if (!is.null(smthtimer))
                                          smthtimer$stop_timer()
                                      smthtimer <- gtimer(800, function(...) updateEverything(), one.shot = TRUE)
                                  })

                autoCheck <- gcheckbox("Update automatically", checked = auto)
                tbl[ii, 1:2, expand = TRUE] <- autoCheck
                ii <- ii + 1

                addHandlerChanged(autoCheck, handler = function(h, ...) {
                                                 enabled(showButton) <- !svalue(autoCheck)
                                                 auto <<- svalue(autoCheck)
                                             })
            }

            tbl[ii, 1:2, expand = TRUE] <- showButton
            enabled(showButton) <- !auto

            add(optGrp, tbl)
        },
        ## Add x=y line
        opt3 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Add x=y line")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            xyline <- gcheckbox("Plot x=y line",
                                checked = curSet$LOE)
            xyCols <- c("red", "black", "blue", "green4",
                        "yellow", "pink", "grey", "orange")
            xyCol <- gcombobox(xyCols,
                               selected = which(
                                   curSet$col.LOE == xyCols
                                   )
                               )
            tbl[ii, 1, expand = TRUE] <- xyline
            tbl[ii, 2, expand = TRUE] <- xyCol
            ii <- ii + 1

            updateEverything <- function() {
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(LOE = svalue(xyline),
                         col.LOE = svalue(xyCol))
                    )
                updateSettings()
            }

            addHandlerChanged(xyline, handler = function(h, ...) updateEverything())
            addHandlerChanged(xyCol, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Add jitter
        opt4 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Add a jitter")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            xJit <- gcheckbox("Jitter x-variable",
                              checked = curSet$jitter %in% c("x", "xy"))
            yJit <- gcheckbox("Jitter y-variable",
                              checked = curSet$jitter %in% c("y", "xy"))
            tbl[ii, 1, expand = TRUE] <- xJit
            tbl[ii, 2, expand = TRUE] <- yJit
            ii <- ii + 1

            updateEverything <- function() {
                ## build string to show which jitter opt
                ## was selected
                jit <- ""
                if (svalue(xJit)) jit <- paste(jit, "x", sep = "")
                if (svalue(yJit)) jit <- paste(jit, "y", sep = "")
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(jitter = jit)
                    )
                updateSettings()
            }

            addHandlerChanged(xJit, handler = function(h, ...) updateEverything())
            addHandlerChanged(yJit, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Add rug
        opt5 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Add rugs")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            xRug <- gcheckbox("Add x-rug",
                              checked = curSet$rug %in% c("x", "xy"))
            yRug <- gcheckbox("Add y-rug",
                              checked = curSet$rug %in% c("y", "xy"))
            tbl[ii, 1, expand = TRUE] <- xRug
            tbl[ii, 2, expand = TRUE] <- yRug
            ii <- ii + 1

            updateEverything <- function() {
                ## build string to show which jitter opt
                ## was selected
                rug <- ""
                if (svalue(xRug)) rug <- paste(rug, "x", sep = "")
                if (svalue(yRug)) rug <- paste(rug, "y", sep = "")
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(rugs = rug)
                    )
                updateSettings()
            }

            addHandlerChanged(xRug, handler = function(h, ...) updateEverything())
            addHandlerChanged(yRug, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Join points by lines
        opt6 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Join points by lines")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            
            joinPts <- gcheckbox("Join points",
                                 checked = curSet$join)
            joinCols <- c("red", "black", "blue", "green4",
                          "yellow", "pink", "grey", "orange")
            joinCol <- gcombobox(joinCols,
                               selected = which(
                                   curSet$col.line == joinCols
                                   )
                               )
            tbl[ii, 1, expand = TRUE] <- joinPts
            tbl[ii, 2, expand = TRUE] <- joinCol
            ii <- ii + 1

            lineByChk <- gcheckbox(paste("For each level of",
                                         curSet$varnames$colby),
                                   selected = curSet$lines.by)
            if (!is.null(curSet$colby)) {
                tbl[ii, 1] <- lineByChk
                ii <- 1
            }

            updateEverything <- function() {
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(join = svalue(joinPts),
                         col.line = svalue(joinCol),
                         lines.by = svalue(lineByChk))
                    )
                updateSettings()
            }
            
            addHandlerChanged(joinPts, handler = function(h, ...) updateEverything())
            addHandlerChanged(joinCol, handler = function(h, ...) updateEverything())
            addHandlerChanged(lineByChk, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## change plot appearance
        opt7 = function() {
            tbl <- glayout()
            ii <- 3

            ## Default settings
            defts <- iNZightPlots:::inzpar()
            
            ## PLOT APPEARANCE
            lbl <- glabel("Change plot appearance")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii,  1:2, anchor = c(-1,-1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            ## PLOT TYPE
            lbl <- glabel("Plot Type :")
            
            plotTypes <- c("default", "scatter plot", "grid-density plot", "hexbin plot")
            plotTypeValues <- list("default", "scatter", "grid", "hex")
            plotTypeList <- gcombobox(
                plotTypes,
                selected = which(plotTypeValues == curSet$plottype)
                )
            
            addHandlerChanged(plotTypeList, handler = function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(plottype = plotTypeValues[[svalue(plotTypeList, index = TRUE)]])
                    )
                updateSettings()

                plType <- svalue(plotTypeList, index = TRUE)
                if (plType == 3 | plType == 4 | (plType == 1 & GUI$plotType != "scatter")) {
                    switch(GUI$plotType,
                           "grid" = iNZGriddenMod$new(GUI, which = 3),
                           "hex" = iNZHexbinMod$new(GUI, which = 3))
                }
            })
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- plotTypeList
            ii <- ii + 1


            ## BACKGROUND COLOUR
            lbl <- glabel("Background colour :")
            
            backgroundCols <- c(defts$bg, "antiquewhite",
                                "azure3", "bisque", "cornsilk", "darkolivegreen2",
                                "darkslategray1", "greenyellow", "lightblue1",
                                "lightpink", "rosybrown1", "slategray1", "thistle1",
                                "wheat1")
            backgroundColList <- gcombobox(
                backgroundCols,
                selected = ifelse(
                    is.na(which(backgroundCols == curSet$bg)[1]),
                    1,
                    which(backgroundCols == curSet$bg)[1]),
                editable = TRUE)
            
            tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii,  2, expand = TRUE] <- backgroundColList
            ii <- ii + 1


            ## ## SYMBOL OPTIONS
            ii <- ii + 1
            lbl <- glabel("Symbol options")
            font(lbl) <- list(weight="bold", family = "normal", size = 8)
            tbl[ii, 1:2, anchor = c(-1,-1), expand = TRUE] <- lbl
            ii <- ii + 1

            isColBy <- !is.null(GUI$getActiveDoc()$getSettings()$colby)
            if (!isColBy) {
                ## COLOUR            
                lbl <- glabel("Colour :")
                pointCols <- c(defts$col.pt, "darkblue", "darkgreen",
                               "darkmagenta", "darkslateblue", "hotpink4",
                               "lightsalmon2", "palegreen3", "steelblue3")
                symbolColList <- gcombobox(
                    pointCols,
                    selected = ifelse(
                        is.na(which(pointCols == curSet$col.pt)[1]),
                        1,
                        which(pointCols == curSet$col.pt)[1]),
                    editable = TRUE)
                
                tbl[ii,  1, anchor = c(-1,-1), expand = TRUE] <- lbl
                tbl[ii,  2, expand = TRUE] <- symbolColList
                ii <- ii + 1
                
                lbl <- glabel("NOTE: You can type in a colour if it is not listed.")
                
                font(lbl) <- list(family = "normal", size = 8)
                tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl                
                ii <- ii + 1
            } else {
                ## COLOUR PALETTE
                lbl <- glabel("Colour palette :")
                palettes <<- list("default" = NULL,
                                  "rainbow" = function(n) rainbow(n, start = 1/6),
                                  "heat" = heat.colors,
                                  "terrain" = terrain.colors)
                if (requireNamespace("colorspace", quietly = TRUE)) {
                    palettes <<- c(palettes, list("advanced" = NULL))
                }
                paletteList <- gcombobox(
                    names(palettes),
                    selected = ifelse(
                        is.na(which(names(palettes) == attr(curSet$col.fun, "name"))[1]),
                        1,
                        which(names(palettes) == attr(curSet$col.fun, "name"))[1]),
                    editable = FALSE)

                tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
                tbl[ii, 2, expand = TRUE] <- paletteList
            }

            ## FILL
            fillColor <- gcheckbox("Colour interior",
                                   checked = (curSet$pch != 1))
            tbl[ii,  2, expand = TRUE] <- fillColor
            ii <- ii + 1
            
            ## SIZE
            lbl <- glabel("Size :")
            cexSlider <- gslider(from = 0.05, to = 3.5,
                                 by = 0.05, value = curSet$cex.pt)
            tbl[ii, 1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- cexSlider
            ii <- ii + 1
            
            ## Transparency
            lbl <- glabel("Transparency :")
            transpSlider <- gslider(from = 0, to = 100,
                                    by = 1, value = 100 * (1 - curSet$alpha))
            tbl[ii, 1, anchor = c(-1,-1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- transpSlider
            ii <- ii + 1

            updateEverything <- function(update = auto) {
                ## To easily diable automatic updating of plot, add this argument,
                ## otherwise would have to block/unblock handlers
                if (!update)
                    return()
                
                pch.sel <- ifelse(svalue(fillColor) | svalue(transpSlider) > 0,
                                  19, 1)
                if (isColBy) {
                    colFn <- palettes[[svalue(paletteList, index = TRUE)]]
                    if (svalue(paletteList, index = TRUE) > 1) {
                        attr(colFn, "name") <- svalue(paletteList)
                    }
                }
                GUI$getActiveDoc()$setSettings(
                    list(col.pt = if (isColBy) curSet$col.pt else svalue(symbolColList),
                         col.fun = if (isColBy) colFn else NULL,
                         bg = svalue(backgroundColList),
                         cex.pt = svalue(cexSlider),
                         pch = pch.sel,
                         alpha = 1 - svalue(transpSlider) / 100
                         ))
                updateSettings()
            }

            ii <- ii + 1
            showButton <- gbutton("Show Changes",
                                  handler = function(h, ...) updateEverything(TRUE))
            if (auto) {
                bcoltimer <- NULL
                addHandlerChanged(backgroundColList,
                                  handler = function(h, ...) {
                                      if (!is.null(bcoltimer))
                                          bcoltimer$stop_timer()
                                      bcoltimer <- gtimer(500, function(...) {
                                                               if (nchar(svalue(backgroundColList)) >= 3)
                                                                   updateEverything()
                                                           }, one.shot = TRUE)
                                  })

                ## This one needs to be deactivated if user is typing:
                if (isColBy) {
                    addHandlerChanged(paletteList,
                                      handler = function(h, ...) {
                                          if (svalue(paletteList) == "advanced") {
                                              palettes$advanced <<- colorspace::choose_palette()
                                          }
                                          updateEverything()
                                      })
                } else {
                    pcoltimer <- NULL
                    addHandlerChanged(symbolColList,
                                      handler = function(h, ...) {
                                          if (!is.null(pcoltimer))
                                              pcoltimer$stop_timer()
                                          pcoltimer <- gtimer(500, function(...) {
                                                                  if (nchar(svalue(symbolColList)) >= 3)
                                                                      updateEverything()
                                                              }, one.shot = TRUE)
                                      })
                }

                addHandlerChanged(fillColor,
                                  handler = function(h, ...) updateEverything())
                                
                cextimer <- NULL
                addHandlerChanged(cexSlider,
                                  handler = function(h, ...) {
                                      if (!is.null(cextimer))
                                          cextimer$stop_timer()
                                      cextimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })

                transptimer <- NULL
                addHandlerChanged(transpSlider,
                                  handler = function(h, ...) {
                                      if (!is.null(transptimer))
                                          transptimer$stop_timer()
                                      transptimer <- gtimer(500, function(...) updateEverything(), one.shot = TRUE)
                                  })

                autoCheck <- gcheckbox("Update automatically", checked = auto)
                tbl[ii, 1:2, expand = TRUE] <- autoCheck
                ii <- ii + 1

                addHandlerChanged(autoCheck, handler = function(h, ...) {
                                                 enabled(showButton) <- !svalue(autoCheck)
                                                 auto <<- svalue(autoCheck)
                                             })
            }
            
            
            tbl[ii, 1:2, expand = TRUE] <- showButton
            enabled(showButton) <- !auto
            
            add(optGrp, tbl)
        },
        opt8 = function() iNZLocatePoints(),
        opt9 = function() {
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Customize Labels")
            font(lbl) <- list(weight="bold",
                               family = "normal",
                               size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1
            

            curPlSet <- GUI$getActiveDoc()$getSettings()
            oldMain <- curPlSet$main
            oldX <- curPlSet$xlab
            oldY <- curPlSet$ylab
            if (is.null(oldMain)) oldMain <- ''
            if (is.null(oldX)) oldX <- ''
            if (is.null(oldY)) oldY <- ''

            lbl    <- glabel("Main title :")
            labMain <- gedit(oldMain)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labMain
            ii <- ii + 1
            
            lbl    <- glabel("x-axis label :")
            labX    <- gedit(oldX)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labX
            ii <- ii + 1

            lbl    <- glabel("y-axis label :")
            labY    <- gedit(oldY)
            tbl[ii, 1, anchor = c(-1, -1), expand = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- labY
            ii <- ii + 1
            

            lbl <- glabel("Enter a single space to print no label\nLeave blank to print default label")
            font(lbl) <- list(family = "normal",
                               size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            
            lbl <- glabel("Press ENTER/RETURN to apply changes")
            font(lbl) <- list(family = "normal", size = 8)
            tbl[ii, 2, anchor = c(-1, -1), expand = TRUE] <- lbl

            
            updateEverything <- function() {
                mlab <- svalue(labMain)
                xlab <- svalue(labX)
                ylab <- svalue(labY)
                GUI$getActiveDoc()$setSettings(
                    list(main = if (mlab != '') mlab else NULL,
                         xlab = if (xlab != '') xlab else NULL,
                         ylab = if (ylab != '') ylab else NULL)
                    )
                updateSettings()
            }
            
            addHandlerChanged(labMain, handler = function(h, ...) updateEverything())
            addHandlerChanged(labX, handler = function(h, ...) updateEverything())
            addHandlerChanged(labY, handler = function(h, ...) updateEverything())
            
            add(optGrp, tbl)
        },
        ## Adjust axis limits
        opt10 = function(){
            tbl <- glayout()
            ii <- 3
            
            lbl <- glabel("Adjust Axis Limits")
            font(lbl) <- list(weight="bold", family = "normal", size = 9)
            tbl[ii, 1:2, anchor = c(-1, -1), expand = TRUE] <- lbl
            ii <- ii + 1

            pl <- GUI$curPlot
            xlim <- if (is.null(curSet$xlim))
                pl$xlim
            else
                curSet$xlim
            ylim <- if (is.null(curSet$ylim))
                pl$ylim
            else
                curSet$ylim

            
            lbl <- glabel("x-axis: ")
            xlower <- gedit(xlim[1])
            xupper <- gedit(xlim[2])
            tbl[ii, 1, expand = TRUE, fill = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- xlower
            tbl[ii, 3, expand = TRUE] <- xupper
            ii <- ii + 1

            lbl <- glabel("y-axis: ")
            ylower <- gedit(ylim[1])
            yupper <- gedit(ylim[2])
            tbl[ii, 1, expand = TRUE, fill = TRUE] <- lbl
            tbl[ii, 2, expand = TRUE] <- ylower
            tbl[ii, 3, expand = TRUE] <- yupper
            ii <- ii + 1

            errlbl <- glabel("Limits must be numbers.")
            tbl[ii, 1:3] <- errlbl
            visible(errlbl) <- FALSE
            ii <- ii + 1

            updateEverything <- function() {
                err <- FALSE
                xl <- suppressWarnings(as.numeric(svalue(xlower)))
                if (is.na(xl)) {
                    xl <- xlim[1]
                    err <- TRUE4
                }
                xu <- suppressWarnings(as.numeric(svalue(xupper)))
                if (is.na(xu)) {
                    xu <- xlim[2]
                    err <- TRUE
                }

                yl <- suppressWarnings(as.numeric(svalue(ylower)))
                if (is.na(yl)) {
                    yl <- ylim[1]
                    err <- TRUE
                }
                yu <- suppressWarnings(as.numeric(svalue(yupper)))
                if (is.na(yu)) {
                    yu <- ylim[2]
                    err <- TRUE
                }

                visible(errlbl) <- err
                    
                ## update plot settings
                GUI$getActiveDoc()$setSettings(
                    list(xlim = c(xl, xu),
                         ylim = c(yl, yu))
                    )
                updateSettings()
            }

            timer <- NULL
            updT <- function(h, ...) {
                if (!is.null(timer))
                    timer$stop_timer()
                timer <- gtimer(800, function(...) updateEverything(), one.shot = TRUE)
            }
            addHandlerKeystroke(xlower, updT)
            addHandlerKeystroke(xupper, updT)
            addHandlerKeystroke(ylower, updT)
            addHandlerKeystroke(yupper, updT)
            
            add(optGrp, tbl)

            resetGrp <- ggroup(cont = optGrp)
            addSpring(resetGrp)
            resetbtn <- gbutton("Reset", cont = resetGrp)
            addHandlerClicked(resetbtn, function(h, ...) {
                GUI$getActiveDoc()$setSettings(
                    list(xlim = NULL, ylim = NULL)
                    )
                updateSettings()

                ## reset the values in the boxes:
                pl <- GUI$curPlot
                xlim <-pl$xlim
                ylim <- pl$ylim

                svalue(xlower) <- xlim[1]
                svalue(xupper) <- xlim[2]
                svalue(ylower) <- ylim[1]
                svalue(yupper) <- ylim[2]
            })
        })
    )

#line 1 "/Users/tom/iNZight/iNZight/R/iNZPlotRmveModWin.R"
## Class to display the window that enables the user to remove
## modifications that were previously made to the plot

iNZPlotRmveModWin <- setRefClass(
    "iNZPlotRmveModWin",
    fields = list(
        GUI = "ANY",
        curSet = "ANY", ## the current plot settings
        defSet = "ANY" ## the default plot settings
        ),
    methods = list(
        initialize = function(gui = NULL, new = TRUE) {
            initFields(GUI = gui)
            if(!is.null(GUI)) {
                curSet <<- GUI$getActiveDoc()$getSettings()
                defSet <<- iNZightPlots:::inzpar()
                ## labels for all possible additions
                additions <- c(
                    "Remove all additions",
                    paste("Remove colour coding by", curSet$varnames$by),
                    paste("Remove resizing by",curSet$varnames$sizeby),
                    "Remove trend curves",
                    "Remove y = x line",
                    "Remove smoothers",
                    "Remove jitter",
                    "Remove rugs",
                    "Remove connecting lines",
                    paste("Remove colour by", curSet$varnames$by),
                    "Remove all inference information",  # "confidence intervals",
                    "Remove symbol interior colouring",
                    "Restore default symbol colours",
                    "Restore default plotting symbol sizes",
                    "Restore default symbol transparency",
                    "Restore default background colour",
                    "Restore default line thickness",
                    "Restore default plot type",
                    "Restore default plot labels",
                    "Restore default bar colours",
                    "Restore default number of bins",
                    "Restore default number of grid bins",
                    "Restore default number of hexs",
                    "Restore default plot type",
                    "Remove point labels",
                    "Restore default axis limits",
                    "Restore all bars of bar chart")
                ## check for presence of all additions
                curAdditions <- c(
                    TRUE, ## all additiions
                    !is.null(curSet$colby) && ## colour coding dotplots
                    (is.numeric(curSet$x) ||
                     is.numeric(curSet$y)),
                    !is.null(curSet$sizeby), ## resize
                    !is.null(curSet$trend), ## trend
                    curSet$LOE, ## x=y line
                    curSet$smooth != 0 || !is.null(curSet$quant.smooth), ## smoother
                    curSet$jitter != "", ## jitter
                    curSet$rugs != "", ## rugs
                    curSet$join, ## connecting lines
                    !is.null(curSet$colby) && ## colour coding barchart
                    !is.numeric(curSet$x) &&
                    is.null(curSet$y),
                    !is.null(curSet$inference.type) ||
                    curSet$bs.inference, ## confidence intervals
                    curSet$fill.pt != defSet$fill.pt | curSet$pch != defSet$pch, ## point filling
                    curSet$col.pt != defSet$col.pt, ## point colour
                    (all.equal(curSet$cex.pt, defSet$cex.pt) != TRUE), ## point size
                    (all.equal(curSet$alpha, defSet$alpha) != TRUE), ## transparency
                    curSet$bg != defSet$bg, ## bg colour
                    curSet$lwd.pt != defSet$lwd.pt, ## point line thickness
                    !is.null(curSet$largesample), ## plot type
                    !is.null(curSet$xlab) | !is.null(curSet$ylab) | !is.null(curSet$main),  ## plot labels
                    curSet$bar.fill != defSet$bar.fill,  ## bar colours
                    !is.null(curSet$hist.bins),  ## number of histogram bins
                    curSet$scatter.grid.bins != defSet$scatter.grid.bins,  ## number of grid bins
                    curSet$hex.bins != defSet$hex.bins,  ## number of hexs
                    curSet$plottype != defSet$plottype,  ## plot type
                    (!is.null(curSet$locate) | !is.null(curSet$locate.id) |
                     !is.null(curSet$locate.col)),  ## locate labels
                    (!is.null(curSet$xlim) | !is.null(curSet$ylim)),  ## axis limits
                    (!is.null(curSet$zoombars))  ## bar plot zooming
                    )

                proceedButton <- gbutton(
                    "OK",
                    handler = function(h, ...) {
                        ## the checkboxes are accessed as
                        ## children of the selectGrp
                        ## first child refers to remove all adds
                        try({
                            if (svalue(selectGrp$children[[1]]))
                                rmv <- TRUE
                            else
                                rmv <- which(curAdditions)[sapply(
                                    selectGrp$children,
                                    svalue)] - 1
                            ## update the plot settings
                            removeAdditions(rmv)
                        }, silent = TRUE)

                        ## only destroy the window if there are no more additions left to remove
                        iNZPlotRmveModWin$new(GUI, new = FALSE)
                    })

                closeButton <- gbutton(
                    "Close",
                    handler = function(h, ...) {
                        delete(GUI$leftMain, GUI$leftMain$children[[2]])
                        visible(GUI$gp1) <<- TRUE
                    })

                if (sum(curAdditions) <= 1) {
                    if (new) {
                        ## User has just clicked the "Remove additions" button
                        gmessage("There are no plot additions to remove.",
                                 title = "Nothing to remove",
                                 parent = GUI$win)
                    } else {
                        ## User has just removed a bunch of additions, and there are none left
                        delete(GUI$leftMain, GUI$leftMain$children[[2]])
                        visible(GUI$gp1) <<- TRUE
                    }
                    return()
                }
                
                ## open in leftMain
                if (length(GUI$leftMain$children) > 1) {
                    delete(GUI$leftMain, GUI$leftMain$children[[2]])
                }
                GUI$initializeModuleWindow()
                
                mainGrp <- gvbox(container = GUI$moduleWindow, expand = TRUE)
                
                lbl <- glabel("Remove additions")
                font(lbl) <- list(weight = "bold", family = "normal", size = 9)
                add(mainGrp, lbl)
                
                selectGrp <- ggroup(horizontal = FALSE,
                                  container = mainGrp,
                                  expand = FALSE)
                btnGrp <- ggroup(container = mainGrp, expand = FALSE)
                mainGrp$set_borderwidth(5)

                ## Action buttons:
                btnTb <- glayout()
                btnTb[1, 1, expand = TRUE] <- proceedButton
                btnTb[1, 2, expand = TRUE] <- closeButton

                ## Checking function:
                checkOK <- function() {
                    checked <- sapply(selectGrp$children, svalue)
                    enabled(proceedButton) <- any(checked)
                }
                checkOK()

                sapply(additions[curAdditions], function(x) {
                       gcheckbox(x, cont = selectGrp, handler = function(h, ...) checkOK())})
                                
                addSpring(btnGrp)
                add(btnGrp, btnTb)
                
                ## add observer to the data
                ## if it changes, remove all current additions
                GUI$getActiveDoc()$addDataObserver(
                    function() removeAdditions(TRUE)
                    )
                
                visible(GUI$moduleWindow) <<- TRUE
            }
        },
        ## remove plot additions from the plot settings
        ## additions: logical vector representing which
        ##            addition to remove
        removeAdditions = function(additions) {
            ## list with entries to remove additions (set to default)
            rmvAdditions <- list(list(colby = NULL, ## colour coding dotplots
                                      varnames = list(colby = NULL)),
                                 list(sizeby = NULL, ## resize proportional
                                      varnames = list(sizeby = NULL)),
                                 list(trend = defSet$trend), ## trend
                                 list(LOE = defSet$LOE), ## x=y line
                                 list(smooth = defSet$smooth, quant.smooth = defSet$quant.smooth), ## smoother
                                 list(jitter = defSet$jitter), ## jitter
                                 list(rugs = ""), ## rugs
                                 list(join = defSet$join), ## connecting lines
                                 list(colby = NULL, ## colour coding barchart
                                      varnames = list(colby = NULL)),
                                 list(inference.type = defSet$inference.type,
                                      inference.par = defSet$inference.par,
                                      bs.inference = defSet$bs.inference), ## confidence intervals
                                 list(pch = defSet$pch, fill.pt = defSet$fill.pt), ## point filling
                                 list(col.pt = defSet$col.pt), ## point colour
                                 list(cex.pt = defSet$cex.pt), ## point size
                                 list(alpha = defSet$alpha), ## transparency
                                 list(bg = defSet$bg), ## bg colour
                                 list(lwd.pt = defSet$lwd.pt), ## point line thickness
                                 list(largesample = defSet$largesample), ## plot type
                                 list(xlab = NULL, ylab = NULL, main = NULL),  ## labels
                                 list(bar.fill = defSet$bar.fill), ## bar colours
                                 list(hist.bins = NULL),  ## histogram bins
                                 list(scatter.grid.bins = defSet$scatter.grid.bins),  ## grid bins
                                 list(hex.bins = defSet$hex.bins),  ## n. hexs
                                 list(plottype = defSet$plottype),  ## plot type
                                 list(locate = NULL, locate.id = NULL, locate.col = NULL,
                                      locate.settings = NULL),
                                 list(xlim = NULL, ylim = NULL),  ## axis limits
                                 list(zoombars = NULL)  ## bar plot zooming
                                 )

            GUI$getActiveDoc()$setSettings(
                unlist(rmvAdditions[additions], recursive = FALSE)
                )
        })
    )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZPlotToolbar.R"
#--------------------------------------------------
# This used to be a gtoolbar in gWidgets
# gWidgets2 only allows toolbars attached to the main gwindow
# Therefore we create a subclass of GToolBar from the gWidgets2RGtk2 package
# that does not have this constraint
# have to give a container to this class so that the toolbar is added
# directly in the class initialization and not through add()
#--------------------------------------------------

##' @importFrom iNZightTools newdevice
iNZPlotToolbar <- setRefClass(
    "iNZPlotToolbar",
    fields = list(
        GUI = "ANY",
        plotWidget = "ANY",
        menu = "ANY",
        popOut = "ANY",
        toolbarcont = "ANY",
        iconbar = "ANY",
        altbar = "ANY"
        ),
    methods = list(
        initialize = function(gui, cont) {
            initFields(GUI = gui,
                       plotWidget = gui$plotWidget,
                       popOut = gui$preferences$popout)
            
            toolbarcont <<- ggroup(container = cont, spacing = 0, fill = TRUE, expand = TRUE)
            iconbar <<- ggroup(horizontal = !popOut, container = toolbarcont, spacing = 15,
                               fill = TRUE, expand = TRUE)

            makeToolbar()

        },
        ## update the toolbar (as opposed to initialize it)
        update = function(btns = c("add", "rmv", "inf"),
                          refresh = NULL,
                          extra = NULL) {

            visible(iconbar) <<- FALSE

            if (length(toolbarcont$children) > 1)
                delete(toolbarcont, toolbarcont$children[[2]])

            altbar <<- ggroup(horizontal = !popOut,container = toolbarcont, spacing = 15,
                              fill = TRUE, expand = TRUE)

            makeToolbar(btns, refresh.fn = refresh, extra, cont = altbar)
        },
        restore = function() {
            setPlotMenu()
            delete(toolbarcont, toolbarcont$children[[2]])
            visible(iconbar) <<- TRUE
        },
        ## create the toolbar!
        makeToolbar = function(btns = c("add", "rmv", "inf"),
                               refresh.fn = NULL,
            extra, cont = iconbar) {

            ## link the menu:
            setPlotMenu(btns, refresh.fn, extra)

            if (is.null(refresh.fn)) {
                refreshFn = GUI$updatePlot
            } else {
                refreshFn = GUI$activeModule[[refresh.fn]]
            }
            
            img.add2plot <- system.file("images/graph-plus-transp.gif", package = "iNZight")
            img.rmvplot <- system.file("images/graph-cross-transp.gif", package = "iNZight")
            img.infinfo <- system.file("images/graph-inference.gif", package = "iNZight")

            newplotBtn <- gimagebutton(stock.id = "newplot", size = "button", name = "newplotbutton")
            addHandlerClicked(newplotBtn, function(h, ...) newPlotWindow(refreshFn))

            newtabBtn <- gimagebutton(stock.id = "new", size = "button")
            addHandlerClicked(newtabBtn, function(h, ...) plotWidget$addPlot())

            refreshplotBtn <- gimagebutton(stock.id = "refresh", size = "button")
            addHandlerClicked(refreshplotBtn, function(h, ...) refreshFn())

            renametabBtn <- gimagebutton(stock.id = "editor", size = "button")
            addHandlerClicked(renametabBtn, function(h, ...) plotWidget$renamePlot())


            saveplotBtn <- gimagebutton(stock.id = "save", size = "button")
            addHandlerClicked(saveplotBtn, function(h, ...) plotWidget$savePlot(refreshFn))

            closetabBtn <- gimagebutton(stock.id = "close", size = "button")
            addHandlerClicked(closetabBtn, function(h, ...) plotWidget$closePlot())


            ## -- IMAGES
            addtoplotBtn <- gimagebutton(filename = img.add2plot, size = "button")
            addHandlerClicked(addtoplotBtn, function(h, ...) addToPlot())

            removeaddBtn <- gimagebutton(filename = img.rmvplot, size = "button")
            addHandlerClicked(removeaddBtn, function(h, ...) iNZPlotRmveModWin$new(GUI))

            inferenceBtn <- gimagebutton(filename = img.infinfo, size = "button")
            addHandlerClicked(inferenceBtn, function(h, ...) addInf())


            addSpace(cont, 10)

            add(cont, newplotBtn)
            if (!popOut) add(cont, newtabBtn)
            add(cont, refreshplotBtn)
            if (!popOut) add(cont, renametabBtn)

            addSpace(cont, 10)
            
            add(cont, saveplotBtn)
            if (!popOut) add(cont, closetabBtn)

            addSpring(cont)

            if ("add" %in% btns)
                add(cont, addtoplotBtn)

            if ("rmv" %in% btns)
                add(cont, removeaddBtn)

            if ("inf" %in% btns)
                add(cont, inferenceBtn)

            if (!missing(extra)) {
                addSpace(cont, 10)
                lapply(extra, function(x) add(cont, x))
            }

            addSpace(cont, 10)

        },
        ## Plot Menu
        setPlotMenu = function(btns = c("add", "rmv", "inf"),
                               refresh.fn = NULL,
                               extra) {

            if (is.null(refresh.fn)) {
                refreshFn = GUI$updatePlot
            } else {
                refreshFn = GUI$activeModule[[refresh.fn]]
            }
            
            curMenu <- svalue(GUI$menubar)
            curMenu[["Plot"]] <- list(
                gaction("Add to plot ...",
                                             handler = function(h, ...) addToPlot()),
                gaction("Remove additions ...", handler = function(h, ...) iNZPlotRmveModWin$new(GUI)),
                gaction("Add inference ...", handler = function(h, ...) addInf()),
                gseparator(),
                gaction(label = "New Tab", icon = "newplot",
                        handler = function(h, ...) plotWidget$addPlot()),
                gaction(label = "Close Tab", icon = "close",
                        handler = function(h, ...) plotWidget$closePlot()),
                gaction(label = "Rename Tab", icon = "editor",
                        handler = function(h, ...) plotWidget$renamePlot()),
                gseparator(),
                gaction(label = "New Plot Window", icon = "new",
                        handler = function(h, ...) newPlotWindow()),
                gaction(label = "Redraw Plot", icon = "refresh",
                        handler = function(h, ...) refreshFn()),
                gaction(label = "Save Plot", icon = "save",
                        handler = function(h, ...) plotWidget$savePlot(refreshFn))
                )
            
            if (popOut)
                curMenu[["Plot"]][5:8] <- NULL

            curMenu[["Plot"]][which(!c("add", "rmv", "inf") %in% btns)] <- NULL

            svalue(GUI$menubar) <<- curMenu

        },
        ## function to open a new plot window
        newPlotWindow = function(f) {
            newdevice()
            f()
        },
        ## function to open the correct plot modification win
        ## depending on the currently selected variable types
        addToPlot = function() {
            curSet <- GUI$getActiveDoc()$getSettings()
            if (is.null(GUI$plotType))
                gmessage("You must select at least one variable before you can access the Add To Plot menu.",
                         title = "No variable selected")
            else
                switch(GUI$plotType,
                       "scatter" = iNZPlotMod$new(GUI),
                       "dot" = iNZDotchartMod$new(GUI),
                       "bar" = iNZBarchartMod$new(GUI),
                       "hist" = iNZHistogramMod$new(GUI),
                       "grid" = iNZPlotMod$new(GUI),
                       "hex" = iNZPlotMod$new(GUI),
                       gmessage("Select at least one variable before using Add to Plot.", title = "No variables selected",
                                icon = "error", parent = GUI$win))
        },
        addInf = function() {
            if (!is.null(GUI$getActiveDoc()$getModel()$getDesign())) {
                gmessage("Inferential markup of plots for survey data is still in development. If nothing shows up, it's because we haven't got to it yet. If you notice errors (wrong values for data you know) let us know.",
                         icon = "warning", parent = GUI$win, title = "Developmental Feature")
            }# else {
                curSet <- GUI$getActiveDoc()$getSettings()
                if (is.null(GUI$plotType))
                    gmessage("You must select at least one variable before you can access the Inference menu.",
                             title = "No variable selected", parent = GUI$win)
                else
                    switch(GUI$plotType,
                           "bar" = iNZBarchartInf$new(GUI),
                           "hist" = ,
                           "dot" = iNZDotchartInf$new(GUI),
                           "grid" = ,
                           "hex" = ,
                           "scatter" = {
                               if (is.null(curSet$trend) && curSet$smooth == 0)
                                   gmessage("Use the Add to Plot menu to add a trend(s) and/or smoother.",
                                            title = "No trend or smoother", parent = GUI$win)
                               else
                                   GUI$getActiveDoc()$setSettings(list(bs.inference = !curSet$bs.inference))
                           })
#            }
        })
    )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZPlotWidget.R"
## ---------------------------
## A class that handles the display of
## plots in a gnotebook and stores information
## about the tabs(plots
## ---------------------------

iNZPlotWidget <- setRefClass(
    "iNZPlotWidget",
    fields = list(
        GUI = "ANY",
        plotNb = "ANY",
        tabDevLink = "numeric" # vector with the link between device and nb nr.
        ),
    methods = list(
        initialize = function(gui) {
            initFields(GUI = gui,
                       tabDevLink = numeric(0))
            plotNb <<- gnotebook(expand = TRUE)
        },
        addPlot = function() {
            add(plotNb, ggraphics(expand = TRUE), label = "plot",
                close.button = FALSE)
            tabDevLink <<- c(tabDevLink, dev.cur())
        },
        closePlot = function() {
            if(length(plotNb$children) > 1) {
                tabDevLink <<- tabDevLink[-svalue(plotNb)]
                dispose(plotNb)
            }
        },
        renamePlot = function() {
            input <- ginput("Name Plot as:",
                            text=names(plotNb)[svalue(plotNb)],
                            title="Input",
                            icon = "question",
                            parent = GUI$win
                            )
            if (length(input) > 0)
                names(plotNb)[svalue(plotNb)] <<- input
        },
        savePlot = function(fun = GUI$updatePlot) {
            ## iNZSaveWin$new(GUI, type = "plot",
            ##                which = tabDevLink[svalue(plotNb)]
            ##                )
            
            w <- gwindow("Save plot", parent = GUI$win, width = 500, height = 250)
            g <- gvbox(spacing = 15, container = w)
            
            g$set_borderwidth(15)
            
            tbl <- glayout()
            ii <- 1
            
            lbl <- glabel("File type :")
            font(lbl) <- list(weight = "bold")
            filetypes <- list("JPEG (.jpg)" = jpeg,
                              "PNG (.png)" = png,
                              "Bitmap (.bmp)" = bmp,
                              "TIFF (.tiff)" = tiff)
            
            fileType <- gcombobox(names(filetypes))
            tbl[ii, 1, anchor = c(1, 0), expand = TRUE] <- lbl
            tbl[ii, 2:6, expand = TRUE] <- fileType
            ii <- ii + 1
            
            
            lbl <- glabel("Save location :")
            font(lbl) <- list(weight = "bold")
            initial.dir <- switch(GUI$OS,
                                  "windows" = {
                                      if (file.exists(file.path(path.expand("~"), "iNZightVIT", "Saved Plots")))
                                          f <- file.path(path.expand("~"), "iNZightVIT", "Saved Plots")
                                      else
                                          f <- getwd()
                                      f
                                  },
                                  "mac" = ,
                                  "linux" = {
                                      if (file.exists(file.path(path.expand("~"), "Documents", "iNZightVIT", "Saved Plots")))
                                          f <- file.path(path.expand("~"), "Documents", "iNZightVIT", "Saved Plots")
                                      else
                                          f <- getwd()
                                      f
                                  })
            fLoc <- gedit(initial.dir, editable = TRUE)
            fBrowse <- gbutton("Browse", handler = function(h, ...) {
                                   ff <- gfile("Select save location ...", type = "selectdir",
                                               initial.dir = svalue(fLoc))
                                   if (length(ff) == 1)
                                       svalue(fLoc) <- ff
                               })
            tbl[ii, 1, anchor = c(1, 0), expand = TRUE] <- lbl
            tbl[ii, 2:4, anchor = c(-1, 0), expand = TRUE] <- fLoc
            tbl[ii, 5:6, expand = TRUE] <- fBrowse
            ii <- ii + 1
            

            lbl <- glabel("File name :")
            font(lbl) <- list(weight = "bold")
            fName <- gedit("")
            fExt <- glabel(gsub(".+\\(|\\)", "", svalue(fileType)))
            tbl[ii, 1, anchor = c(1, 0), expand = TRUE] <- lbl
            tbl[ii, 2:4, expand = TRUE] <- fName
            tbl[ii, 5, anchor = c(-1, 0), expand = TRUE] <- fExt
            ii <- ii + 1
            
            add(g, tbl)

            addSpace(g, 10)
            glabel("Developmental - only working for base plots.\nDoesn't check for existing file.", container = g)
            
            addSpring(g)
            btnGrp <- ggroup(container = g)
            
            addSpring(btnGrp)
            cnclBtn <- gbutton("Cancel", handler = function(h, ...) dispose(w), container = btnGrp, expand = TRUE)
            saveBtn <- gbutton("Save", container = btnGrp, expand = TRUE,
                               handler = function(h, ...) {
                                   if (svalue(fName) == "") {
                                       gmessage("No file name", icon = "error", parent = w)
                                       return()
                                   }
                                   
                                   f <- file.path(svalue(fLoc), paste0(svalue(fName), svalue(fExt)))
                                   dim <- dev.size("px")
                                   
                                   filetypes[[svalue(fileType)]](file = f,
                                                                 width = dim[1],
                                                                 height = dim[2])
                                   fun()
                                   dev.off()

                                   dispose(w)
                               })

            addHandlerChanged(fileType, function(h, ...) {
                                  svalue(fExt) <- gsub(".+\\(|\\)", "", svalue(fileType))
                              })
        })
    )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZPreferencesWin.R"
iNZPrefsWin <- setRefClass(
    "iNZPrefsWin",
    fields = list(
        GUI = "ANY"
        ),
    methods = list(
        initialize = function(gui = NULL) {
            initFields(GUI = gui)

            prefs <- GUI$preferences
            
            if (!is.null(GUI)) {
               try(dispose(GUI$modWin), silent = TRUE) ## close any current mod windows
               GUI$modWin <<- gwindow("iNZight Preferences", parent = GUI$win,
                                      width = 600, height = 400)

               g <- gvbox(container = GUI$modWin, expand = FALSE)
               g$set_borderwidth(5)

               trackOpt <- gcheckbox("Allow iNZight to collect annonymous usage information",
                                     checked = prefs$track)
               add(g, trackOpt)

               updOpt <- gcheckbox("Check for updates when iNZight launched (NOTE: this will not automatically update iNZight)",
                                     checked = prefs$check.updates)
               add(g, updOpt)


               addSpace(g, 30)

               lab <- glabel("Default Window Size (will take effect next time you start iNZight)")
               font(lab) <- list(weight = "bold")
               add(g, lab, anchor = c(-1, -1))

               tbl <- glayout()
               tbl[1, 1] <- glabel("Width (px): ")
               winWd <- gedit(prefs$window.size[1], width = 4)
               tbl[1, 2] <- winWd
               tbl[1, 4] <- glabel("Height (px): ")
               winHt <- gedit(prefs$window.size[2], width = 4)
               tbl[1, 5] <- winHt

               useCur <- gbutton("Use current dimensions")
               addHandlerClicked(useCur, function(h, ...) {
                   curDim <- size(GUI$win)
                   svalue(winWd) <- curDim[1]
                   svalue(winHt) <- curDim[2]
               })
               tbl[1, 8] <- useCur

               useDef <- gbutton("Reset default")
               addHandlerClicked(useDef, function(h, ...) {
                   curDim <- GUI$defaultPrefs()$window.size
                   svalue(winWd) <- curDim[1]
                   svalue(winHt) <- curDim[2]
               })
               tbl[1, 9] <- useDef
               
               add(g, tbl)

               addSpace(g, 30)

               popoutWin <- gcheckbox("Use dual-window display mode", checked = prefs$popout)

               add(g, popoutWin)
               
               
               addSpring(g)

               ## CANCEL / OK buttons
               btnGrp <- ggroup(container = g, expand = FALSE)
               addSpring(btnGrp)

               ## okButton <- gbutton("Apply", expand = FALSE, cont = btnGrp,
               ##               handler = function(h, ...) {
               ##                   GUI$preferences <<- list(track = svalue(trackOpt),
               ##                                            check.updates = svalue(updOpt),
               ##                                            window.size =
               ##                                                as.numeric(c(svalue(winWd), svalue(winHt))),
               ##                                            popout = svalue(popoutWin))
               ##                   GUI$savePreferences()
               ##               })

               ## addSpace(btnGrp, 15)

               cancelButton <- gbutton("Cancel", expand = FALSE, cont = btnGrp,
                                       handler = function(h, ...) dispose(GUI$modWin))

               addSpace(btnGrp, 15)
               
               okButton <- gbutton("Save", expand = FALSE, cont = btnGrp,
                             handler = function(h, ...) {
                                 GUI$preferences <<- list(track = svalue(trackOpt),
                                                          check.updates = svalue(updOpt),
                                                          window.size =
                                                          as.numeric(c(svalue(winWd), svalue(winHt))),
                                                          popout = svalue(popoutWin))
                                 GUI$savePreferences()
                                 dispose(GUI$modWin)
                             })

               addSpace(btnGrp, 15)

               ## extra space between buttons and bottom of window
               addSpace(g, 15)
               
               visible(GUI$modWin) <<- TRUE
           }
        }
        )
    )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZQuickexploreWin.R"
## --------------------------------------------
## The super class for the Quick explore window
## The different windows that are opened through the
## 'Quick Explore' sub-menu are subclasses of this superclass
## --------------------------------------------

iNZQuickexploreWin <- setRefClass(
    "iNZQuickexploreWin",
    fields = list(
        GUI = "ANY"
        ),
    methods = list(
        initialize = function(gui=NULL) {
            initFields(GUI = gui)
            if (!is.null(GUI)) {
                GUI$modWin <<- gwindow(visible = FALSE,
                                   parent = GUI$win)
                size(GUI$modWin) <<- c(700, 400)
            }
        })
    )

iNZExploreMissing <- setRefClass(
    "iNZExploreMissing",
    contains = "iNZQuickexploreWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Explore Missing Values"
            oldWd <- options(width = 1000)  # so it doesn't wrap
            dd <- GUI$getActiveData()
            g <- gtext(text = paste(iNZightMR::calcmissing(dd,
                           print = FALSE,
                           final = FALSE),
                           collapse = "\n"),
                       expand = TRUE, cont = GUI$modWin, wrap = FALSE,
                       font.attr = list(family = "monospace"))
            visible(GUI$modWin) <<- TRUE
            dev.new()
            iNZightMR::plotcombn(dd)
            options(width = oldWd$width)
        })
    )

iNZallSummaries <- setRefClass(
    "iNZallSummaries",
    contains = "iNZQuickexploreWin",
    methods = list(
        initialize = function(gui) {
            callSuper(gui)
            svalue(GUI$modWin) <<- "Explore all 1-way Summaries"
            oldWd <- options(width = 1000)  # so it doesn't wrap
            g <- gtext(text = iNZightPlots::exploreAllSummaries(GUI$getActiveData()),
                       expand = TRUE, cont = GUI$modWin, wrap = FALSE,
                       font.attr = list(family = "monospace"))
            visible(GUI$modWin) <<- TRUE
            options(width = oldWd$width)
        })
    )

iNZallPlots <- setRefClass(
    "iNZallPlots",
    contains = "iNZQuickexploreWin",
    methods = list(
        initialize = function(gui) {
            ## Instead, we will make a gui that cycles through them ...
            ign <- gwindow("...", visible = FALSE)
            tag(ign, "dataSet") <- gui$getActiveData()
            e <- list(obj = ign)
            e$win <- gui$win
            iNZightModules::allUniPlots(e)
        })
    )

iNZall2Plots <- setRefClass(
    "iNZall2Plots",
    contains = "iNZQuickexploreWin",
    methods = list(
        initialize = function(gui) {
            ## Instead, we will make a gui that cycles through them ...
            ign <- gwindow("...", visible = FALSE)
            tag(ign, "dataSet") <- gui$getActiveData()
            e <- list(obj = ign)
            e$win <- gui$win
            iNZightModules::allBivarPlots(e)
        })
    )

iNZscatterMatrix <- setRefClass(
    "iNZscatterMatrix",
    contains = "iNZQuickexploreWin",
    methods = list(
        initialize = function(gui) {
            ign <- gwindow("...", visible = FALSE)
            tag(ign, "dataSet") <- gui$getActiveData()
            e <- list(obj = ign)
            e$win <- gui$win
            iNZightModules::scatterPlotMatrix(e)
        })
    )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZSaveWin.R"
iNZSaveWin <- setRefClass(
    "iNZSaveWin",
    fields = list(
        GUI = "ANY",
        saveFileWin = "ANY"
        ),
    methods = list(
        initialize = function(gui, type = c("plot", "data"), ...) {
            initFields(GUI = gui)
            if(!(type %in% c("plot", "data")))
                gmessage("Can't save this type of object")
            else {
                saveFileWin <<- gwindow("File Browser", parent = GUI$win)
                fileMainGp <- ggroup(container = saveFileWin,
                                     horizontal = FALSE)
                filetbl <- glayout(container = fileMainGp)

                l <- list(plot = list(), data = list())
                l$plot[[gettext("Bitmap Image (BMP)")]] <- "bmp"
                l$plot[[gettext("JPEG Image (JPG)")]] <- "jpg"
                l$plot[[gettext("Portable Document Format (PDF)")]] <- "pdf"
                l$plot[[gettext("PNG Image (PNG)")]] <- "png"
                l$plot[[gettext("TIFF Image (TIFF)")]] <- "tiff"
                l$data[[gettext("Comma Separated Values (CSV)")]] <- "csv"
                l$data[[gettext("Tab Separated Values (TXT)")]] <- "txt"
                l$data[[gettext("Space Separated Values (TXT)")]] <- "txt"

                fileExtensions <- l[[type]]
                pop <- function(x) x[-length(x)]
                popchar <- function(str) paste(pop(unlist(strsplit(str, ""))),
                                               collapse = "")

                filterList <- lapply(fileExtensions, function(i)
                                     list(patterns = paste("*.", i, sep = "")))

                ll = list()
                ll$"All files " <- list(patterns = "*")
                filterList <- c(ll, filterList)

                filetbl[2, 2] <- glabel("Local file")
                filetbl[2, 3] <- (filebrowse <- gfilebrowse(
                    text = "Specify a file",
                    action = invisible,
                    type = "save",
                    container = filetbl,
                    filter = filterList,
                    quote = FALSE))
                filetbl[3, 2:3] <- gseparator(container = filetbl)
                filetbl[4, 2] = gettext("File type is")
                filetbl[4, 3] <- (filetype = gcombobox(
                                      c("<use file extension to determine>",
                                        names(filterList[!filterList %in% ll])),
                                      container = filetbl))
                buttonGp <- ggroup(container = fileMainGp)
                addSpring(buttonGp)
                extra.args <- list(...)
                okButton <- gbutton("OK",
                                    handler = function(h, ...) {
                                        l1 <- list(
                                            type = type,
                                            fileBrowse = filebrowse,
                                            filetype = filetype,
                                            fileExtensions = fileExtensions
                                            )
                                        l2 <- modifyList(l1, extra.args)
                                        do.call(.self$okButtonHandler, l2)
                                    })
                cancelButton <- gbutton("Cancel",
                                        handler = function(h,...)  cancelButtonHandler())
                add(buttonGp, okButton)
                add(buttonGp, cancelButton)
            }
        },
        okButtonHandler = function(type, fileBrowse, filetype,
            fileExtensions, ...) {
            theFile <- svalue(fileBrowse)
            ext <- NULL ## the extension, figure out
            ## list of possible extensions for each type
            poss.ext <- list(plot = c("pdf", "png", "jpg", "jpeg",
                                 "tiff", "bmp"),
                             data = c("csv", "txt"))
            ## list of default extensions for each type
            def.ext <- list(plot = "png", data = "csv")
            if (theFile != "Specify a file") {
                fileType <- svalue(filetype)
                if (fileType != "<use file extension to determine>") {
                    ext <- fileExtensions[[fileType]][1]
                } else if (is.null(ext)) {
                    tmp <- unlist(strsplit(basename(theFile), split="\\."))
                    ext <- tolower(tmp[length(tmp)])
                    ## In the case where we aren't able to assign a usable
                    ## file extension, assume default
                    if (! ext %in% poss.ext[[type]])
                        ext <- def.ext[[type]]
                }
                result <- iNZSaveFile(theFile, ext,
                                      fileType = svalue(filetype, index=TRUE),
                                      ...)
                if(is.logical(result) && result)
                    dispose(saveFileWin)
                else {
                    if (is.list(result))
                        msg <- result$msg
                    else
                        msg <- "Could not save file"
                    gmessage(msg, icon="error")
                }
            }
        },
        cancelButtonHandler = function() {
            dispose(saveFileWin)
        })
    )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZSurveyDesign.R"
iNZSurveyDesign <- setRefClass("iNZSurveyDesign",
                               fields = list(
                                   GUI = "ANY",
                                   designWin = "ANY"
                                   ),
                               methods = list(
                                   initialize = function(GUI) {
                                       initFields(GUI = GUI)

                                       if (is.null(GUI$getActiveData())) {
                                           gerror("Please import a data set first.",
                                                    title = "No data set", icon = "error")
                                           return()
                                       } else if ((names(GUI$getActiveData())[1] == "empty")) {
                                           gmessage("Please import a data set first.",
                                                    title = "No data set", icon = "error")
                                           return()
                                       }


                                       gmessage(paste(
                                           "The Survey functionality is still under development. Please use with caution",
                                           "and for experimentation only.",
                                           "\n\nIf you discover any bugs, let us know by emailing",
                                           "inzight_support@stat.auckland.ac.nz."),
                                                title = "Survey Analysis BETA", parent = GUI$win, icon = "warning")

                                       designWin <<- gwindow("Specify survey design", parent = GUI$win,
                                                            width = 450, height = 300, visible = FALSE)
                                       gg <- gvbox(container = designWin, expand = TRUE)
                                       gg$set_borderwidth(5)
                                       
                                       ttl <- glabel("Specify Survey Design", cont = gg)
                                       font(ttl) <- list(weight = "bold", size = 11)
                                       
                                       addSpace(gg, 5)
                                       tbl <- glayout(cont = gg)
                                       
                                       vars <- c("", colnames(GUI$getActiveData()))
                                       
                                       ii <- 2
                                       lbl <- glabel("Strata variable: ")
                                       tbl[ii, 1, expand = TRUE, fill = FALSE, anchor = c(1, 0)] <- lbl
                                       stratVar <- gcombobox(vars)
                                       tbl[ii, 2, expand = TRUE] <- stratVar
                                       
                                       ii <- ii + 1
                                       lbl <- glabel("1st stage clustering variable: ")
                                       tbl[ii, 1, expand = TRUE, fill = FALSE, anchor = c(1, 0)] <- lbl
                                       clus1Var <- gcombobox(vars)
                                       tbl[ii, 2, expand = TRUE] <- clus1Var
                                       
                                       ii <- ii + 1
                                       lbl <- glabel("2nd stage clustering variable: ")
                                       tbl[ii, 1, expand = TRUE, fill = FALSE, anchor = c(1, 0)] <- lbl
                                       clus2Var <- gcombobox(vars)
                                       tbl[ii, 2, expand = TRUE] <- clus2Var

                                       ii <- ii + 1
                                       nestChk <- gcheckbox("Use nested sampling")
                                       tbl[ii, 2, expand = TRUE] <- nestChk
                                       
                                       ii <- ii + 2
                                       lbl <- glabel("Weighting variable: ")
                                       tbl[ii, 1, expand = TRUE, fill = FALSE, anchor = c(1, 0)] <- lbl
                                       wtVar <- gcombobox(vars)
                                       tbl[ii, 2, expand = TRUE] <- wtVar

                                       ii <- ii + 1
                                       lbl <- glabel("Finite population correction: ")
                                       tbl[ii, 1, expand = TRUE, fill = FALSE, anchor= c(1, 0)] <- lbl
                                       fpcVar <- gcombobox(vars, editable = TRUE)
                                       tbl[ii, 2, expand = TRUE] <- fpcVar

                                       
                                       
                                       addSpring(gg)
                                       
                                       btnGrp <- ggroup(cont = gg)
                                       addSpace(btnGrp, 10)
                                       #advancedBtn <- gbutton("Advanced", cont = btnGrp)
                                       addSpring(btnGrp)
                                       cancelBtn <- gbutton("Cancel", cont = btnGrp)
                                       addSpace(btnGrp, 10)
                                       createBtn <- gbutton("OK", cont = btnGrp)
                                       addSpace(btnGrp, 10)
                                       
                                       addSpace(gg, 10)

                                       #addHandlerClicked(advancedBtn, handler = function(h, ...) {
                                       #})
                                       addHandlerClicked(cancelBtn, handler = function(h, ...) {
                                           dispose(designWin)
                                       })
                                       addHandlerClicked(createBtn, handler = function(h, ...) {
                                           strat <- svalue(stratVar, index = FALSE)
                                           clus1 <- svalue(clus1Var, index = FALSE)
                                           clus2 <- svalue(clus2Var, index = FALSE)
                                           wts <- svalue(wtVar, index = FALSE)
                                           fpc <- svalue(fpcVar, index = FALSE)
                                           nest <- as.character(svalue(nestChk))

                                           if (strat == "") strat <- NULL
                                           if (clus1 == "") clus1 <- NULL
                                           if (clus2 == "") clus2 <- NULL
                                           if (wts == "") wts <- NULL
                                           if (fpc == "") fpc <- NULL

                                           GUI$getActiveDoc()$getModel()$setDesign(
                                               strat, clus1, clus2, wts, nest, fpc, gui = GUI
                                               )

                                           setOK <- try(GUI$getActiveDoc()$getModel()$createSurveyObject(), TRUE)
                                           
                                           if (!inherits(setOK, "try-error")) {
                                               if (is.null(strat) & is.null(clus1) &
                                                   is.null(clus2) & is.null(wts) & is.null(fpc)) {
                                                   ## ENABLE A WHOLE LOT OF STUFF
                                                   enabled(GUI$menubar$menu_list[["Dataset"]][[3]]) <<- TRUE
                                                   enabled(GUI$menubar$menu_list[["Variables"]][["Numeric Variables"]][[2]]) <<- TRUE
                                                   enabled(GUI$menubar$menu_list[["Plot"]][[3]]) <<- TRUE
                                                   #enabled(GUI$sumBtn) <<- TRUE
                                                   enabled(GUI$infBtn) <<- TRUE
                                               } else {
                                                   ## DISABLE A WHOLE LOT OF STUFF
                                                   enabled(GUI$menubar$menu_list[["Dataset"]][[3]]) <<- FALSE
                                                   enabled(GUI$menubar$menu_list[["Variables"]][["Numeric Variables"]][[2]]) <<- FALSE
                                                   enabled(GUI$menubar$menu_list[["Plot"]][[3]]) <<- FALSE
                                                   #enabled(GUI$sumBtn) <<- FALSE
                                                   enabled(GUI$infBtn) <<- FALSE

                                                   dispose(designWin)
                                               }
                                           } else {
                                               gmessage(paste0(
                                                   "There is a problem with the specification of the survey design:\n\n",
                                                   setOK
                                                   ), icon = "error")
                                           }                                           
                                       })


                                       ## Populate the lists:
                                       curDes <- GUI$getActiveDoc()$getModel()$getDesign()
                                       if (!is.null(curDes)) {
                                           if (!is.null(curDes$strata))
                                               svalue(stratVar) <- curDes$strata
                                           if (!is.null(curDes$clus1))
                                               svalue(clus1Var) <- curDes$clus1
                                           if (!is.null(curDes$clus2))
                                               svalue(clus2Var) <- curDes$clus2
                                           if (!is.null(curDes$nest))
                                               svalue(nestChk) <- curDes$nest
                                           if (!is.null(curDes$wt))
                                               svalue(wtVar) <- curDes$wt
                                           if (!is.null(curDes$fpc))
                                               svalue(fpcVar) <- curDes$fpc
                                       }

                                       visible(designWin) <<- TRUE
                                   }
                                   )
                               )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZViewSwitcher.R"
iNZViewSwitcher <- setRefClass(
    "iNZViewSwitcher",
    fields = list(
        GUI = "ANY",
        viewGroup = "ANY",
        dataBtn = "ANY",
        listBtn = "ANY",
        ## max size before dataview gets deactived
        dataThreshold = "numeric"
        ),
    methods = list(
        initialize = function(gui, dataThreshold) {
            initFields(GUI = gui,
                       dataThreshold = dataThreshold)
            viewGroup <<- ggroup()
            addSpring(viewGroup)
            dataBtn <<- gbutton("View Data Set",
                                handler = function(h,...) .self$viewData(h,...))
            listBtn <<- gbutton("View Variables",
                                handler = function(h,...) .self$viewList(h,...))
            font(dataBtn) <<- list(weight="bold", family = "normal",
                                   color = "navy")
            font(listBtn) <<- list(weight="bold", family = "normal",
                                   color = "navy")
            dataSet <- GUI$getActiveData()
            ## if the data size is below threshold, start in data view,
            ## otherwise start don't allow view switching
            enabled(dataBtn) <<- FALSE
            if (nrow(dataSet) * ncol(dataSet) >= dataThreshold)
                enabled(listBtn) <<- FALSE
            
            add(viewGroup, dataBtn)
            add(viewGroup, listBtn)
        },
        viewData = function(h, ...) {
            dataSet <- GUI$getActiveData() ## get the active dataSet
            if(is.null(dataSet)){
                gmessage("Please load a new data set (with named columns)",
                         parent = GUI$win)
            } else {
                if((names(dataSet)[1] == "empty"))
                    gmessage("Please load a new data set", parent = GUI$win)
                else {
                    enabled(h$obj) = FALSE
                    GUI$dataViewWidget$dataView() ## change to data.frame view
                    enabled(listBtn) <<- TRUE
                }
            }
        },
        viewList = function(h, ...) {
            dataSet <- GUI$getActiveData() ## get the active dataSet
            if(is.null(dataSet)){
                gmessage("Please load a new data set (with named columns)",
                         parent = GUI$win)
            } else {
                if((names(dataSet)[1] == "empty"))
                    gmessage("Please load a new data set", parent = GUI$win)
                else {
                    enabled(h$obj) = FALSE
                    GUI$dataViewWidget$listView() ## change to list of col view
                    enabled(dataBtn) <<- TRUE
                }
            }
        },
        ## check wich view is activate and the current data size
        ## and enable the buttongs accordingly
        updateWidget = function() {
            dataSet <- GUI$getActiveData()
            if (nrow(dataSet) * ncol(dataSet) >= dataThreshold) {
                enabled(listBtn) <<- FALSE
                enabled(dataBtn) <<- FALSE
            } else {
                if (visible(GUI$dataViewWidget$dfView)) {
                    enabled(listBtn) <<- TRUE
                    enabled(dataBtn) <<- FALSE
                } else {
                    enabled(listBtn) <<- FALSE
                    enabled(dataBtn) <<- TRUE
                }
            }
        })
    )
#line 1 "/Users/tom/iNZight/iNZight/R/iNZight-package.R"
##' @import methods grid RGtk2 gdata gWidgets2 gWidgets2RGtk2 cairoDevice grDevices objectProperties iNZightPlots reshape2 plyr survey
##' @importFrom iNZightTools newdevice
NULL


#line 1 "/Users/tom/iNZight/iNZight/R/iNZight.R"
##' iNZight GUI
##'
##' Starts iNZight
##' @title iNZight GUI
##' @param data a data frame
##' @param disposeR logical, if \code{TRUE}, R will quit when iNZight is closed.
##' @return NULL
##' @author Marco Kuper
##' @export
iNZight <- function(data = NULL, disposeR = FALSE) {
    gui <- iNZGUI$new()
    gui$initializeGui(data, disposeR)
}
